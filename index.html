<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="utf-8">
<title>Crucian Carp</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="naver-site-verification" content="2316a6af47a7b653c7f6af966d7c718fb98027ed">

<link rel="canonical" href="https://aaronryu.github.io/">


    <meta name="description" content="Cool heads but warm hearts">
<meta property="og:type" content="website">
<meta property="og:title" content="Crucian Carp">
<meta property="og:url" content="https://aaronryu.github.io/index.html">
<meta property="og:site_name" content="Crucian Carp">
<meta property="og:description" content="Cool heads but warm hearts">
<meta property="og:locale" content="en">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Crucian Carp">
<meta name="twitter:description" content="Cool heads but warm hearts">



<link rel="alternative" href="atom.xml" title="Crucian Carp" type="application/atom+xml">



<link rel="icon" href="/images/favicon.svg">


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bulma@0.7.2/css/bulma.css">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.4.1/css/all.css">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/androidstudio.css">


    
    
    
    <style>body>.footer,body>.navbar,body>.section{opacity:0}</style>
    

    
    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css">
    

    
    

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.css">


    
    
    
    

<link rel="stylesheet" href="/css/back-to-top.css">


    
    
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-134840627-1"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134840627-1');
</script>


    
    
    
    

    
    
<link rel="stylesheet" href="/css/progressbar.css">
<script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>

    
    
    

    
    
    


<link rel="stylesheet" href="/css/style.css">
</head>
<body class="is-2-column">
    <nav class="navbar navbar-main">
    <div class="container">
        <div class="navbar-brand is-flex-center">
            <a class="navbar-item navbar-logo" href="/">
            
                Crucian Carp
            
            </a>
        </div>
        <div class="navbar-menu">
            
            <div class="navbar-start">
                
                <a class="navbar-item is-active" href="/">Home</a>
                
                <a class="navbar-item" href="/archives">Archives</a>
                
                <a class="navbar-item" href="/categories">Categories</a>
                
                <a class="navbar-item" href="/about">About</a>
                
            </div>
            
            <div class="navbar-end">
                
                
                
                <a class="navbar-item search" title="Search" href="javascript:;">
                    <i class="fas fa-search"></i>
                </a>
                
            </div>
        </div>
    </div>
</nav>
    
    <section class="section">
        <div class="container">
            <div class="columns">
                <div class="column is-9-tablet is-9-desktop is-9-widescreen has-order-2 column-main">
    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <!-- <time class="level-item has-text-grey" datetime="2019-12-14T17:32:23.000Z">2019-12-15</time> -->
                <div class="level-item has-text-grey">2019-12-15</div>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/Licenses/">Licenses</a>
                </div>
                
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/12/15/one-page-for-regular-expression/">한 장으로 보는 정규표현식</a>
            
        </h1>
        <div class="content">
            <h1 id="중요성"><a href="#중요성" class="headerlink" title="중요성"></a>중요성</h1><p>개인적으로 좋아했던 구글 Tech Lead 유튜버가 개발자라면 당연히 알아야할 몇가지 스킬을 업로드<a href="https://www.youtube.com/watch?v=3MtrUf81k6c" target="_blank" rel="noopener">^1</a>한적이 있다.</p>
<ol>
<li>Regular expressions</li>
<li>SQL</li>
<li>Debugging Skills (problem solving).</li>
<li>Tooling language</li>
<li>Anti-Social skill </li>
</ol>
<p>이 중 오늘의 주제는 가장 첫번째에 언급된 <strong>정규표현식</strong>이다. 중간에 5번이라는 스파이가 있는듯 한데 개발자는 사실상 코딩보단 말을 많이하는 직업이라 생각해서 그리 좋은 전략은 아닌듯하다. <strong>정규표현식</strong>은 학사때도 나중에 공부해야지 하고 메모는 많이 해놓았는데 정작 제대로 외우진 않고 매번 필요할때마다 찾아 쓴듯하다. 최근에 정리하였는데 나름 문법처럼 분류해서 외우면 쉽다. 사실 Regex 는 Tech Lead 말대로 개발하는데 너무 널리 사용된다. 텍스트 검색, 정확히는 패턴 매칭에 사용되는데 검색이라면 아래같이 수많은 유즈케이스들이 있다.</p>
<ul>
<li>grep 을 통한 로그/텍스트 분석</li>
<li>개발하고 있는 코드/디렉토리 검색</li>
<li>commit 이전 코드 체킹</li>
<li>웹 크롤링</li>
<li>URL 파싱</li>
<li>값/포맷 validation</li>
</ul>
<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>Regex 는 처음보았을때나 공부하기 전까지는 암호내지 외계어처럼 보이긴 한다. 우리가 흔히 접하는 언어는 semantic 이 word 혹은 그 조합으로 표현되지만, semantic 들이 각각 하나의 charactor 에 매핑되어있는건 암호체계와 동일하기 때문이다. 이것도 syntax 로 분류하면 아래와 같이 나뉘어지는데, 정규표현식을 익히는데 많은 도움이 된다.</p>
<center><img src="/2019/12/15/one-page-for-regular-expression/one-page-regex.png"></center>

<p>기본적으로 특정 단어를 검색하기 위해 정규표현식을 사용하는데, 단순히 찾고싶은 <strong>1. 특정 단어</strong>를 명시하는 방법도 있지만 <strong>2. 글자나 숫자 조합</strong>으로써 단어를 명시할수도 있다. 정규표현식은 이에 두 가지 방법을 제공한다.</p>
<h1 id="기본"><a href="#기본" class="headerlink" title="기본"></a>기본</h1><h2 id="단어"><a href="#단어" class="headerlink" title="단어"></a>단어</h2><p>간단하게 검색하고 싶은 <strong>특정 단어</strong>만 명시하면 된다.<br>만약 여러 단어를 한번에 검색하고 싶다면 <strong>()</strong> 를 사용하여 <strong>|</strong> 를 통해 다수의 단어를 넣으면 된다.</p>
<h2 id="글자-타입"><a href="#글자-타입" class="headerlink" title="글자 - 타입"></a>글자 - 타입</h2><p><strong>특정 글자</strong>를 명시하고 싶을땐 <strong>단어</strong>와 같은 방식으로 사용하면 되는데 <strong>[]</strong>를 통해 여러 글자를 찾을수도 있고, <strong>[]</strong> 내부에서 확장 표현을 통해 A 부터 Z 까지(<strong>A-Z</strong>) 규칙을 추가하거나 특정 글자를 제외할 수도 있다.</p>
<p>숫자 글자를 검색하고 싶다면 위에서 배운대로 <strong>[0-9]</strong> 도 좋지만 <strong>‘숫자’ 글자 타입</strong>을 명시하여 검색할수도 있다. <strong>글자의 타입</strong>을 명시하기 위한것이 역슬래시(\)며 예를 들면 <strong>‘숫자’ 글자 타입</strong>은 <strong>\d</strong> 로 표현할 수 있고 <strong>‘숫자가 아닌’ 글자 타입</strong>은 <strong>\D</strong> 와 같이 대문자로 표기할 수 있다.</p>
<hr>
<h1 id="확장"><a href="#확장" class="headerlink" title="확장"></a>확장</h1><h2 id="앞-뒤"><a href="#앞-뒤" class="headerlink" title="앞/뒤"></a>앞/뒤</h2><p>특정 단어 혹은 글자를 찾더라도 글의 <strong>가장 앞쪽에</strong> 혹은 <strong>가장 뒷쪽에</strong> 존재하는 것을 찾고 싶을때 사용한다.</p>
<h2 id="횟수"><a href="#횟수" class="headerlink" title="횟수"></a>횟수</h2><p>특정 단어 혹은 글자가 <strong>몇번 반복된 것</strong>을 검색하고 싶은지 명시할 수 있다.</p>
<blockquote>
<p>(abc){1} = abc<br>(abc){1,3} = abc, abcabc, abcabcabc<br>(abc)? = (공백), abc<br>(abc)+ = abc, abcabc …</p>
</blockquote>
<h2 id="캡쳐"><a href="#캡쳐" class="headerlink" title="캡쳐"></a>캡쳐</h2><p>앞부분에서 설명하였듯 패턴으로 검색할 단어를 집합으로 묶을때 사용하거나 <strong>검색한 결과물</strong>들을 활용하려고 할때 결과값을 저장하는 역할을 한다.</p>
<hr>
<p>정규표현식은 한번 배워두면 어떤 개발 언어에서든 모든곳에서 범용적으로 사용가능하며, 개발에서 활용할 수 있는 경우의 수가 매우 많아 유용하다. 이렇게 정리함으로써 이젠 매번 검색할일 없이 잘 사용할 수 있을듯하다.</p>

        </div>
        
        
        
    </div>
</div>










    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <!-- <time class="level-item has-text-grey" datetime="2019-08-10T06:31:23.000Z">2019-08-10</time> -->
                <div class="level-item has-text-grey">2019-08-10</div>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/Licenses/">Licenses</a>
                </div>
                
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/08/10/software-licences/">오픈 소스(공개 소프트웨어)의 다양한 라이센스들</a>
            
        </h1>
        <div class="content">
            <h1 id="GPL-General-Public-License-GNU-GPL"><a href="#GPL-General-Public-License-GNU-GPL" class="headerlink" title="GPL (General Public License, GNU GPL)"></a><strong>GPL</strong> (General Public License, GNU GPL)</h1><p>공개(자유) 소프트웨어 철학의 조상에 해당하며 그만큼 보수적입니다.</p>
<blockquote>
<p>일반 라이센스는 SW에 대한 공유와 수정의 자유를 제한하려는 목적을 가진 반면<br>GPL은 공유와 수정의 자유를 보장하기 위한 규정</p>
</blockquote>
<ul>
<li><strong>상업적 사용이 가능</strong>하다.</li>
<li>다만, <strong>공개 및 상업적 사용</strong>시 <strong>무료 공개</strong>를 해야한다.</li>
<li><strong>내부 사용시</strong> (개인, 기관, 단체 내부) <strong>무료 공개의 의무가 없다.</strong></li>
<li>GPL 코드의 일부만 사용하더라도 GPL 라이센스를 갖는다.</li>
</ul>
<h1 id="LGPL-Lesser-General-Public-License-GNU-LGPL"><a href="#LGPL-Lesser-General-Public-License-GNU-LGPL" class="headerlink" title="LGPL (Lesser General Public License, GNU LGPL)"></a><strong>LGPL</strong> (Lesser General Public License, GNU LGPL)</h1><p>GPL 은 GPL 인 라이브러리를 사용만해도 2차 저작물에 GPL 이 적용되어,<br>상업적 사용은 가능하지만 소스 코드가 공개되어야하는 단점을 갖습니다.</p>
<blockquote>
<p>FSF(Free Software Foundation) 는 이런 이유로 GPL 라이브러리 사용 기피 방지 및 오픈 소스의 기여를 위해<br>코드 자체를 수정하지 않는한 공개 조항을 강제하지 않습니다.</p>
</blockquote>
<ul>
<li><strong>기본적으로는 GPL 과 동일</strong>하다.</li>
<li>LGPL 코드를 <strong>단순 사용</strong> 시 <strong>무료 공개의 의무가 없다.</strong> 사용했음만을 명시하면 된다.</li>
<li>LGPL 코드를 <strong>수정 사용</strong> 시 <strong>무료 공개</strong>를 해야한다.</li>
</ul>
<h1 id="BSD-Berkeley-Software-Distribution-License-amp-MIT-License"><a href="#BSD-Berkeley-Software-Distribution-License-amp-MIT-License" class="headerlink" title="BSD (Berkeley Software Distribution) License &amp; MIT License"></a><strong>BSD</strong> (Berkeley Software Distribution) License &amp; MIT License</h1><p>유닉스 계열 운영체제인 BSD 가 유닉스의 원 제작자인 AT&amp;T의 벨 연구소에게 소송을 당하게 되고,<br>그 이후 소스코드 작성자 이름 표기 외에 어떠한 저작권 내용이 없는 라이센스를 만들어 배포합니다.<br>추가로 MIT 는 BSD 와 거의 유사하여 따로 항목을 생성하지 않았습니다.</p>
<ul>
<li>소프트웨어계의 <strong>공공재</strong></li>
<li><strong>수정 가능, 자유로운 사용</strong></li>
<li><strong>공개의 의무가 없다.</strong></li>
</ul>
<p>초기 4조항 버전에서 조항이 하니씩 빠지면서 3조항, 2조항 버전이 있습니다.</p>
<h3 id="4조항-Original"><a href="#4조항-Original" class="headerlink" title="4조항 - Original"></a>4조항 - Original</h3><ul>
<li>광고에 <strong>원</strong> 저작권자 표기 필수</li>
<li>광고에 <strong>2차</strong> 저작권자 표기 불가</li>
</ul>
<h3 id="3조항-BSD-License-2-0"><a href="#3조항-BSD-License-2-0" class="headerlink" title="3조항 - BSD License 2.0"></a>3조항 - BSD License 2.0</h3><ul>
<li><del>광고에 <strong>원</strong> 저작권자 표기 필수</del> (제거)</li>
<li>광고에 <strong>2차</strong> 저작권자 표기 불가</li>
</ul>
<h3 id="2조항-FreeBSD-License"><a href="#2조항-FreeBSD-License" class="headerlink" title="2조항 - FreeBSD License"></a>2조항 - FreeBSD License</h3><ul>
<li>제품에 BSD 라이센스 내용과 <strong>원, 2차</strong> 저작권자를 표기해야하는 의무</li>
</ul>
<h1 id="5-Apache-License"><a href="#5-Apache-License" class="headerlink" title="5. Apache License"></a>5. Apache License</h1><p>BSD 라이센스는 공공재에 가까운 조항으로 <strong>2차 저작물에 대한 어떠한 특허도 요구할 수 없습니다.</strong></p>
<blockquote>
<p>Apache License 는 이 라이센스 코드를 자신이 활용하여 2차 저작물을 만들어도 그에 대해 특허를 가질 수 있습니다.<br>단 그렇게 하려면 해당 저작물에는 더 이상 Apache License 를 적용해선 안되겠지요.</p>
</blockquote>
<ul>
<li><strong>공개의 의무가 없다.</strong></li>
<li><strong>2차 변형물</strong>의 <strong>특허출원이 가능</strong>하다.</li>
<li>다만, 수정 여부 및 아파치 재단 이름과 라이센스 내용을 명시해야한다.</li>
</ul>
<hr>
<p>간단한 이해를 위해서 위와같이 정리해 보았는데요. 역시나 가장 재미있는것은 각 라이센스들이 왜? 어떻게? 에 해당하는 역사겠지요. 아래 링크<a href="https://meetup.toast.com/posts/101" target="_blank" rel="noopener">^1</a>에서 약간 상세하게 풀어놓았으니 참조하시면 큰 도움이 되실겁니다.</p>
<hr>
<p>참조</p>
<ol>
<li><a href="https://meetup.toast.com/posts/101" target="_blank" rel="noopener">https://meetup.toast.com/posts/101</a></li>
<li><a href="http://wiki.kldp.org/wiki.php/OpenSourceLicenseGuide" target="_blank" rel="noopener">http://wiki.kldp.org/wiki.php/OpenSourceLicenseGuide</a></li>
<li><a href="https://en.wikipedia.org/wiki/BSD_licenses" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/BSD_licenses</a></li>
<li><a href="https://en.wikipedia.org/wiki/MIT_License" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/MIT_License</a></li>
</ol>

        </div>
        
        
        
    </div>
</div>










    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <!-- <time class="level-item has-text-grey" datetime="2019-06-29T05:20:40.000Z">2019-06-29</time> -->
                <div class="level-item has-text-grey">2019-06-29</div>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Programming/">Programming</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Programming/Develop/">Develop</a>
                </div>
                
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/06/29/ios-design-patterns/">개발 일지 - iOS 아키텍쳐 패턴 MVC, MVVM, VIPER</a>
            
        </h1>
        <div class="content">
            <p>iOS 는 어떻게 보면 웹 어플리케이션 개발과 거의 유사하다고 생각됩니다. 다만 .NET WebForm 처럼 View 와 Controller 가 강결합 되어있어서, React.js 렌더링(프론트) 로직과 View 데이터를 전달해주는 Controller 를 따로 생각할 수 없습니다. 처음 스위프트 앱을 만들때 앱도 결국 웹 페이지와 거의 유사한 모델이기 때문에 웹 어플리케이션 개발 방식 그대로 개발하려했습니다. MVC 와 MVVM 에 대한 작은 경험을 그대로 적용해보았습니다.</p>
<h1 id="MVC-MVVM"><a href="#MVC-MVVM" class="headerlink" title="MVC / MVVM"></a>MVC / MVVM</h1><p>기존 웹 어플리케이션을 만들때 서버에서는 Controller, Application, Service, Repository 순으로 분류하여 작업했습니다. HTML, Javascript 는 View 에, JPA 같은 데이터 레벨은 Model 에, Model 을 활용한 모든 비지니스 로직과 View 와 POST/GET 통신으로 이벤트를 주고받는 중간 레이어는 Controller 에 해당합니다. 웹 어플리케이션에서 MVC 의 Controller 는 사실상 View Model 에 해당합니다. View 를 그려주는것이 아니라 View 를 그릴 수 있는 View Model 을 전달해주고 이를 처리하는건 클라이언트 엔진위인 Single Page 니까요. 이름만 들어도 알만한 프론트엔드 프레임워크인 .js 류들이 이런 패턴을 사용합니다.</p>
<h2 id="iOS-Massive-Controller-Actually-It’s-‘View’-not-a-Controller"><a href="#iOS-Massive-Controller-Actually-It’s-‘View’-not-a-Controller" class="headerlink" title="iOS - Massive Controller ? (Actually It’s ‘View’ not a Controller)"></a>iOS - Massive Controller ? (Actually It’s ‘View’ not a Controller)</h2><p>MVVM 패턴을 그대로 적용하려니 iOS 에서 에러가 발생합니다. 문제의 핵심은 <strong>View.storyboard 와 ViewController.swift 가 사실상 하나의 View</strong> 라는겁니다. 일반적으로 프론트엔드와 백엔드의 코드 베이스가 JS, Java 등으로 나뉘는것과 달리 iOS Swift 는 View 를 모두 .swift 에서 처리합니다. ViewController.swift 가 Controller 라는 이름을 갖고있지만 사실상 View 에 해당하고 View.storyboard 는 CSS/HTML 및 Router 가 포함된 개념으로 볼 수 있습니다.</p>
<p>스위프트는 본질적으론 MVC 패턴입니다. 다만 언어의 특성상 웹 어플리케이션의 MVC 와는 조금 구별해야하는것 처럼 보입니다. Controller 가 사실상 View 에 해당하는것이기 때문에 <strong>렌더에 해당하는 로직을 Controller 가 갖습니다.</strong> Service, Repository 모듈화를 잘한다해도 Controller 에는 <strong>View 렌더 로직</strong>뿐만 아니라, <strong>View 렌더에 필요한 데이터 조작에 대한 ‘일부’ 비지니스 로직</strong>도 포함하게 됩니다. 이 문제를 <strong>Massive Controller</strong> 라고 칭합니다.</p>
<h1 id="첫-개발-MVC"><a href="#첫-개발-MVC" class="headerlink" title="첫 개발 - MVC"></a>첫 개발 - MVC</h1><p>MVC 를 그대로 적용해본 제 첫 Swift 코드는 아래와 같았습니다. Bar 같은 여러 Asset 에 그려줄 데이터(Model)들을 받아와서 <strong>통계 데이터를 만들고(비지니스 로직)</strong> 그걸 <strong>View 에 주입해서 그려주었죠(View).</strong> 물론 보시는것과 같이 간단한 UIView 임에도 View 를 그리는 로직뿐만 아니라 <strong>View Model 에 대한 로직</strong>을 보실 수 있습니다.</p>
<center><img src="/2019/06/29/ios-design-patterns/mvc-code.png"></center>

<h1 id="리팩토링-MVVM"><a href="#리팩토링-MVVM" class="headerlink" title="리팩토링 - MVVM"></a>리팩토링 - MVVM</h1><p>Controller 가 커지면 무의식적으로 불안감이 발생합니다. 코드를 작성하면서 이건 정말 아닌것같은 느낌을 많이 받으며 리팩토링을 수행했습니다. 사실상 View 의 의미를 갖는 Controller 아래에 진정한 의미의(…) Controller인 View Model 을 두는 것입니다. <strong>모양, 색깔, 크기에 해당하는건 ViewController</strong> 에 두고 이에 필요한 <strong>ViewModel 은 ViewModelController</strong> 가 제공하는것입니다. 아래 예를 보면 <strong>ViewController 에서 ViewModel 인 mockBudgets 만을 잘 사용하고 있습니다.</strong> View(Controller)와 ViewModel(Controller) 바인딩 시 Rx 를 사용한다고 하는데 아직 이것까진 적용해보지 못했습니다.</p>
<center><img src="/2019/06/29/ios-design-patterns/mvvm-code.png"></center>

<h1 id="최근-VIPER"><a href="#최근-VIPER" class="headerlink" title="최근 - VIPER"></a>최근 - VIPER</h1><p>그러다 개인 프로젝트이기에 시간 날때마다 작업을 하니 제가 짠 코드도 몇일 몇주가 지나서 보면 너무 새로운 겁니다. 매번 개발을 진행할때, 더 진척이 생길때마다 코드를 다시 읽고 이해하는 시간이 길어졌고, 이건 코드들이 각 구체적이고 명확한 역할을 가지지도 않는다는걸로 이해됐습니다. 물론 Service, Repository 레벨의 코드들은 정리가 잘되어있어서 문제가 없었지만 View 는 아무리 적응하려해도 힘들더군요. 심지어 저는 Swift 를 처음 공부하면서 첫 어플리케이션을 만들고 있는것이니까요.</p>
<h2 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h2><p>VIPER 는 사실 View Model 의 이중화라고 보면 됩니다. 기존 비지니스 로직을 <strong>View 와 연관된 비지니스 로직</strong>, <strong>Model 데이터 레벨에 가까운 비지니스 로직 및 로깅, 네트워크 인스턴스 관리</strong> 이렇게 둘로 세분화한것으로 이해하면 쉽습니다. 전자를 <strong>Presentator</strong> 후자를 <strong>Interactor</strong> 라고 부릅니다. 그렇게 3개에서 4개의 컴포넌트가 되었습니다. 거기에 ViewController 간 화면 전환과 같은 segue 처리를 맡는 <strong>Router</strong> 가 추가되어 총 5개가 됩니다.</p>
<p>제 기존 코드에서 Model 은 이미 잘 정리되어있었기 때문에 이 부분은 Entity 와 Interactor 로 이미 분리되어 있었습니다. ViewModel 에도 최대한 Model 에 대한 로직은 넣지 않았으니까요. 기존 ViewController 에 몰려있던 <strong>View 에 대한 관련 비지니스 로직</strong>들을 <strong>Presentator</strong> 로 이관을 해보니 기존 View 에 View Model 로직들이 너무 많았었구나 싶었습니다. 또한 화면 전환(segue) 처리도 기존 ViewController 가 갖고있었는데 사실 이건 메타적으로 생각해보면 ViewController 간 이동을 조율하는것이므로 상위 레벨의 컴포넌트가 관리하는게 맞았습니다. segue 이동에 대해 매 ViewController 마다 중복해 갖는 보일러플레이트 코드들을 어떻게 중앙처리할까 했더니 VIPER 의 Router 를 사용하면 되는것이었습니다.</p>
<p>이렇게 적용을 해보았는데 컴포넌트가 5개이다 보니 기반 코드가 너무 많습니다. 귀찮았지만 앞으로의 생산성을 위해 적용해봤는데요. 효과는 아직 모르겠습니다. ReSwift(Redux on Swift) 개념도 있는듯한데 React.js 를 짧게 사용해보면서 컴포넌트들이 해봐야 고작 1, 2 레이어여서 굳이 Redux 를 적용할 필요가 없었기 때문에 배워보지 못했습니다. 이건 추후에 적용해보는걸로 해야겠습니다. 아무래도 새로운 아키텍쳐 패턴이나 요즘 핫하다는걸 적용해보면 좋겠지만 아무리 개인 개발이라도 빨리 배포를 하는게 더 중요하겠지요.</p>

        </div>
        
        
        
    </div>
</div>










    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <!-- <time class="level-item has-text-grey" datetime="2019-05-26T18:20:22.000Z">2019-05-27</time> -->
                <div class="level-item has-text-grey">2019-05-27</div>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Language/">Language</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Language/Kotlin/">Kotlin</a>
                </div>
                
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/05/27/coroutine-and-thread/">Coroutine, Thread 와의 차이와 그 특징</a>
            
        </h1>
        <div class="content">
            <p>처음 Kotlin 를 사용하던 중에 <strong>비동기</strong> 처리를 위해 Coroutine 개념을 마주했었습니다. <strong>동기</strong>란 요청을 보낸 후 요청에 대한 <strong>반환값을 얻기 이전까지 대기</strong>하는걸 의미하고, <strong>비동기</strong>는 그 <strong>대기시간동안 다른 일을 수행</strong>하여 효율성을 높히는걸 의미합니다.</p>
<p>동기와 비동기는 ‘대기’가 필요한 작업들이 빈번한 프로그래밍에 등장하는 개념이고 이를 ‘blocking’으로 명명하여 예로는 OS 시간에 배웠던 I/O 나 Network Request/Response 처리가 있습니다. 과거에는 앞서 말한 예를 처리할때에만 비동기를 사용했던것으로 기억하는데요. 현재에는 어떤 작업이든지 잘게 쪼개어 비동기로 하는 것으로 보입니다. 이런 분위기를 이끌어 온것은 사용이 간편해짐을 들 수 있는데 여기서 설명할 Coroutine 개념도 Thread 보다 비동기 사용이 쉽도록 만들어주었기 때문아닐까 생각이 듭니다.</p>
<h1 id="Process-amp-Thread"><a href="#Process-amp-Thread" class="headerlink" title="Process &amp; Thread"></a>Process &amp; Thread</h1><blockquote>
<p><strong>Process</strong>: Program 이 메모리에 적재되어 실행되는 인스턴스<br><strong>Thread</strong>: Process 내 실행되는 여러 흐름의 단위</p>
</blockquote>
<p>먼저 Thread 는 Process 보다 작은 단위의 실행 인스턴스로만 알고 있는데, 메모리 영역도 조금 다릅니다.</p>
<center><img src="/2019/05/27/coroutine-and-thread/process-and-thread.png"></center>

<p><strong>Process</strong> 는 독립된 메모리 영역<strong>(Heap)</strong>을 할당받고 각 <strong>Thread</strong>도 독립된 메모리 영역<strong>(Stack)</strong>을 할당받습니다. Thread 는 본질적으로 Process 내에 속해있기 때문에 Head 메모리 영역은 해당 Process 에 속한 모든 Thread 들이 공유할 수 있습니다. </p>
<p>Program 에 대한 Process 가 생성되면 Heap 영역과 하나의 Thread 와 하나의 Stack 영역을 갖게되고, <strong>Thread 가 추가될때마다 그 수만큼의 Stack 이 추가됩니다.</strong> Thread 가 100 개라면 전체 메모리에 100 개의 Stask 이 생성되는 것입니다.</p>
<h1 id="Concurrency-amp-Parallelism"><a href="#Concurrency-amp-Parallelism" class="headerlink" title="Concurrency &amp; Parallelism"></a>Concurrency &amp; Parallelism</h1><h2 id="Concurrency-동시성"><a href="#Concurrency-동시성" class="headerlink" title="Concurrency 동시성"></a>Concurrency 동시성</h2><blockquote>
<p><strong>Interleaving, 시분할</strong>: 다수의 Task 가 있는데, 각 Task 들을 평등하게 조금씩 나누어 실행하는것</p>
</blockquote>
<center><img src="/2019/05/27/coroutine-and-thread/tasks.png"><img src="/2019/05/27/coroutine-and-thread/concurrency.png"></center>

<p>총 실행시간은 Context Switching 에 대한 비용을 제외하곤 각 Task 수행시간을 합친것과 동일합니다.<br>예를 들어 3 개의 Task 각각이 10분씩 걸린다고 했을때, <strong>총 30분</strong>이 소요되는것입니다.</p>
<h2 id="Parallelism-병렬성"><a href="#Parallelism-병렬성" class="headerlink" title="Parallelism 병렬성"></a>Parallelism 병렬성</h2><blockquote>
<p><strong>Parallelizing, 병렬수행</strong>: 다수의 Task 가 있는데, 각 Task 들이 한번에 수행되는 것</p>
</blockquote>
<center><img src="/2019/05/27/coroutine-and-thread/tasks.png"><img src="/2019/05/27/coroutine-and-thread/parallelism.png"></center>

<p>Task 수 만큼 자원이 필요하며, Context Switching 은 필요없습니다.<br>총 실행시간은 다수의 Tasks 중 가장 소요시간이 긴 Task 만큼 걸립니다.<br>예를 들어 3 개의 Task 각각이 10, 11, 12분씩 걸린다면, <strong>총 12분</strong>이 소요되는것입니다.</p>
<h1 id="Thread-amp-Coroutine"><a href="#Thread-amp-Coroutine" class="headerlink" title="Thread &amp; Coroutine"></a>Thread &amp; Coroutine</h1><p>Thread, Coroutine 모두 Concurrency 동시성 (Interleaving) 를 보장하기 위한 기술입니다. 여러개의 작업을 동시에 수행할 때 Thread 는 각 작업에 해당하는 메모리 영역을 할당하는데, 여러 작업을 동시에 수행해야하기 때문에 OS 레벨에서 각 작업들을 얼만큼씩 분배하여 수행해야지 효율적일지 Preempting Scheduling 을 필요로 합니다. A 작업 조금 B 작업 조금을 통해 최종적으로 A 작업과 B 작업 모두를 이뤄내는 것입니다. Coroutine 은 Lightweight Thread 라고 불립니다. 이 또한 작업을 효율적으로 분배하여 조금씩 수행하여 완수하는 Concurrency 를 목표로하지만 각 작업에 대해 Thread 를 할당하는 것이 아니라 작은 Object 만을 할당해주고 이 Object 들을 자유자재로 스위칭함으로써 Switching 비용을 최대한 줄였습니다.</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><ul>
<li>Task 단위 = <strong>Thread</strong><ul>
<li>다수의 작업 각각에 <strong>Thread</strong> 를 할당합니다.<br>각 Thread 는 위에 설명했듯 자체 Stack 메모리 영역을 가지며 <strong>JVM Stack 영역을 차지</strong>합니다.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Context Switching</strong><ul>
<li><strong>OS Kernel</strong> 에 의한 <strong>Context Switching</strong> 을 통해 Concurrency 를 보장합니다.</li>
<li><strong>Blocking</strong>: 작업 1(Thread) 이 작업 2(Thread) 의 결과가 나오기까지 기다려야한다면<br>작업 1 Thread 는 Blocking 되어 그 시간동안 해당 자원을 사용하지 못합니다.</li>
</ul>
</li>
</ul>
<center><img src="/2019/05/27/coroutine-and-thread/context-switch-between-threads.png">* 쉬운 설명을 위해 CPU 는 Single Core 로 가정합니다.</center>

<p>위 그림에서 작업들은 모두 Thread 단위인것을 알 수 있습니다. Thread A 에서 작업 1을 수행중에 작업 2가 필요할때 이를 비동기로 호출하게 됩니다. 작업 1은 진행중이던 작업을 멈추고(Blocked) 작업 2는 Thread B 에서 수행되며 이때 CPU 가 연산을 위해 바라보는 메모리 영역을 Thread A 에서 Thread B 로 전환하는 Context Switching 이 일어납니다. 작업 2가 완료되었을때 해당 결과값을 작업 1에 반환하게 되고, 동시에 수행할 작업 3과 작업 4는 각각 Thread C 와 Thread D 에 할당됩니다. 싱글 코어 CPU 는 동시 연산이 불가능하므로 이때에도 OS Kernel 의 Preempting Scheduling 에 의해 각 작업 1, 3, 4 각각을 얼만큼 수행하고 멈추고 다음 작업을 수행할지 결정하여 그에 맞게 세 작업을 돌아가며 실행함으로써 Concurrency 를 보장합니다.</p>
<h2 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h2><ul>
<li>Task 단위 = <strong>Object (Coroutine)</strong><ul>
<li>다수의 작업 각각에 <strong>Object</strong> 를 할당합니다.<br>이 Coroutine Object 는 객체를 담는 <strong>JVM Heap 에 적재</strong>됩니다.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Programmer Switching</strong> = No Context Switching<ul>
<li><strong>프로그래머의 코딩</strong>을 통해 <strong>Switching 시점을 마음대로 정함으로</strong>써 Concurrency 를 보장합니다.</li>
<li><strong>Suspend (Non-Blocking)</strong>: 작업 1(Object) 이 작업 2(Object) 의 결과가 나오기까지 기다려야한다면<br>작업 1 Object 는 Suspend 되지만 작업 1 을 수행하던 Thread 는 그대로 유효하기 때문에 작업 2 도 작업 1 과 동일한 Thread 에서 실행될 수 있습니다.</li>
</ul>
</li>
</ul>
<center><img src="/2019/05/27/coroutine-and-thread/no-context-switch-between-coroutines.png">* 쉬운 설명을 위해 CPU 는 Single Core 로 가정합니다.</center>

<p>작업의 단위는 Coroutine Object 이므로 작업 1 수행중에 비동기 작업 2가 발생하더라도 작업 1을 수행하던 같은 Thread 에서 작업 2를 수행할 수 있으며, 하나의 Thread 에서 다수의 Coroutine Object 들을 수행할 수도 있습니다. 위 그림에 따라 <strong>작업 1과 작업 2의 전환에 있어 단일 Thread A 위에서 Coroutine Object 객체들만 교체함으로써 이뤄지기 때문에 OS 레벨의 Context Switching 은 필요없습니다.</strong> 한 Thread 에 다수의 Coroutine 을 수행할 수 있음과 Context Switching 이 필요없기 떄문에 Coroutine 을 <strong>Lightweight Thread</strong> 로도 부릅니다.</p>
<p>다만 위 그림의 Thread A 와 Thread C 의 예처럼 다수의 스레드가 동시에 수행된다면 Concurrency 보장을 위해 두 Threads 간 Context Switching 은 수행되어야합니다. 따라서 Coroutine 을 사용할때에는 No Context Switching 이라는 장점을 최대한 활용하기 위해 다수의 Thread 를 사용하는 것보다 <strong>단일 Thread 에서 여러 Coroutine Object 들을 실행하는 것이 좋습니다.</strong></p>
<blockquote>
<p>결국 <strong>Coroutine</strong> 으로 <strong>‘작업’의 단위를 Thread 가 아닌 Object 로 축소</strong>하면서<br><strong>작업의 전환 및 다수 작업 수행에 굳이 다수의 Thread 를 필요로 하지 않게됩니다.</strong></p>
</blockquote>
<blockquote>
<p><strong>Coroutine 은 Thread 의 대안이 아니라 기존의 Thread 를 더 잘게 쪼개어 사용하기위한 개념이다.</strong><br>하나의 Thread 가 다수의 코루틴을 수행할 수 있기 때문에 더 이상 작업의 수만큼 Thread 를 양산하며 메모리를 소비할 필요가 없다.</p>
<ul>
<li>각 스레드마다 갖는 Stack 메모리 영역을 갖지 않기때문에, 스레드 사용시 스레드 개수만큼 Stack 메모리에 따른 메모리 사용공간이 증가하지 않아도 된다.</li>
<li>같은 프로세스내에 ‘공유 데이터 구조’(Heap)에 대한 locking 걱정도 없다.</li>
</ul>
</blockquote>
<center><img src="/2019/05/27/coroutine-and-thread/concurrency-progress-bar-thread-and-coroutine.png"></center>

<p>Thread 와 Coroutine 의 예로 보여드린 그림들을 위와 같이 축약해보았습니다. Coroutine 을 사용한다면 Task 가 바뀌어도 Thread 는 그대로 유지되는 것을 볼 수 있습니다. 그에 따라 자연스레 Context Switching 횟수도 확연히 줄어들은것을 볼 수 있습니다. Coroutine 에서 설명드린바와 같이 Task 3 과 Task 4 도 Thread C 가 아닌 Thread A 에서 수행되도록 한다면 하나의 Context Switching 도 없게 설계할 수 있습니다. 즉, Coroutine 이 수행될 Thread 도 프로그래머가 Shared Thread Pool 을 지정하여 결정한다는 의미이며, Coroutine 을 활용한 효율성은 오로지 프로그래머의 몫이라는 의미입니다.</p>
<h3 id="각-언어의-Coroutine"><a href="#각-언어의-Coroutine" class="headerlink" title="각 언어의 Coroutine"></a>각 언어의 Coroutine</h3><ul>
<li><strong>Future</strong> - <strong>Java</strong> 비동기 지원</li>
<li><strong>Promise, Generators</strong> - <strong>JavaScript</strong> 비동기 지원<ul>
<li>제너레이터는 yield 구문에 의해서만 실행을 멈춥니다. 즉 잘게잘게 쪼개어 (Iterator) 얼려놓았다 (Freeze/Yield)</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Deferred</strong> - <strong>Kotlin</strong> 비동기 지원<ul>
<li>Non Blocking Cancellable ‘Future’(Java) = <strong>Coroutine Object</strong></li>
<li>Coroutine Builder 인 <strong>async { } 를 통해 정의</strong>된다.</li>
<li>Coroutine 에서 설명했듯이 <strong>Deferred</strong> 객체를 수행할땐 <strong>Thread 를 Blocking 하지 않고</strong><br>해당 구문이 끝날때까지 awaits 하였다 끝나면 계속 이어간다.</li>
</ul>
</li>
</ul>
<h3 id="Stackful-amp-Stackless"><a href="#Stackful-amp-Stackless" class="headerlink" title="Stackful &amp; Stackless"></a>Stackful &amp; Stackless</h3><p>Coroutine 을 조금 더 깊게 알아보았다면 <strong>Stackful</strong> 과 <strong>Stackless</strong> 이 두 종류로 나뉘는것을 볼 수 있다. 본 글의 맨 처음에서 언급했듯이 <strong>Thread 는 자체 메모리 영역인 Stack 을 갖는다.</strong> Stack 은 함수 실행 순서를 적재하고 그를 관리할 수 있게 해준다. <strong>Lightweight Thread 인 Coroutine 의 Stackful &amp; Stackless 는 Coroutine 이 자체 Stack 을 가지는가? 갖지 않는가?</strong>를 의미한다. <strong>Stackful Coroutine 은 Coroutine 내부에서 다른 함수를 호출하였을때 해당 함수에서 현재 Coroutine 을 suspend 할 수 있음 (정확히는 yield 호출을 할 수 있음) 을 의미한다.</strong> <strong>Stackless Coroutine 은 함수에 대한 Stack 을 따로 갖지 않기 때문에 호출하려는 함수를 다시 한번 Coroutine 객체로 묶어서 ‘Coroutine 중첩 호출’을 해야지 이전 Coroutine 과 내부 Coroutine 을 suspend 를 통해 연결할 수 있다.</strong></p>
<ul>
<li>Coroutine - Stackful Functions<ul>
<li>Coroutine 내부 함수에서 Yield(Suspending the Coroutine) 호출 가능</li>
</ul>
</li>
</ul>
<ul>
<li>Generators - Stackless Functions<ul>
<li>Coroutine 내부 함수에서 Yield(Suspending the Coroutine) 호출 불가능</li>
<li>예를 들면 Coroutine 내부에 있는 Arrays.forEach() 함수 안 구문에선 forEach() 함수를 코루틴 적용이 가능하게 따로 정의하지 않는한 <strong>Yield 호출이 불가능하다.</strong></li>
</ul>
</li>
</ul>
<h1 id="Kotlin-Coroutine"><a href="#Kotlin-Coroutine" class="headerlink" title="Kotlin Coroutine"></a>Kotlin Coroutine</h1><h2 id="buildSequence"><a href="#buildSequence" class="headerlink" title="buildSequence { }"></a>buildSequence { }</h2><ul>
<li>순차적 Yield/Resuming<ul>
<li>Yield 를 통해 멈춥니다.</li>
<li>Resume 을 통해 순차수행합니다.</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">g</span><span class="hljs-params">()</span></span> = buildSequence &#123;</span><br><span class="line">  yield(<span class="hljs-number">1</span>); yield(<span class="hljs-number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-keyword">for</span> (v <span class="hljs-keyword">in</span> g()) &#123;</span><br><span class="line">  println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking { }"></a>runBlocking { }</h2><ul>
<li><strong>Main Thread</strong> 를 <strong>Blocking</strong> 한 채 <strong>{ } 구문 내 작업을 새 Thread</strong> 에 할당하여 수행합니다.</li>
<li>runBlocking { } 내부에 다수의 async { } 들을 정의하였다면 해당 모든 async 들이 다 수행 완료, 반환되었을때 Main Thread 에 대한 Blocking 을 풉니다.</li>
</ul>
<h2 id="launch"><a href="#launch" class="headerlink" title="launch { }"></a>launch { }</h2><ul>
<li><strong>Main Thread</strong> 를 <strong>Unblocking</strong> 한 채 { } 구문 내 작업을 수행합니다.</li>
</ul>
<h2 id="async"><a href="#async" class="headerlink" title="async { }"></a>async { }</h2><ul>
<li><strong>Main Thread</strong> 를 <strong>Unblocking</strong> 한 채 { } 구문 내 작업을 하고 <strong>반환값이 존재</strong>합니다.<ul>
<li>async { } 는 launch { } 와 같은 동작을 하지만 반환값이 존재하는 <strong>Deferred</strong> 입니다.<br>즉, launch 는 끝까지 실행하면 끝나는거고 async 는 끝까지 실행하고 반환값을 가진 객체를 반환한다.</li>
<li>Deferred<t>, which has an await() function that returns the result of the coroutine.</t></li>
</ul>
</li>
</ul>
<hr>
<p>출처: </p>
<ol>
<li><a href="https://stackoverflow.com/questions/1934715/difference-between-a-coroutine-and-a-thread" target="_blank" rel="noopener">https://stackoverflow.com/questions/1934715/difference-between-a-coroutine-and-a-thread</a></li>
<li><a href="https://stackoverflow.com/questions/43021816/difference-between-thread-and-coroutine-in-kotlin/43232925" target="_blank" rel="noopener">https://stackoverflow.com/questions/43021816/difference-between-thread-and-coroutine-in-kotlin/43232925</a></li>
<li><a href="https://kotlinlang.org/docs/tutorials/coroutines/coroutines-basic-jvm.html" target="_blank" rel="noopener">https://kotlinlang.org/docs/tutorials/coroutines/coroutines-basic-jvm.html</a></li>
<li><a href="https://medium.com/@jooyunghan/stackful-stackless-%EC%BD%94%EB%A3%A8%ED%8B%B4-4da83b8dd03e" target="_blank" rel="noopener">https://medium.com/@jooyunghan/stackful-stackless-%EC%BD%94%EB%A3%A8%ED%8B%B4-4da83b8dd03e</a></li>
</ol>

        </div>
        
        
        
    </div>
</div>










    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <!-- <time class="level-item has-text-grey" datetime="2019-03-24T12:42:23.000Z">2019-03-24</time> -->
                <div class="level-item has-text-grey">2019-03-24</div>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Language/">Language</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Language/Functional-Programming/">Functional Programming</a>
                </div>
                
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/03/24/only-one-page-for-functional-programming/">한 장으로 보는 함수형 프로그래밍 - 클로저, 커링, Functor, 모나드</a>
            
        </h1>
        <div class="content">
            <h1 id="‘함수’형-프로그래밍"><a href="#‘함수’형-프로그래밍" class="headerlink" title="‘함수’형 프로그래밍"></a>‘함수’형 프로그래밍</h1><p>‘함수’형 프로그래밍은 한 마디로 요약할 수 있습니다.</p>
<blockquote>
<p>‘함수’를 <strong>1. 변수</strong>에 <strong>2. 파라미터</strong>에 <strong>3. 반환값</strong>에 사용할 수 있으며, <strong>4. 순수 함수</strong> 특성을 갖습니다.</p>
</blockquote>
<ol start="0">
<li>‘함수’는 <strong>일급함수(first-class function)</strong> 입니다.<ol>
<li>‘함수’를 <strong>변수</strong>에 대입할 수 있습니다.</li>
<li>‘함수’를 <strong>파라미터</strong>로 넘길 수 있습니다.</li>
<li>‘함수’를 <strong>반환</strong>할 수 있습니다</li>
</ol>
</li>
</ol>
<ol start="4">
<li>‘함수’는 <strong>순수 함수</strong> 특성을 갖습니다.<ul>
<li><strong>참조 투명성 (No Side-Effects)</strong>: 외부 상태나 변수, 환경의 영향을 받지 않고,<br>같은 파라미터로 함수를 호출하면 매 항상 같은 결과를 반환합니다.</li>
</ul>
</li>
</ol>
<h2 id="함수-포인터"><a href="#함수-포인터" class="headerlink" title="함수 포인터"></a>함수 포인터</h2><p>함수는 값이 아닌 참조인 만큼 <strong>함수를 일급함수로 사용하기 위해서는 함수 포인터</strong>를 이용해야 합니다.</p>
<ol>
<li>함수 포인터를 통해 함수를 <strong>변수</strong>로 사용할 수 있습니다.</li>
<li>함수를 <strong>파라미터</strong>로 넘기고 싶다면 함수 포인터를 전달하면 가능합니다.</li>
<li>함수를 <strong>반환</strong>하고 싶으면 반환하려는 함수에 대한 포인터를 반환하면 가능합니다.</li>
</ol>
<figure class="highlight c hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qsort</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>* base, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">size_t</span> size,  <span class="hljs-keyword">int</span> (*compare)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*))</span></span>;</span><br></pre></td></tr></table></figure>
<p>위 C 언어 예를 보면 퀵소트 알고리즘의 마지막 <strong>파라미터</strong>로 <strong>compare 함수 포인터</strong>를 넘겨주는걸 볼 수 있습니다. 다만 C 언어에서의 함수는 <strong>런타임에 정의된 함수</strong>가 아니라 <strong>미리 컴파일된 함수</strong>는 이유로 일급함수(first-class function)가 아닌 이급함수(second-class function)로 부르자는 의견<a href="https://en.wikipedia.org/wiki/First-class_citizen#Functions" target="_blank" rel="noopener">^3</a>도 있는듯 합니다.</p>
<hr>
<h1 id="람다-익명함수"><a href="#람다-익명함수" class="headerlink" title="람다 (익명함수)"></a>람다 (익명함수)</h1><p><strong>람다</strong>는 컴퓨터과학 및 수리논리학에 사용되는 개념으로 현 프로그래밍 함수의 원형에 해당하는 개념입니다.</p>
<blockquote>
<p><strong>입력값</strong>을 받고 함수 외부에 정의된 <strong>자유변수</strong>를 활용하여 결과를 반환하는 함수 <strong>추상</strong>표현법 입니다.</p>
</blockquote>
<p>함수를 정의만 할 뿐 수행하지 않는다는 점이 프로그래밍 내에서 함수를 정의를 먼저하는 것<a href="https://ko.wikipedia.org/wiki/%EB%9E%8C%EB%8B%A4_%EB%8C%80%EC%88%98#%ED%95%B5%EC%8B%AC_%EA%B0%9C%EB%85%90" target="_blank" rel="noopener">^8</a>과 같습니다. 수리논리 개념이자 함수의 원형인만큼 <strong>람다는 함수명이 존재하지 않습니다.</strong> 이런 이유로 <strong>람다</strong>를 프로그래밍에서는 <strong>익명함수</strong>로 부르기도 합니다. 개념이라는 것은 알겠는데 그럼 람다는 언제 왜 사용되는것일까요?</p>
<p>프로그래밍에서는 <strong>값</strong>을 사용하는 두 가지 방법이 있습니다.</p>
<ul>
<li><p><strong>재사용성</strong>을 위해 값을 정의 후 변수에 할당하여 <strong>변수로 사용</strong>하는 방법</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> defined: <span class="hljs-type">Int</span> = <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-built_in">print</span>(defined)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>일회성</strong> 사용을 위해 값을 바로 <strong>inline 으로 사용</strong>하는 방법</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span>)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>함수</strong>를 사용하는 방법도 값과 같이 두 가지 방법이 있습니다.</p>
<ul>
<li><p><strong>재사용성</strong>을 위해 함수를 정의 후 <strong>참조로 사용</strong>하는 방법</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defined</span><span class="hljs-params">()</span></span> -&gt; (<span class="hljs-type">Int</span>) &#123;</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="hljs-built_in">print</span>(defined)</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>일회성</strong> 사용을 위해 함수를 바로 <strong>inline 으로 사용</strong>하는 방법</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">print</span>(&#123; <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>람다</strong>는 변수, 파라미터, 반환값에 함수 포인터를 넘겨준다는 것은 일반 함수 사용과 동일하지만, <strong>함수 정의 시점</strong>이 다르기 때문에 </p>
<ul>
<li>함수 이름이 필요없으며</li>
<li>함수의 유효범위가 일회성이라는 장점이 있습니다. <ul>
<li><strong>일반 함수</strong>는 정의 시 정의 구역 내 <strong>전역으로 존재</strong>합니다.<br>(어려운 말로 <strong>전역 네임스페이스에 소속되는 정적인 구현체</strong><a href="http://seorenn.blogspot.com/2014/06/swift-closures.html" target="_blank" rel="noopener">^1</a>)</li>
<li><strong>람다</strong>는 정의 시 정의 블럭 내 <strong>일회성으로 존재</strong>합니다. </li>
</ul>
</li>
</ul>
<p><strong>람다</strong>를 통해 함수를 <strong>일급함수</strong>로 사용 시 미리 정의할 필요없이 <strong>inline 으로 함수를 정의하여 바로 사용</strong>이 가능해졌습니다.</p>
<h2 id="함수객체"><a href="#함수객체" class="headerlink" title="함수객체"></a>함수객체</h2><p>객체지향 프로그래밍에서는 함수가 단일 함수로는 존재할 수 없으며 꼭 클래스안에 속해야하는 한계가 있습니다. 함수를 람다로 사용하고싶다면 <strong>함수객체</strong>를 만들어 객체레벨로 사용해야합니다. 객체지향 프로그래밍에서 <strong>람다</strong>는 겉으로 보기에는 단일 함수로 존재하는것 같지만, 실제론 이름없는 객체가 단일 함수를 감싸고 있는 <strong>‘함수객체’의  Syntactic Sugar</strong> 라고 보시면됩니다.</p>
<hr>
<h1 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h1><p><strong>람다</strong>와 <strong>클로저</strong> 이 둘은 같아보이지만 엄연히 다른 개념<a href="https://stackoverflow.com/a/220728/3231395" target="_blank" rel="noopener">^4</a>입니다. 각 정의를 살펴보면</p>
<blockquote>
<p><strong>람다</strong>는 <strong>익명함수</strong>를 뜻합니다.<br>함수를 변수, 파라미터, 반환값에 <strong>일회성</strong>으로 바로 사용하고싶을때 쓰입니다.</p>
</blockquote>
<blockquote>
<p><strong>클로저</strong>는 <strong>함수가 정의될 때의 환경(상태)</strong>을 갖는 <strong>함수</strong>를 뜻합니다.<a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)#cite_note-2" target="_blank" rel="noopener">^5</a><br>여기서 <strong>환경</strong>은 <strong>클로저가 정의되는 범위(Scope)에 있는 지역변수</strong>을 의미합니다.</p>
</blockquote>
<p>일반적으로 클로저는 함수 A 내부에서 함수(클로저) C 를 정의하는 방식으로 많이 사용합니다. 함수 A 내에 <strong>클로저</strong> C 가 정의된다면 C 는 <strong>A 의 변수</strong>들을 파라미터로 넘기지 않았음에도 자연적으로 <strong>참조</strong>하여 사용할 수 있습니다. 이것이 <strong>환경(상태)</strong>입니다.</p>
<ul>
<li><strong>함수 A 의 변수</strong> 와 <strong>클로저 C</strong> 의 관계를 <strong>클래스 A 내 필드</strong>와 <strong>메서드 C</strong>의 관계로 생각하시면 이해가 쉽습니다. </li>
</ul>
<p><strong>클로저를 함수를 객체처럼 사용하기 위한 방법</strong>으로 본다면, 클로저를 사용하는 이유는 객체를 사용하는 이유와 비슷합니다.</p>
<ul>
<li>클로저 C 가 참조하는 외부 변수를 상태처럼 계속 갖기 때문에 반복 호출하더라도 해당 상태를 계속 활용할 수 있습니다.</li>
<li>외부 변수는 함수 A 범위 내에만 정의되었기 때문에 외부 접근이 불가능합니다.</li>
</ul>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">query</span><span class="hljs-params">(dbName: String)</span></span> -&gt; (<span class="hljs-type">String</span>) -&gt; (<span class="hljs-type">Person</span>) &#123;</span><br><span class="line">  <span class="hljs-keyword">let</span> instance: <span class="hljs-type">DBInstance</span> = <span class="hljs-type">DBConfig</span>.getInstance(dbName)</span><br><span class="line">  <span class="hljs-comment">// * 클로저 내부 &#123; &#125; 에서 클로저가 정의된 함수 내 존재하는 instance 변수를 사용하였습니다.</span></span><br><span class="line">  <span class="hljs-keyword">return</span> &#123; (tableName: <span class="hljs-type">String</span>) -&gt; (<span class="hljs-type">Person</span>) <span class="hljs-keyword">in</span> </span><br><span class="line">    <span class="hljs-keyword">return</span> instance.getTable(tableName).getFirst()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Swift-클로저"><a href="#Swift-클로저" class="headerlink" title="Swift 클로저"></a>Swift 클로저</h2><p>위에서 살펴보았듯 클로저의 정의가 익명함수는 아니지만, <strong>Swift 에서는 클로저가 이름 없이 사용되기 때문에 익명함수이기도 합니다.</strong> Swift 의 클로저는 ‘파라미터’와 ‘반환에 해당하는 구문’을 in 으로 구별합니다.</p>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/closure.svg"></center>

<p>Swift 의 클로저는 아래와 같이 원하는 만큼 축약할 수 있습니다. </p>
<ol>
<li><p><strong>기본형</strong>: 파라미터 타입, 반환 타입을 명시하고 in 이후 함수 구문을 작성합니다.</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; (parameters) -&gt; (return_type) <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> <span class="hljs-comment">/* statements using parameters */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>축약형</strong>: 반환 타입을 암시적으로 결정합니다</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; parameters <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> <span class="hljs-comment">/* statesments using parameters */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>축약성애자</strong>: 반환 타입뿐만 아니라 반환 식의 return 도 없앴습니다.</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; parameters <span class="hljs-keyword">in</span> <span class="hljs-comment">/* statesments using parameters */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>변태</strong>: 파라미터 타입을 암시적으로 결정합니다. 사용은 파라미터 순으로 <strong>$0</strong>, <strong>$1</strong> 로 사용합니다.</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="hljs-comment">/* statesments using parameters with $0, $1 ... */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>Trailing Closure</strong>: 클로저가 마지막 파라미터로 사용된다면 파라미터에 넣지않고 함수 뒤 클로저 { } 로 바로 명시합니다.</p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> sorted = <span class="hljs-built_in">sort</span>(names, &#123; $<span class="hljs-number">0</span> &lt; $<span class="hljs-number">1</span> &#125;)</span><br><span class="line"><span class="hljs-keyword">var</span> sorted = <span class="hljs-built_in">sort</span>(names) &#123; $<span class="hljs-number">0</span> &lt; $<span class="hljs-number">1</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<hr>
<h1 id="고차함수"><a href="#고차함수" class="headerlink" title="고차함수"></a>고차함수</h1><p><strong>‘고차함수’</strong>는 일급함수 세 조건 중 두번째 혹은 세번째에 해당하는 함수를 뜻합니다.</p>
<ol>
<li><del>‘함수’를 <strong>변수</strong>에 대입할 수 있습니다.</del></li>
<li>‘함수’를 <strong>파라미터</strong>로 받거나</li>
<li>‘함수’를 <strong>반환</strong>하는 함수</li>
</ol>
<blockquote>
<p><strong>‘고차함수’</strong>는 <strong>‘함수’를 파라미터로 혹은 반환값으로 사용하는 것</strong>을 의미합니다. </p>
<ul>
<li>함수를 사용하는 함수다보니 <strong>메타적 ‘함수’</strong>라는 의미에서 한 차원 높은 함수, 고차함수라고 명명합니다.</li>
</ul>
</blockquote>
<hr>
<h1 id="커링"><a href="#커링" class="headerlink" title="커링"></a>커링</h1><p><strong>‘커링’</strong>은 일급함수 세 조건 중 세번째에 해당하는 함수를 뜻합니다.</p>
<ol>
<li><del>‘함수’를 <strong>변수</strong>에 대입할 수 있습니다.</del></li>
<li><del>‘함수’를 <strong>파라미터</strong>로 넘길 수 있습니다.</del></li>
<li>‘함수’를 <strong>반환</strong>하는 함수</li>
</ol>
<blockquote>
<p><strong>커링(Curring)</strong>은 <strong>‘함수’가 ‘함수’를 반환하는 것</strong>을 의미합니다. </p>
<ul>
<li>일반적으로 <strong>Swift</strong> 에서 <strong>커링</strong>은 <strong>함수가 ‘클로저’를 반환</strong>하는 방식으로 많이 사용됩니다.</li>
</ul>
</blockquote>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">curringExample</span>: <span class="hljs-params">(a: Int, b: Int, <span class="hljs-built_in">c</span>: Int)</span></span> -&gt; (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) -&gt; (<span class="hljs-type">Bool</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>위 <code>curringExample</code> 예를 보면 a, b, c 파라미터를 받아 <code>(Int, Int) 두 파라미터를 받아 -&gt; (Bool) 을 반환하는 함수</code>를 <strong>반환</strong>합니다</p>
<p>Swift 에서 <strong>‘클래스의 객체’</strong>가 <strong>‘클래스 객체의 함수’</strong>를 호출하는 방법도 <strong>커링</strong>을 사용합니다.<a href="https://academy.realm.io/kr/posts/currying-on-the-swift-functions/" target="_blank" rel="noopener">^2</a></p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> someInstance = <span class="hljs-type">SomeClass</span>()</span><br><span class="line">someInstance.someFunction(params: <span class="hljs-comment">/* parameters */</span>)</span><br></pre></td></tr></table></figure>
<p>위 <strong>클래스 객체의 함수</strong>는 실제로 아래와 같이 <strong>클래스 함수에 객체를 넘겨 수행합니다.</strong></p>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">SomeClass</span>.someFunction(<span class="hljs-keyword">self</span>: someInstance)(params: <span class="hljs-comment">/* parameters */</span>)</span><br></pre></td></tr></table></figure>
<p>사담으로 Kotlin 의 확장함수도 수신객체타입(클래스)에 대한 함수에 수신객체를 파라미터로 넘기는 형태로 사용됩니다.</p>
<hr>
<h1 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h1><p>Functor 는 <strong>데이터 구조</strong>입니다. Functor 개념에 앞서 함수에 대해서 짧게 살펴보겠습니다.</p>
<h2 id="함수-Mapping"><a href="#함수-Mapping" class="headerlink" title="함수 = Mapping"></a>함수 = Mapping</h2><p>함수는 Input A 를 넣으면 Output B 라는 결과가 나오는 것입니다.<br>달리보자면 함수는 Input A -&gt; Output B, 이 둘에 대한 <strong>매핑</strong>입니다.</p>
<h2 id="데이터-구조-Mapping"><a href="#데이터-구조-Mapping" class="headerlink" title="데이터 구조 Mapping"></a>데이터 구조 Mapping</h2><p>어떤 데이터 구조 전체에 대해 매핑을 적용한다면, 데이터 구조 내 원소 각각에 대해 매핑을 적용해야합니다.<br>예를 들어 데이터 구조가 <strong>리스트</strong>라면 0, 1 .. 이터레이팅을 통해 </p>
<ul>
<li><strong>Pull</strong>: 각 원소를 꺼내어 </li>
<li><strong>Mapping</strong>: 매핑을 적용한 후 </li>
<li><strong>Push</strong>: 결과 원소를 반환하려는 데이터 구조에 넣습니다.</li>
</ul>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/functor-example.svg"></center>

<p><strong>각 원소에 대한 매핑 함수를 적용할 수 있음</strong>을 Mappable 로 정의한다면, 예로 살펴본 리스트는 <strong>Mappable 데이터 구조</strong>라고 정의할 수 있습니다. 위 그림 예는 Int 데이터 구조에서 String 데이터 구조로 각 원소에 대해 stringify 한 Functor 의 예입니다.</p>
<ul>
<li><strong>Functor</strong> 정의</li>
</ul>
<blockquote>
<p><strong>Functor</strong> 는 <strong>Mappable (Mapping 함수를 갖는) 데이터 구조</strong><a href="https://medium.com/@sjsyrek/five-minutes-to-functor-83ef9075978b" target="_blank" rel="noopener">^9</a>입니다.<br>각 원소에 대한 매핑 함수를 적용할 수 있는 데이터 구조라면 Functor 로 부를 수 있습니다.</p>
</blockquote>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/functor-definition.svg"></center>

<ol>
<li><strong>‘단위 원소’들로 구성된 데이터 구조</strong></li>
<li><strong>각 ‘단위 원소’에서 ‘단위 윈소’로의 Mapping 함수</strong></li>
</ol>
<p>어떤 <strong>1. 데이터 구조</strong>든 원하는 연산을 적용하고싶다면 데이터 구조안의 <strong>단위 원소</strong>가 어떤 타입(T)이고, <strong>2. 단위 원소(T)에 대한 Mapping</strong>만 정의하면 됩니다. 1.을 클래스의 프로퍼티, 2.를 클래스의 메서드로 본다면 <strong>Functor 를 Function Object, 함수객체로 부르기도 합니다.</strong><a href="https://en.wikipedia.org/wiki/Function_object" target="_blank" rel="noopener">^10</a></p>
<blockquote>
<p><strong>Functor</strong> 는 <strong>범주론(Category Theory)</strong>에서 <strong>카테고리에서 동일 카테고리로 사상</strong>되는 개념에서 유래했습니다. <strong>데이터 구조에서 동일 데이터 구조로 각 단위 원소들에 대해 Mapping</strong>하는것과 개념적으로 동일한 것을 알 수 있습니다. 이처럼 데이터 구조(카테고리)는 바뀌지 않은 채 값만 Mapping 되는 것을 범주론에서는 <strong>natural transformation<a href="https://en.wikipedia.org/wiki/Natural_transformation" target="_blank" rel="noopener">^6</a></strong> 라고 정의합니다.</p>
</blockquote>
<h2 id="Haskell’s-Functor"><a href="#Haskell’s-Functor" class="headerlink" title="Haskell’s Functor"></a>Haskell’s Functor</h2><p>Functor 를 찾다보면 하스켈의 Functor 개념을 먼저 접하실텐데 하스켈의 Functor 는 typeclass 로 아래와 같이 정의하며, 데이터 구조 타입을 명시해서 원하는대로 인스턴스화 하여 사용합니다. Swift-like 문법으로 표현해보면 아래로 볼 수 있습니다.</p>
<ul>
<li><strong>Functor (typeclass)</strong><ul>
<li>Operation(<strong>T</strong>) -&gt; (<strong>R</strong>) </li>
<li><strong>S</strong> (Any Data Structure)</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Functor 구현 (instantiation)</strong><ul>
<li>Operation(<strong>Int</strong>) -&gt; (<strong>String</strong>) { +1 and Stringfy }</li>
<li><strong>List</strong></li>
</ul>
</li>
</ul>
<p>하스켈에서 Functor 는 <strong>데이터 구조 타입(S)</strong>과 <strong>원소(T)에서 원소(R)로의 Mapping 추상 함수</strong>를 가진 <strong>제네릭(S, T, R) 추상 클래스</strong>로 볼 수 있습니다. 하스켈에서 fmap() 이나 map() 함수를 정의할때 Mapping 추상 함수를 정의하고 변환하고자하는 데이터 구조를 주입하면 내부 값만 바뀐 동일한 데이터 구조가 반환됩니다.</p>
<p>Java 유저라면 Stream 의 map() 함수를 떠올리시면 이해가 쉽습니다. </p>
<ul>
<li>Stream 이 Mapping 함수를 가질 수 있는, Mappable 데이터 구조에 해당하므로 Functor 라고 부를 수 있고, </li>
<li>그 Mapping 함수는 Stream.map() 에 람다(익명함수) 형태로 정의하여 파라미터로 넘겨주면 됩니다. </li>
</ul>
<p>Java 의 Stream 은 정확히는 모나드입니다. 이유는 Mapping 함수가 </p>
<ul>
<li><code>Operation(T) -&gt; (R)</code>: <strong>원소(T)에서 원소(T)</strong>로 <strong>‘매핑’</strong>하는 것이 아니라</li>
<li><code>Operation(T) -&gt; (S)</code>: <strong>원소(T)에서</strong> 아예 <strong>새 Functor(S)</strong>로 <strong>‘반환’</strong>한다는 것입니다. </li>
</ul>
<p><strong>Functor</strong> 에서는 연산 전 데이터 구조에서 단위 원소를 꺼내 <strong>‘매핑’</strong>을 적용 후 <strong>결과 원소</strong>를 데이터 구조에 넣었습니다. 반면 <strong>모나드</strong>에서는 연산 전 데이터 구조에서 단위 원소를 꺼내 <strong>‘매핑’</strong>을 적용 후 해당 원소를 <strong>데이터 구조에 넣어</strong>서 <strong>결과 데이터 구조</strong>를 <strong>‘반환’</strong>합니다. 함수 자체가 데이터 구조를 반환하기 때문에 매핑 함수 결과에 <strong>Stream.map().map().map()…</strong> 과 같이  계속해서 Chaining 으로 연결할 수 있습니다. </p>
<p><strong>왜</strong> <strong>‘원소 - 원소 매핑’</strong>이 아닌 <strong>‘원소 - 데이터 구조 매핑’</strong>을 하는지 아래 <strong>모나드</strong>에서 살펴보겠습니다.</p>
<hr>
<h1 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h1><p>모나드가 무엇인지 한 마디로 정리하기에 앞서, 왜 모나드가 필요한지에 대해 알아보겠습니다. 프로그래밍 언어의 ‘프로그래밍 함수’와 학문에서의 ‘함수’의 차이점이 무엇인지 아시는지요? </p>
<ul>
<li><strong>함수</strong><ul>
<li>함수 실행 시 내부에 어떤 상황이 발생하더라도 최종적으로 <strong>값을 반환하는걸 보장</strong>합니다. </li>
</ul>
</li>
</ul>
<ul>
<li><strong>프로그래밍 함수</strong><ul>
<li>함수 실행 시 내부에 어떤 <strong>처리할 수 없는</strong> 상황이 발생하면 <strong>값을 반환하지 못한채 중간에 Exception</strong>을 발생시킵니다.</li>
</ul>
</li>
</ul>
<p>고등, 대학 수학에서 그 어떠한 함수도 f(x) 중간에 실행하다가 입력해준 값이 잘못되어있으면 중간에 Exception을 내지(…) 않았습니다. 하지만 프로그래밍 함수는 작동 중 상태가 잘못되었을 경우 Exception 을 발생시킵니다. </p>
<blockquote>
<p><strong>Exception 을 발생시키는 것</strong>을 <strong>순수함수</strong> 관점에서는 <strong>Side-Effect</strong> 로 정의하기 때문에 <strong>Exception 이 발생하는 함수</strong>를 <strong>‘비순수 함수’</strong>로 정의합니다.<a href="https://github.com/funfunStudy/study/wiki/%EC%88%9C%EC%88%98%ED%95%A8%EC%88%98-(Pure-Function)" target="_blank" rel="noopener">^7</a> </p>
</blockquote>
<p>만약 ‘프로그래밍 함수’에서 Exception 발생시 <strong>중간에 멈추는것</strong>이 아니라 <strong>해당 ‘상태’가 발생했음을 ‘상태’값으로써 결과에 함께 반환</strong>한다면 Side-Effect 는 없어지게 됩니다. 프로그래밍 함수의 <strong>순수함수화</strong>인 셈입니다. 이렇게 <strong>‘상태’값</strong>과 함수 본연의 <strong>‘결과’값</strong>을 함께 반환하기 위해서는 이 둘을 묶는 데이터 구조가 필요할 것 같습니다. </p>
<blockquote>
<p>Functor 의 <strong>Mapping 함수를 순수함수로 만들기위해</strong> 함수의 결과에 <strong>Exception 이 발생할 수 있는 ‘상태’</strong> 및 <strong>‘결과’</strong>를 <strong>모두 포함하는 데이터 구조를 반환</strong>해보았습니다.</p>
</blockquote>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/functor-return-functor.svg"></center>

<p>Functor 의 Mapping 함수가 데이터 구조를 반환하도록 만들었지만 <strong>반환되는 데이터 구조</strong>가 <strong>한번 더 Functor 의 데이터 구조</strong>로 감싸져서 반환되는 문제가 발생했습니다.</p>
<ul>
<li><strong>Exception ‘상태’를 갖는 데이터 구조</strong>가 </li>
<li><strong>Mapping 함수를 수행한 Functor 의 데이터 구조</strong>에 <strong>한번 더 감싸진채로 반환</strong>되었습니다.</li>
</ul>
<p>Functor 는 자신의 데이터 구조의 내부 원소에서 그에 대한 연산을 수행하고 결과 원소를 데이터 구조에 Mapping 하여 반환하기 때문입니다.</p>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/monad-return-functor.svg"></center>

<p>불필요하게 두 번 감싸지 않고 Exception 상태만을 포함한 데이터 구조를 반환하기 위하여 Mapping 함수의 결과를 그대로 반환하고, Mapping 함수 수행 전에 갖고있는 데이터 구조에서 값을 추출하는 Unwrap 함수를 명시합니다. 이를 flatMap 함수라고 부르며 이 <strong>flatMap 으로 얻어진 ‘데이터 구조의 내부 원소’</strong>에 대한 <strong>Mapping 결과인 ‘데이터 구조’를 바로 반환</strong>하도록 하는것이 <strong>모나드</strong> 패턴입니다.</p>
<ul>
<li><strong>Monad</strong> 정의</li>
</ul>
<blockquote>
<p><strong>Monad</strong>는 <strong>Unwrap(flatMap) 함수</strong>를 포함하는 <strong>Mappable 데이터 구조</strong>입니다.<br><strong>Monad</strong>의 <strong>Mapping 함수</strong>는 <strong>‘결과’와 ‘상태’ 모두를 갖는 데이터 구조를 반환</strong>합니다.</p>
</blockquote>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/monad-definition.svg"></center>

<ol>
<li><strong>‘단위 원소’로 구성된 (1) 데이터 구조</strong></li>
<li><strong>‘단위 원소’에서 ‘Exception 상태를 포함한 (2) 데이터 구조’로의 Mapping 함수</strong></li>
<li><strong>(1) 데이터 구조에서 ‘단위 원소’을 꺼내는 Unwrap(flatMap) 함수</strong></li>
</ol>
<p>모나드에 대한 설명을 보면 Context 와 Content 이 둘을 가진 데이터 타입으로 설명하는 글들이 많습니다. Context 를 값이 있음/없음에 대한 ‘상태’값으로, Content 는 우리가 연산하려는 ‘값’ 내지 ‘결과’값으로 설명합니다. Monad 의 Context 가 꼭 값이 있음/없음의 상태를 가져야하는것은 아니지만 <strong>일반적으로 함수 수행 중에 Exception 이 발생할 수 있는 경우들은 값이 null 인 경우</strong>가 대부분이기 때문에 많은 설명들에서 nullable 로 설명하는것 같습니다. </p>
<h2 id="Function-Composition"><a href="#Function-Composition" class="headerlink" title="Function Composition"></a>Function Composition</h2><p>모나드는 <strong>결과 데이터 구조가 ‘상태’를 갖는다는것</strong> 뿐만 아니라 <strong>함수의 합성이 가능하다는 성질</strong>도 갖습니다.</p>
<ul>
<li><strong>composition</strong> with <strong>associative</strong>:<br>두 Mapping 함수 f(x), g(x) 가 있다면 두 함수를 합성시 f(g(x)) = (f.g)(x) 의 결과를 갖는다.<br>또한 associative 성질에 의해 f(g(x)) = (f.g)(x) = (g.f)(x) = g(f(x)) 도 만족한다.</li>
</ul>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/monad-composition.svg"></center>

<p>이렇게 함수형 프로그래밍의 클로저, 고차함수, 커링, Functor, 모나드 총 5개의 개념을 다뤄보았습니다. 질문이나 논의할 사항이 있으면 댓글이나 개인적으로 알려주시면 감사하겠습니다. 특히 이번 글은 시니어 개발자분의 도움으로 틀린 내용들을 가다듬고 다시 보완할 수 있었습니다. 다음 글에서는 Swift 의 클로저가 외부 변수를 참조하면서 생기는 참조 순환 문제와 그걸 해결하기 위한 기법들을 설명하겠습니다.</p>
<hr>
<p>참조</p>
<ol>
<li><a href="https://medium.com/@sjsyrek/five-minutes-to-functor-83ef9075978b" target="_blank" rel="noopener">https://medium.com/@sjsyrek/five-minutes-to-functor-83ef9075978b</a></li>
<li><a href="https://medium.com/@jooyunghan/functor-and-monad-examples-in-plain-java-9ea4d6630c6" target="_blank" rel="noopener">https://medium.com/@jooyunghan/functor-and-monad-examples-in-plain-java-9ea4d6630c6</a></li>
<li><a href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html" target="_blank" rel="noopener">http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html</a></li>
<li><a href="http://seorenn.blogspot.com/2014/06/swift-closures.html" target="_blank" rel="noopener">http://seorenn.blogspot.com/2014/06/swift-closures.html</a></li>
<li><a href="https://stackoverflow.com/questions/356950/what-are-c-functors-and-their-uses" target="_blank" rel="noopener">https://stackoverflow.com/questions/356950/what-are-c-functors-and-their-uses</a></li>
<li><a href="https://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor" target="_blank" rel="noopener">https://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor</a></li>
</ol>

        </div>
        
        
        
    </div>
</div>










    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <!-- <time class="level-item has-text-grey" datetime="2019-03-09T07:24:17.000Z">2019-03-09</time> -->
                <div class="level-item has-text-grey">2019-03-09</div>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Language/">Language</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Language/Swift-4-iOS/">Swift 4+ / iOS</a>
                </div>
                
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/03/09/swift-keyword-open/">Swift 4+ Keywords - &#34;open&#34;</a>
            
        </h1>
        <div class="content">
            <h1 id="접근-제어자-Access-Modifier"><a href="#접근-제어자-Access-Modifier" class="headerlink" title="접근 제어자 (Access Modifier)"></a>접근 제어자 (Access Modifier)</h1><p>프로그래밍 언어에서 Java 를 예로 들자면 public, private, protected 으로 <strong>필드, 함수, 클래스</strong>의 <strong>접근 범위</strong>를 제어할 수 있습니다. final, open, override, abstract 과 같이 상속 관련 키워드들도 ‘접근 제어자’의 범주에 함께 포함됩니다. (접근 제어자를 가시성 변경자 (Visibility Modifier)로 부르기도 합니다.)</p>
<h2 id="취약-기반-클래스-Fragile-Base-Class"><a href="#취약-기반-클래스-Fragile-Base-Class" class="headerlink" title="취약 기반 클래스 (Fragile Base Class)"></a>취약 기반 클래스 (Fragile Base Class)</h2><p><strong>취약 기반 클래스 문제<a href="http://www.cas.mcmaster.ca/~emil/Publications_files/MikhajlovSekerinski98FragileBaseClassProblem.pdf" target="_blank" rel="noopener">^1</a></strong>는 <strong>상속</strong>에 의해 발생하는 문제로 <strong>기반 클래스</strong>와 그를 상속하는 <strong>하위 클래스</strong>가 있다고 가정하였을 때 <strong>기반 클래스의 변경</strong>이 발생하면 <strong>하위 클래스가 깨지는 문제</strong>를 의미합니다. 기반 클래스를 하위 클래스에서 상속할 시 <strong>어떤 메소드를 어떻게 오버라이드할 지에 대한 규칙</strong>을 명시하지 않는다면 하위 클래스에서 의도와 다른 방식으로 메소드 오버라이드를 할 수 있습니다. 또한 기반 클래스의 메소드 목적이 변경되었을 때 하위 클래스의 오버라이드 메소드는 기존 의도와 예기치 못한 채 달라지게 되기 때문에 기반 클래스의 변경은 그를 상속하는 모든 하위 클래스에 영향을 줍니다. 이를 기반 클래스가 취약하다는 의미로 <strong>취약 기반 클래스</strong>라고 부릅니다.</p>
<p>초기 객체지향 프로그래밍 언어에 해당하는 Java, C#, C++ 의 경우에는 객체지향의 특징인 상속이 용이하도록, 접근 제어자를 따로 명시하지 않는다면 <strong>모든 기본 클래스는 상속이 가능</strong>합니다. 하지만 <strong>취약 기반 클래스 문제</strong>를 방지하기 위하여 ‘Effective Java’ 저서에서도 “상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라”로 언급되듯 <strong>모든 기본 클래스는 상속하지 말 것</strong>을 소프트웨어 아키텍쳐 및 디자인 패턴에서 권장하고 있습니다.</p>
<p>초기 객체지향 프로그래밍을 사용하면서 발견된 한계와 문제들은 언어를 꾸준히 업데이트하면서 보완되기도 하지만, 새로 나오는 언어들은 이러한 좋은 패턴들을 자신들의 특징으로 가져가기도 합니다. 현대 객체지향 프로그래밍 언어인 <strong>Kotlin</strong> 과 <strong>Swift</strong> 가 그 중 하나에 속합니다. 우스갯소리로 이런 언어들을 짬뽕이라고 얘기하기도 하지만 그만큼 패턴들을 문법으로서 강제하는 장점을 갖습니다.</p>
<h1 id="Swift-Kotlin-final-class"><a href="#Swift-Kotlin-final-class" class="headerlink" title="Swift, Kotlin - final class"></a>Swift, Kotlin - final class</h1><p>Java 는 취약 기반 클래스 문제를 갖는 초기 프로그래밍 언어로써 기본적으로 <strong>모든 기본 클래스는 상속이 가능</strong>합니다.<br>Kotlin 과 Swift 는 위 문제 해결을 위하여 기본적으로 <strong>모든 기본 클래스는 상속이 불가능(final)</strong>합니다.<br>따라서 Swift 의 두 타입인 class 와 struct 모두 기본적으로 상속이 불가능합니다. </p>
<p>추가로 Java 의 변수, 클래스, 함수 모두 기본적으로 아무 접근 제어자를 명시하지 않으면 package-<strong>private</strong> 로 선언되지만<br>Kotlin 과 Swift 의 경우 아무 접근 제어자를 명시하지 않으면 <strong>public</strong> 으로 선언되어 어디서든지 사용할 수 있으며, public 은 기본적으로 final로 상속이 불가능합니다.</p>
<ul>
<li><strong>public</strong> = <strong>Uninheritable</strong>, Callable</li>
<li><strong>open</strong> = <strong>Inheritable</strong>, Callable</li>
</ul>
<figure class="highlight swift hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">login</span><span class="hljs-params">()</span></span> &#123; &#125;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">playGame</span><span class="hljs-params">()</span></span> &#123; &#125;</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>() &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Kotlin, Swift 모두 상속을 하기 위해서는 클래스, 함수, 변수 모두에 open 키워드를 추가해야합니다. 함수와 변수에 open 키워드를 사용하여 클래스 전체 레벨이 아닌 함수, 변수 레벨에서 ‘상속 가능한 것’과 ‘상속 불가능한 것’들을 쉽게 관리할 수 있다는 장점이 있습니다.</p>
<hr>
<p>살펴본 바와 같이 Java 와 Kotlin, Swift 의 상속에 대한 처리는 완전히 반대입니다. Public 한 클래스와 함수들에게 <strong>기본적으로 상속 가능</strong>하게 하고 상속을 제한하기 위해서 private 나 protected 와 같은 접근 제한자를 사용하게 하는 <strong>Java</strong> 와 반대로 <strong>Kotlin, Swift</strong> 는 개발자들에게 <strong>기본적으로 모두 상속 불가능</strong>하게 하고 상속을 하기위해선 open 을 명시하게끔 제한함으로써 잘못 상속하는걸 방지합니다. 그래서 Swift 에서 얼핏 open 을 사용하다보면 함수, 변수 단위의 상속 여부를 결정하기 때문에 Java 에서 abstract 와 비슷하단 느낌을 받습니다.</p>
<hr>
<p>참조</p>
<ol>
<li><a href="https://www.hackingwithswift.com/example-code/language/what-does-the-open-keyword-do" target="_blank" rel="noopener">https://www.hackingwithswift.com/example-code/language/what-does-the-open-keyword-do</a></li>
</ol>

        </div>
        
        
        
    </div>
</div>










    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <!-- <time class="level-item has-text-grey" datetime="2019-03-02T12:15:18.000Z">2019-03-02</time> -->
                <div class="level-item has-text-grey">2019-03-02</div>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Design-Pattern/">Design Pattern</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Design-Pattern/Singleton/">Singleton</a>
                </div>
                
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/03/02/singleton-pattern/">6. 싱글턴 패턴</a>
            
        </h1>
        <div class="content">
            <p>디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다.</p>
<ul>
<li><a href="https://aaronryu.github.io/2018/12/30/a-introduction-to-design-patterns/">1. 디자인 패턴에 앞서</a></li>
<li><a href="https://aaronryu.github.io/2019/02/21/two-principles-of-design-patterns/">2. 디자인 패턴의 제 1, 2 원칙</a></li>
</ul>
<p>설명에 사용할 코드는 Java-like Pseudo Code 입니다.</p>
<hr>
<h1 id="‘정적-변수’-및-‘정적-메서드’"><a href="#‘정적-변수’-및-‘정적-메서드’" class="headerlink" title="‘정적 변수’ 및 ‘정적 메서드’"></a>‘정적 변수’ 및 ‘정적 메서드’</h1><p>코드를 작성하다보면 <strong>변수</strong>나 <strong>메서드</strong>를 <strong>단 하나만 생성하여 모든 곳에서 공유</strong>하여 사용할 때가 있습니다. <strong>정적 변수</strong>와 <strong>정적 메서드</strong>에 해당하는 개념입니다. Java 와 같이 객체지향 프로그램에서는 변수, 메서드 모두 클래스 내 존재해야하는 제약사항 때문에 공유하려는 <strong>전역 변수, 메서드</strong>를 클래스에 담아서 공유해야합니다. 재미있는 점은 <strong>정적 클래스</strong>라는 개념은 없기 때문에 클래스 안의 <strong>정적 변수나 메서드는 따로 객체 초기화 할 필요없이 바로 접근이 가능함</strong>과 동시에 원한다면 <strong>이 클래스를 객체로 초기화해서도 사용가능</strong>하다는 것입니다. 객체 초기화 없이 해당 클래스의 정적 변수와 정적 메서드를 사용한다니 이게 <strong>어떻게</strong> 가능한걸까요?</p>
<h2 id="Java-JVM-메모리"><a href="#Java-JVM-메모리" class="headerlink" title="Java, JVM 메모리"></a>Java, JVM 메모리</h2><p>Java 는 JVM 위에서 프로그램을 동작시키는데요. JVM 의 M, Machine 이 뜻하는대로 작은 OS 라고 보시면 됩니다. JVM 에서 돌리는 모든 프로그램의 자원을 JVM 이 관리합니다. 이런 이유로 Java 에 대한 이해는 JVM 메모리 관리에 대한 이해와 1:1의 관계에 놓여있습니다. 싱글턴 패턴을 배우기에 앞서 정적 변수, 메서드를 이해하기 위해 클래스, 변수, 메서드가 메모리에 어떤 JVM 메모리 영역에 할당이 되고 어떻게 정리가 되는지 간단하게 살펴보겠습니다. JVM 메모리 영역은 다음 세 영역으로 나뉩니다.</p>
<ul>
<li><strong>변하지 않는 값</strong>을 담는 <strong>Static 영역</strong> (이를 칭하는 용어는 아래 총 3가지가 있습니다)<ul>
<li><strong>변하지 않는 값</strong>을 담는다는 의미에서 <strong>Static 영역</strong>이라 부르기도 하고</li>
<li>객체화 되기 전 <strong>Class 그 자체</strong>를 담는다는 의미에서 <strong>Class 영역</strong>이라 부르기도 하고 (Class Loading)</li>
<li>객체화 되기 전 <strong>Class 의 함수</strong>를 담는다는 의미에서 <strong>Method 영역</strong>이라 부르기도 합니다.</li>
</ul>
</li>
<li><strong>변하는 값</strong>을 담는 <strong>Heap 영역</strong>과 <strong>Stack 영역</strong>으로 나뉩니다.<ul>
<li><strong>Stack 영역</strong>: 함수 내 ‘파라미터’나 ‘로컬변수’와 같이 그 함수 블록 내에만 생존하는 변수들을 저장</li>
<li><strong>Heap 영역</strong>: 객체들을 저장</li>
</ul>
</li>
</ul>
<p>객체 생성의 가장 근간이 되는 <strong>Class 는</strong> 바이트코드 형태로 <strong>Static 영역에 적재</strong>됩니다. 그 Class 를 객체화할때마다 그 <strong>객체와 객체의 변수, 메서드는</strong> 위 클래스 바이트코드를 참조하여 생성된 뒤에 <strong>Heap 영역에 적재</strong>됩니다. <strong>정적 변수, 메서드</strong>는 객체없이 Class 에 존재하는것이므로 <strong>Static 영역</strong>에 저장되겠군요. Static 영역에 Class 적재 및 객체 생성을 담당하는 것을 <strong>Classloader(클래스로더)</strong>라고 부르며 이 로더는 커스텀하게 바꾸지 않았다면 일반적으로 JVM 위에 하나만 존재합니다. 만약 두 개의 클래스로더가 있다면 같은 정적 변수라 할지라도 각자 다른 Static 영역에 적재됩니다. <strong>정적 변수, 메서드</strong>와 <strong>일반 객체의 변수, 메서드</strong>는 적재된 영역이 다르기 때문에 <strong>서로 참조하지 못하는 특징</strong>을 갖습니다.</p>
<h1 id="싱글턴-패턴"><a href="#싱글턴-패턴" class="headerlink" title="싱글턴 패턴"></a>싱글턴 패턴</h1><h2 id="정적-변수-메소드"><a href="#정적-변수-메소드" class="headerlink" title="정적 변수, 메소드"></a>정적 변수, 메소드</h2><p>정적 변수, 메서드는 ‘클래스로더’ 내 단 하나만 존재하는 <strong>유일무이한 “클래스”</strong>의 변수, 메서드입니다.<br>(클래스로더는 한 프로그램에 다수 개일 수 있습니다.)</p>
<ul>
<li><strong>Static 영역</strong>에 생성되는 <strong>클래스 변수, 메서드</strong>입니다.</li>
<li>프로그램의 시작과 동시에 클래스로더 에 의해 바이트코드형태로 <strong>Static 영역</strong> 메모리에 바로 적재됩니다.</li>
</ul>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// * Public: Can be initialized from outer</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Caculator</span><span class="hljs-params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="hljs-comment">// * Static: sum(a, b)</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title">sum</span><span class="hljs-params">(Integer a, Integer a)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="싱글턴-변수-메소드"><a href="#싱글턴-변수-메소드" class="headerlink" title="싱글턴 변수, 메소드"></a>싱글턴 변수, 메소드</h2><p>싱글턴 패턴의 정의는 ‘클래스로더’ 내 단 하나만 존재하는 <strong>유일무이한 “객체”</strong>의 변수, 메서드입니다.<br>(클래스로더는 한 프로그램에 다수 개일 수 있습니다.)</p>
<ul>
<li><strong>Heap 영역</strong>에 생성되는 <strong>객체 변수, 메서드</strong>입니다.</li>
<li>프로그램 실행 도중 필요한 그 시점에 객체로 <strong>Heap 영역</strong>에 적재됩니다. 그리곤 오랜기간 사용되지 않는다면 GC 됩니다.<br>(필요한 시점에 객체 생성하는것을 <strong>Lazy Loading</strong> 이라고 합니다. 싱글턴 패턴의 존재 의의기도 합니다.)</li>
</ul>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>&#123;</span><br><span class="line">  <span class="hljs-comment">// * Priavte: Cannot be initialized from outer</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Caculator</span><span class="hljs-params">()</span> </span>&#123;&#125;</span><br><span class="line">  <span class="hljs-comment">// * Non-Static: sum(a, b)</span></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">sum</span><span class="hljs-params">(Integer a, Integer a)</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">return</span> a + b;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-comment">// * Singleton: Can be initialized only once using getInstance()</span></span><br><span class="line">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Calculator uniqueInstance;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Calculator <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">      uniqueInstance = <span class="hljs-keyword">new</span> Calculator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>차이를 아시겠나요? 하지만 <strong>유일한 클래스</strong>의 정적 변수, 메서드든 <strong>유일한 객체</strong>인 싱글턴 패턴이든 진입점이 한 곳인 만큼 다중 스레드가 한번에 진입점에 들어올 때 서로를 어떻게 독립적으로 수행할 수 있게 보장할지가 문제가 됩니다. 이를 유식한 말로는 다수의 스레드가 모두 이 클래스 내지는 객체에 접근을 하려 경쟁한다는 의미로 <strong>Race Condition(경쟁 상태)</strong>라고 합니다.</p>
<h1 id="Race-Condition"><a href="#Race-Condition" class="headerlink" title="Race Condition"></a>Race Condition</h1><p>Java 에서 다중 스레드를 사용할지라도 <strong>JVM 메모리에서는 따로 스레드별로 영역들을 지정해주지 않기 때문에 프로그래머가 접근제어를 해주지 않는다면 하나의 클래스 혹은 객체를 두 스레드에서 접근할 수 있습니다.</strong> Java 의 객체, 변수, 메서드 모두 기본적으로 non-blocking 이므로 여러 스레드에서 하나의 클래스 혹은 객체 접근을 동시에 할 경우 함수, 변수를 중복 호출/사용하는 문제가 발생합니다. 이를 해결하기 위해 가장 단순하게 생각할 수 있는것은 <strong>함수 단위로 blocking</strong> 하는것입니다.</p>
<p>위 싱글턴 패턴의 예로 사용한 <strong>Caculator 클래스의 getInstance() 함수를 두 개의 스레드에서 동시에 진입했다고 가정</strong>합시다. 동시에 <code>if (uniqueInstance == null)</code> 구문에 진입했을때 <strong>어느 스레드도 그 다음 라인인 <code>new Caculator()</code> 를 수행하지 않았다고 가정한다면 두 스레드 모두 uniqueInstance 가 null 인것으로 판단</strong>할것입니다. 그리고 그 다음 라인에 두 스레드 각각 새 객체를 생성하게 되고, 이렇게 된다면 두 스레드는 하나의 객체 함수가 아닌 각자의 객체 함수를 보게됩니다. 단순 계산 객체라면 큰 영향은 없겠지만 만약 하나의 상태를 공유하려는 객체라면 두 스레드가 서로 다른 상태를 보고있는 끔찍한 상황이 연출됩니다.</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread1: getInstance() </span><br><span class="line">  <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">// 2019-03-03 00:00:01</span></span><br><span class="line">    uniqueInstance = <span class="hljs-keyword">new</span> Calculator();  <span class="hljs-comment">// 2019-03-03 00:00:03 - Calculator 객체 1 생성 (Thread1)</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread2: getInstance() </span><br><span class="line">  <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;         <span class="hljs-comment">// 2019-03-03 00:00:02</span></span><br><span class="line">    uniqueInstance = <span class="hljs-keyword">new</span> Calculator();  <span class="hljs-comment">// 2019-03-03 00:00:04 - Calculator 객체 2 생성 (Thread2)</span></span><br></pre></td></tr></table></figure>
<h2 id="함수-단위-Blocking-Synchronized"><a href="#함수-단위-Blocking-Synchronized" class="headerlink" title="함수 단위 Blocking - Synchronized"></a>함수 단위 Blocking - Synchronized</h2><p>다수의 스레드가 한 함수에 접근하려 한다면, 하나의 스레드가 해당 함수를 수행하는 동안에는 기다리도록 blocking 합니다. Java 가 제공하는 <strong>synchronized</strong> 키워드를 사용하면 손쉽게 해당 함수 호출을 blocking 할 수 있습니다. 이젠 Thread 1 이 해당 함수를 호출하고 끝날때까지 Thread 2 는 해당 함수 호출을 계속 기다려야합니다. 두 스레드가 한 함수를 동시에 호출할일은 없어졌습니다.</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Calculator <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">      uniqueInstance = <span class="hljs-keyword">new</span> Calculator();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-keyword">return</span> uniqueInstance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>하지만 싱글턴 함수가 위에 로직보다 더 복잡하고 수행시간이 길다면 다른 스레드들은 한 스레드가 해당 함수 호출을 완료하는 그 긴 시간동안 멈춰있어야하는 성능의 이슈가 있습니다. 이런 경우에는 함수 단위의 blocking 이 아니라 함수 내 blocking 해야하는 딱 <strong>그 변수만 집어서 blocking</strong> 하는게 좋겠지요.</p>
<h2 id="변수-생성-단위-Blocking-DCL-Double-Checked-Locking"><a href="#변수-생성-단위-Blocking-DCL-Double-Checked-Locking" class="headerlink" title="변수 생성 단위 Blocking - DCL (Double Checked Locking)"></a>변수 생성 단위 Blocking - DCL (Double Checked Locking)</h2><p>우리의 원래 목적은 “변수”의 스레드간 공유인데, 굳이 함수 단위의 blocking 을 해서 변수 외 나머지 로직 수행의 시간까지 손만 빨며 성능 이슈까지 발생시킬 이유는 없습니다. 똑똑한 프로그래머들의 고민 결과 <strong>“함수”가 아닌 “변수” 단위의 Blocking</strong> 을 고안해내었고 이를 <strong>DCL (Double Checked Locking)</strong>이라고 명명합니다. 왜 Double Checked 일까요? 아래 코드를 보시면 객체 생성 로직 진입 전과 진입 후 생성하기전에 한번 더 null 여부를 검사하기 때문인것으로 알 수 있습니다.</p>
<ul>
<li><p><strong>함수 단위 Blocking - 함수에 synchronized 추가</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Calculator uniqueInstance;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Calculator <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">    uniqueInstance = <span class="hljs-keyword">new</span> Calculator();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>변수 생성 단위 Blocking - 변수에 volatile 추가, 함수 내 해당 변수에 synchronized 추가</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> Calculator uniqueInstance;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Calculator <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">  <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">synchronized</span> (Calculator.class) &#123;</span><br><span class="line">      <span class="hljs-keyword">if</span> (uniqueInstance == <span class="hljs-keyword">null</span>) &#123;</span><br><span class="line">        uniqueInstance = <span class="hljs-keyword">new</span> Calculator();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-keyword">return</span> uniqueInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>기존 방식은 getInstance() <strong>함수에 synchronized</strong> 가 붙어있는 반면, 변수 생성 단위 Blocking 에서는 <strong>변수에 volatile</strong> 이 추가되었고, 해당 함수 내 아까 <strong>volatile 을 추가한 변수에 대해서 synchronized</strong> 붙여준걸 알 수 있습니다. 여기서 유념히 보셔야할것은 <strong>변수를 사용하는 부분</strong>이 아닌 <strong>변수를 생성하는 부분에 synchronized 를 붙여줬음</strong>을 꼭 기억하시기 바랍니다.</p>
<h3 id="DCL-Double-Checked-Locking-의-의미"><a href="#DCL-Double-Checked-Locking-의-의미" class="headerlink" title="DCL (Double Checked Locking) 의 의미"></a>DCL (Double Checked Locking) 의 의미</h3><p>모든 프로그램 및 스레드는 CPU 을 통해 연산들을 수행하고, 연산을 위한 변수값들은 “메인 메모리”로부터 CPU 바로 옆 “캐시”로 가져와 사용하게 됩니다. 만약 두 스레드가 각자 다른 CPU (멀티코어 환경) 에서 하나의 싱글턴 혹은 정적 변수를 공유하여 작동한다면 어떤 일이 발생할까요? </p>
<center><img src="/2019/03/02/singleton-pattern/race-condition.svg"></center>

<p>두 스레드가 공유하는 하나의 변수는 기본적으로 “메인 메모리”에 적재되어 있습니다. 각 스레드가 각 CPU 에서 값을 변경하는 경우 1) 먼저 메인 메모리로부터 캐시로 변수값을 가져오고, 2) CPU 가 해당 캐시의 값을 변경하고, 3) 캐시에 변경된 값을 메인 메모리에 작성(동기화)하는 과정을 거칩니다. 두 스레드가 동시에 변수의 값에 접근할 경우, 첫번째 스레드가 자신이 할당된 CPU 내 캐시의 변수값을 먼저 바꿨음에도 불구하고 아직 메인 메모리에 쓰지 않아 두번째 스레드는 변경된 값을 모른채 자신의 CPU 에서 독립적으로 값 변경을 수행하는 문제가 발생합니다. </p>
<p>그렇다고 다수 스레드가 하나의 CPU 에서 수행된다고 하더라도 아예 문제가 없는것은 아닙니다. JIT 컴파일러에 의해 어셈블리 레벨 코드 재배열(Reorder)이 발생하여 스레드 간 참조하는 변수값이 달라질 수 있기 때문입니다.</p>
<p>위에서 설명한 스레드간 변수 동기화 내지는 불일치 문제를 한 스레드의 값 업데이트를 다른 스레드에서는 볼 수 없다는 의미의 <strong>가시성(Visibility) 문제</strong>라고 일컫습니다. 볼 수 있다면 Visible 하다. 라고 표현합니다.</p>
<p>가시성 문제를 해결하기 위해 “캐시”와 “메인 메모리” 간 <strong>읽은(READ) 값이 일치하도록 강제하는 것이 volatile</strong> 키워드 입니다. 변수에 volatile 키워드를 추가하면 해당 변수는 CPU 에서 “캐시”의 값을 읽을때 동시에 “메인 메모리”의 값을 Read 함을 보장합니다. 한 스레드에서 값을 변경한다면 바로 메인 메모리에 적용되고 다른 스레드가 값을 읽을 때 최신의 값을 읽을 수 있습니다. </p>
<p>하지만 두 스레드가 같은 메인 메모리 값을 가져다가 변경할 경우는 여전히 문제입니다. 값을 쓰는것은 어쩔 수 없이 blocking 을 걸어두어야합니다. 한 스레드가 작성하고있다면 다른 스레드는 기다렸다가 앞 스레드가 작성을 마치면 바로 메인 메모리로부터 값을 읽어서 그 다음 쓰기를 진행하면 됩니다. 이를 위해 <strong>값을 변경(WRITE)할때는 해당 클래스에 blocking 을 거는 synchronized</strong> 키워드를 함께 사용하면 됩니다. </p>
<h2 id="변수-사용-단위-Blocking-Lazy-Holder"><a href="#변수-사용-단위-Blocking-Lazy-Holder" class="headerlink" title="변수 사용 단위 Blocking - Lazy Holder"></a>변수 사용 단위 Blocking - Lazy Holder</h2><p>애석하게도 변수 생성 단위의 Blocking 으로 단일 생성이 완벽히 보장되진 않았습니다. 세상에, CPU 캐시까지 고려했는데 무엇을 또 놓쳤다는걸까요? 트랜지스터 레벨이라도 봐야하는 것일까요? <strong>DCL 을 통해 변수의 단일 생성 자체는 보장</strong>되었습니다. 다만 <strong>단일 생성 바로 직후</strong>에 다른 스레드에서 해당 변수를 바로 사용하려 한다면, 아직 채 완전히 생성되지 못한 변수를 사용하게 될 수 있다는 것입니다. 단일 생성을 시작하면 해당 클래스의 new ..를 통해 생성자를 수행하게 될 것입니다. 생성자가 조금이라도 복잡하다면 온전한 객체가 만들어지기 까지는 조금의 시간이 걸릴 것입니다. 하지만 해당 객체를 접근하는 다른 스레드는 그 라인의 끝마침을 기다려주지 않습니다. 이때 미처 다 온전하게 생성되지 않은 불완전한 객체를 다른 스레드에서 가져다가 사용하게 되는것입니다. 이를 <strong>out-of-order write 문제</strong>라고 명명합니다.</p>
<p>해결은 해당 객체가 <strong>단순히 생성되었다</strong> 여부가 아닌 <strong>완벽히 생성되었다</strong>는걸 보장하면 됩니다. 이를 보장하는 방식은 더 똑똑한 프로그래머들에 의해 정말 다양하게 제시되었는데요. 기발한것들도 있지만 그 중에 가장 이해가 쉬운것은 아래와 같습니다.</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazyHolder</span> </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Calculator UNIQUE_INSTANCE = <span class="hljs-keyword">new</span> Calculator();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Calculator <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">      <span class="hljs-keyword">return</span> LazyHolder.UNIQUE_INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>static final 로 정의된 <code>UNIQUE_INSTANCE</code>는 클래스로더에 의해 프로그램 시작 시 가장 먼저 Static 영역에 바로 적재됩니다. 이를 통해 getInstance() 호출되기 이전에 UNIQUE_INSTANCE = new Calculator(); 가 무조건 존재함을 보장합니다.</li>
</ul>
<p>사실상 위에서 배운 모든 것을 활용한 해결책에 해당합니다. 개인적으로 이 해결책이 기억에 남는 이유가 C# 에서 LazyHolder 형식을 기본적으로 제공해주기 때문에 싱글턴 패턴 사용이 아래와 같이 매우 쉽게 해결했던 기억이 있습니다.</p>
<figure class="highlight csharp hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">readonly</span> Lazy&lt;Singleton&gt; lazy = <span class="hljs-keyword">new</span> Lazy&lt;Singleton&gt;(() =&gt; <span class="hljs-keyword">new</span> Singleton());  </span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton Instance &#123; <span class="hljs-keyword">get</span> &#123; <span class="hljs-keyword">return</span> lazy.Value; &#125; &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"></span>)</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<ol>
<li><a href="https://gampol.tistory.com/entry/Double-checked-locking%EA%B3%BC-Singleton-%ED%8C%A8%ED%84%B4" target="_blank" rel="noopener">https://gampol.tistory.com/entry/Double-checked-locking%EA%B3%BC-Singleton-%ED%8C%A8%ED%84%B4</a></li>
<li><a href="http://thswave.github.io/java/2015/03/08/java-volatile.html" target="_blank" rel="noopener">http://thswave.github.io/java/2015/03/08/java-volatile.html</a></li>
</ol>

        </div>
        
        
        
    </div>
</div>










    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <!-- <time class="level-item has-text-grey" datetime="2019-02-27T13:23:42.000Z">2019-02-27</time> -->
                <div class="level-item has-text-grey">2019-02-27</div>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Design-Pattern/">Design Pattern</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Design-Pattern/Observer/">Observer</a>
                </div>
                
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/02/27/observer-pattern/">5. 옵저버 패턴</a>
            
        </h1>
        <div class="content">
            <p>디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다.</p>
<ul>
<li><a href="https://aaronryu.github.io/2018/12/30/a-introduction-to-design-patterns/">1. 디자인 패턴에 앞서</a></li>
<li><a href="https://aaronryu.github.io/2019/02/21/two-principles-of-design-patterns/">2. 디자인 패턴의 제 1, 2 원칙</a></li>
</ul>
<p>설명에 사용할 코드는 Java-like Pseudo Code 입니다.</p>
<hr>
<h1 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h1><p>프로그래밍을 처음 배울때 우리는 먼저 변수에 대해 배웁니다.<br>변하지 않는 값은 Constant 상수라고 부르며, Variable 변수의 값은 수시로 변합니다.<br>변수는 수시로 변할 수 있기 때문에 말 그대로 프로그램 내내 산전수전을 다 겪습니다.</p>
<h1 id="상태"><a href="#상태" class="headerlink" title="상태"></a>상태</h1><p>변수는 위에서 언급한대로 정말 다양한 상태를 갖습니다. 이러한 변수의 상태를 알기 위해서는 두 가지 방법이 있습니다.</p>
<h2 id="Push-방식"><a href="#Push-방식" class="headerlink" title="Push 방식"></a>Push 방식</h2><blockquote>
<p><strong>자동</strong>: <strong>변수가</strong> 자신이 상태가 바뀌었음을 우리에게 <strong>알려줍니다</strong>.</p>
</blockquote>
<h2 id="Pull-방식"><a href="#Pull-방식" class="headerlink" title="Pull 방식"></a>Pull 방식</h2><blockquote>
<p><strong>수동</strong>: <strong>우리가</strong> 변수가 상태가 바뀌었는지를 직접 <strong>알아봅니다</strong>.</p>
</blockquote>
<p><strong>자동</strong>으로 우리에게 알려주는게 가장 편해보일 수도 있겠지만 굳이 알 필요가 없는데 계속해서 자신의 상태에 대해 말해준다면 매우 귀찮겠지요. 그 상태를 계속 추적하기 위한 자원도 불필요하게 낭비될것입니다. 그럴때는 우리가 필요할때만 상태를 볼 수 있는 <strong>수동</strong>의 방법도 필요합니다. 이를 조금 고지식하게 <strong>Push</strong> 와 <strong>Pull</strong> 방식으로 이야기합니다. <strong>변수의 상태를 하나의 ‘주제’라고 본다면</strong> 주제를 중심으로 <strong>우리에게 알려주는지(Push)</strong> 아니면 <strong>우리가 알아보는지(Pull)</strong>에 따라 상태를 알 수 있는 방법이 나뉘는것입니다.</p>
<h1 id="옵저버-패턴"><a href="#옵저버-패턴" class="headerlink" title="옵저버 패턴"></a>옵저버 패턴</h1><blockquote>
<p>옵저버 패턴은 변수의 상태를 Push 와 Pull 중 원하는 방식을 통해 알 수 있는 패턴입니다.</p>
</blockquote>
<center><img src="/2019/02/27/observer-pattern/observer.svg"></center>

<p>일반적으로 이 패턴을 설명할때 상태를 ‘주제’라 보고 Publish-Subscribe(발행-구독) 모델로 설명하곤합니다. 여기선 패턴 이름이 옵저버 패턴인 만큼 헷갈리지 않게 구독모델이 아닌 <strong>Observer</strong>와 <strong>Observable</strong> 두 가지 용어로만 설명을 드리겠습니다. 옵저버 패턴에는 앞서 말씀드린 딱 두 종류의 인터페이스만 존재합니다. 하나는 <strong>상태를 갖고있는 옵저버블</strong>, 나머지 하나는 <strong>상태를 보려하는 옵저버</strong>입니다.</p>
<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>위 옵저버 패턴 그림을 보시면 옵저버블 인터페이스는 두 가지 정보를 ‘구성’(has)합니다.</p>
<ol>
<li><strong>상태</strong> (State)</li>
<li><strong>옵저버 리스트</strong> (Observers)</li>
</ol>
<p>오해를 해서는 안되는 점이 옵저버블 인터페이스는 <strong>상태 자체</strong>가 아니라 <strong>상태를 ‘갖고 있다’</strong>는 것입니다. 상태를 갖고있다는 의미로 옵저버블, 즉 <strong>옵저버는 이 인터페이스를 통해 상태를 ‘볼 수 있다’</strong>는 의미인것입니다. 그리고 옵저버블은 상태를 알려주거나/알아보려는 옵저버들을 리스트(물론 다른 자료구조형도 가능합니다)로 관리하여 <strong>Push 방식의 경우에는 상태를 누구에게 보내줄지?</strong> 그리고 <strong>Pull 방식의 경우에는 상태를 누구만 볼 수 있는지?</strong> 결정할 수 있습니다.</p>
<ul>
<li><p><strong>옵저버블 인터페이스</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">protected</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer o)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer o)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>옵저버블 구현</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateObservable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observable</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> State state;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeState</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 상태가 변경됩니다. */</span> &#125;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123; <span class="hljs-comment">/* 옵저버 제외 */</span> &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer o)</span> </span>&#123; <span class="hljs-comment">/* 옵저버 추가 */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>notifyObserver 구현 - 1) Push 방식</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">(State state)</span> </span>&#123; <span class="hljs-comment">/* 2. 옵저버 리스트의 각 옵저버들에게 1. 상태를 전송 */</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>notifyObserver 구현 - 2) Pull 방식</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 아무것도 하지 않습니다. */</span> <span class="hljs-keyword">null</span> &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-comment">/* 상태를 보고싶으면 옵저버가 이 함수를 호출하면 됩니다. */</span> <span class="hljs-keyword">return</span> state; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>옵저버는 길게 설명할 것 없이 <strong>상태를 보고자 하는 인터페이스</strong>입니다. 인터페이스인 만큼 해당 정보를 보고, 활용하고싶다면 의도에 맞게 원하는 방식대로 구현하여 사용하시면 됩니다.</p>
<ul>
<li><p><strong>옵저버 인터페이스</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">protected</span> Observable observable;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getStateFromObservable</span><span class="hljs-params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>옵저버 구현</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StateObserver</span><span class="hljs-params">(Observable observable)</span> </span>&#123; </span><br><span class="line">        <span class="hljs-keyword">this</span>.observable = observable;</span><br><span class="line">        <span class="hljs-keyword">this</span>.observable.registerObserver(<span class="hljs-keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(state)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>왜 StateObserver 를 <code>Observable.getObservers().add(new StateObserver())</code> 방식으로 추가하지 않고 StateObserver 객체를 생성할때 Observable 를 넣어줌으로써 생성자 안에서 추가를 해주었을까요?</p>
<blockquote>
<p><code>Observable.getObservers()</code>를 호출하지 않음으로써 <strong>옵저버 리스트를 옵저버블 외부에 절대 노출하지 않습니다.</strong></p>
</blockquote>
<hr>
<p>옵저버 패턴을 왜 굳이 패턴으로 정의했을까요? 저렇게 복잡하게 할 필요까진 없을텐데요. 옵저버블과 옵저버 두 인터페이스가 서로의 구현에 대해서 전혀 알 필요없이 데이터만을 주고 받는데 의의가 있습니다. 좀 더 풀어쓰자면 아래와 같습니다.</p>
<blockquote>
<p><strong>옵저버블이 갖는 1. 상태와 2. 옵저버 테이블 모두 외부에 노출하지 않은채 오로지 옵저버들만 알게끔하는 것이죠.</strong><br><strong>“서로 상호작용을 하는 객체 사이에는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.”</strong>는 원칙입니다.</p>
</blockquote>
<p>잘 이해가 되셨는지요. 오늘의 디자인 패턴은 여기서 마치도록 하겠습니다.</p>

        </div>
        
        
        
    </div>
</div>










    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <!-- <time class="level-item has-text-grey" datetime="2019-02-26T17:59:41.000Z">2019-02-27</time> -->
                <div class="level-item has-text-grey">2019-02-27</div>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Design-Pattern/">Design Pattern</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Design-Pattern/Adapter-Decorator/">Adapter, Decorator</a>
                </div>
                
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/02/27/adapter-decorator-facade-pattern/">4. 데코레이터, 어댑터, 퍼사드 패턴</a>
            
        </h1>
        <div class="content">
            <p>디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다.</p>
<ul>
<li><a href="https://aaronryu.github.io/2018/12/30/a-introduction-to-design-patterns/">1. 디자인 패턴에 앞서</a></li>
<li><a href="https://aaronryu.github.io/2019/02/21/two-principles-of-design-patterns/">2. 디자인 패턴의 제 1, 2 원칙</a></li>
</ul>
<p>설명에 사용할 코드는 Java-like Pseudo Code 입니다.</p>
<hr>
<h1 id="분장술"><a href="#분장술" class="headerlink" title="분장술"></a>분장술</h1><p>아기돼지 삼형제를 보면 양가죽을 쓰고 하얀색 분으로 손을 칠해 양으로 변장한 늑대가 나옵니다. 물론 너무 어설픈 나머지 막내돼지한테 비웃음을 당하지만 돼지들의 집을 들어가기 위해서는 ‘변장’이 필요했던 것이죠. 이번에 얘기할 내용은 분장과 변장에 대한 이야기입니다. 여기서 잠깐 그 차이를 알아볼까요.</p>
<h2 id="분장"><a href="#분장" class="headerlink" title="분장"></a>분장</h2><p>분장은 현재 <strong>나의 모습</strong>에서 조금 더 <strong>과장한 나의 모습</strong>으로 꾸민것입니다.<br><strong>나 자신은 그대로</strong>, 어렵게 말하면 본질은 해치지 않는 선에서 그 위에 <strong>무엇인가를 추가로 꾸민것</strong>이죠.</p>
<h2 id="변장"><a href="#변장" class="headerlink" title="변장"></a>변장</h2><p>변장은 현재 <strong>나의 모습</strong>에서 <strong>완전 다른것의 모습</strong>으로 꾸민것입니다.<br><strong>나 자신이 아닌 완전 다른 어떤것으로 꾸민것</strong>이죠.</p>
<p>이번 챕터에서 배울것은 <strong>분장에 해당하는 데코레이터 패턴</strong>과 <strong>변장에 해당하는 어댑터 패턴</strong>입니다. 마지막으론 앞서 두 패턴처럼 한 클래스를 다른 클래스로 바꾸는것이 아닌 <strong>다수의 클래스를 하나의 클래스로 단순히 묶어주는 퍼사드 패턴</strong>을 다루고 마칠 예정입니다.</p>
<h1 id="어댑터-패턴-변장"><a href="#어댑터-패턴-변장" class="headerlink" title="어댑터 패턴 - 변장"></a>어댑터 패턴 - 변장</h1><p>앞서 늑대가 돼지삼형제 집으로 들어가기 위해 순한 양으로 변장했습니다. 무시무시한 발톱을 하얀 분칠을 통해 예뻐보이는 손으로 바꾸었고, 그르렁거리는 목소리를 순한 양처럼 메에 흉내내기도 해봅니다. 이를 클래스로 표현하면 이해가 매우 Sheep습니다.</p>
<ul>
<li><p><strong>늑대</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wolf</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Claw</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"Sharp Claw"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Growl</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"Grrrrrrr"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>늑대가 돼지삼형제 집에 들어가기 위해 양으로 ‘변장’했군요.</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WolfWantsToBeSheep</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sheep</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">public</span> Wolf wolf;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Hand</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        wolf.Claw().replace(<span class="hljs-string">"Sharp Claw"</span>, <span class="hljs-string">"White Hand"</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Sound</span><span class="hljs-params">()</span> </span>&#123;</span><br><span class="line">        wolf.Growl().replace(<span class="hljs-string">"Grrrrrrr"</span>, <span class="hljs-string">"Baaaaaaa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>이제 늑대는 양이 들어갈 수 있는곳이면 어디든 갈 수 있습니다. 양만 들어갈 수 있는 돼지삼형제 집에 한번 들어가보겠습니다.</p>
<ul>
<li><p><strong>돼지삼형제 집</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WelcomeToPigHouse</span><span class="hljs-params">(Sheep sheep)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>실제 양은 돼지삼형제 집에 잘 들어갑니다.</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WelcomeToPigHouse(<span class="hljs-keyword">new</span> Sheep());</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>이런, 양으로 변한 늑대도 돼지삼형제 집에 들어갔군요.</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WelcomeToPigHouse(<span class="hljs-keyword">new</span> WolfWantsToBeSheep(<span class="hljs-keyword">new</span> Wolf()));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>어떤 클래스나 함수를 <strong>클라이언트</strong>로 본다면 <strong>클라이언트들은 특정 타켓 인터페이스에만 맞게 구현</strong>되어있습니다. 이런 제약때문에 다른 클래스를 해당 클라이언트에서 사용하고 싶을지라도, <strong>해당 클래스가 타겟 인터페이스의 구현체가 아니라면 사용할 수 없습니다.</strong> 위의 예처럼 태어났을때부터 늑대였지만 돼지삼형제 집에 가기위해서는 순한 양이 되어야하는 상황말이죠. 일반 비지니스에서도 이와 같이 어떤 클래스를 클라이언트 목적에 맞는 클래스로 사용해야하는 갑작스런 요구사항이 발생하곤 합니다.</p>
<h2 id="객체-어댑터"><a href="#객체-어댑터" class="headerlink" title="객체 어댑터"></a>객체 어댑터</h2><p>위 늑대와 양의 예시처럼 어댑터 패턴은 <strong>어댑터</strong>라는 <strong>타겟 인터페이스의 구현 클래스</strong>를 생성하고 그 안에 <strong>타켓 인터페이스로 변장하고자 하는 클래스를 객체</strong>로 갖습니다. 이를 <strong>어댑티</strong>라고 명명하는데요. 어댑티의 원래 함수와 프로퍼티들을 활용하여 <strong>타겟 인터페이스의 각 함수들을 구현</strong>하면 됩니다. </p>
<p>이걸 <strong>객체 어댑터</strong>로 부르는 이유는 <strong>어댑티를 어댑터가 객체로 갖고 있기 때문</strong>입니다. 이를 우리는 ‘구성’이라고 배웠었지요. 아래의 코드를 보면 Adapter 가 Adaptee 를 객체로 가지고 있습니다. 클래스 다이어그램이 이해를 조금 더 도와줄겁니다.</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Client</span><span class="hljs-params">(TargetInterface interface)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Adaptee adaptee; </span><br><span class="line">    <span class="hljs-comment">// ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">this</span>.Client(<span class="hljs-keyword">new</span> Adapter(<span class="hljs-keyword">new</span> Adaptee()));</span><br></pre></td></tr></table></figure>
<p>어답티는 어답터의 도움으로 TargetInterface 만을 사용하는 클라이언트에 주입가능해졌습니다.</p>
<center><img src="/2019/02/27/adapter-decorator-facade-pattern/adapter.svg"></center>

<p>그럼 <strong>클래스 어댑터</strong>은 무엇일까요? Adapter 가 Adaptee 를 <strong>객체의 형태로 ‘구성’</strong>하지 않고 <strong>클래스의 형태로 ‘상속’</strong>하면 됩니다.</p>
<h2 id="클래스-어댑터"><a href="#클래스-어댑터" class="headerlink" title="클래스 어댑터"></a>클래스 어댑터</h2><p>클래스 어댑터는 되려 단순합니다. 아래 코드와 클래스 다이어그램을 보시면 객체 어댑터와 두 가지 차이점이 있습니다.</p>
<ol>
<li>Adapter 가 Adaptee 를 구성(has)하지 않고 상속(extends)하고 있습니다.</li>
<li>Target 이 Interface 가 아니라 Class 로 존재하며, 그에 따라 구현(implements)이 아닌 상속(extends)을 하고 있습니다.</li>
</ol>
<ul>
<li><strong>객체 어댑터</strong><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Adaptee adaptee; </span><br><span class="line">    <span class="hljs-comment">// ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<center><img src="/2019/02/27/adapter-decorator-facade-pattern/object-adapter.svg"></center>


<ul>
<li><strong>클래스 어댑터</strong><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Target</span>, <span class="hljs-title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// ... adaptee 함수를 활용해 Target 의 함수를 확장합니다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<center><img src="/2019/02/27/adapter-decorator-facade-pattern/class-adapter.svg"></center>

<p>위 코드를 보고 흠칫하셨을것입니다. Java 에서는 다중 상속을 지원하지 않기때문에 extends A, B 와 같은 문법은 사용할 수 없습니다. 또한 이렇게 사용할 경우 Target 이 Interface 가 아닌 Class 이기 때문에 다른 클래스로 대체할 수 없을뿐더러 Adapter 와 Target 이 단단히 엮어버렸습니다. 이는 배운대로 유연성을 해치는 구조이기에 사용을 권하지 않습니다.</p>
<h2 id="다중-어댑터"><a href="#다중-어댑터" class="headerlink" title="다중 어댑터"></a>다중 어댑터</h2><p>다중 어댑터는 기존에 <strong>하나의 타겟 인터페이스만 지원</strong>하는것이 아닌 <strong>다수의 타겟 인터페이스를 모두 지원</strong>하는걸 의미합니다. 하나의 어댑티 클래스를 <strong>여기 인터페이스뿐만 아니라 저 인터페이스에서도 사용하고 싶을때</strong> TargetOneInterface, TargetTwoInterface 를 하나의 어댑터 클래스로 연결하고 두 인터페이스의 모든 것을 구현하면 됩니다. 객체 어댑터가 아니라 클래스 어댑터라면 두 개의 클래스 TargetOne, TargetTwo 를 상속(extends) 하면 됩니다.</p>
<ul>
<li><strong>다중 (객체) 어댑터</strong><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClientOne</span><span class="hljs-params">(TargetOneInterface interface1)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClientAnother</span><span class="hljs-params">(TargetTwoInterface interface2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetOneInterface</span>, <span class="hljs-title">TargetTwoInterface</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Adaptee adaptee; </span><br><span class="line">    <span class="hljs-comment">// ... adaptee 함수를 활용해 TargetOne/TwoInterface 의 함수들을 모두 구현합니다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="데코레이터-패턴-분장"><a href="#데코레이터-패턴-분장" class="headerlink" title="데코레이터 패턴 - 분장"></a>데코레이터 패턴 - 분장</h1><p>데코레이터 패턴은 클래스에 추가적인 기능을 무수히 많이 추가하더라도 그 클래스는 본래 클래스의 기능을 유지하는 ‘분장’에 해당합니다. 데코레이터 패턴을 어댑터 패턴 다음에 같이 다루는 이유는 사실 원리는 어댑터-어댑티 개념과 같기 때문입니다. 어댑터가 <strong>Adaptee</strong>를 <strong>TargetInterface</strong>로 변장시켰다면, 데코레이터는 <strong>Decoratee</strong>를 <strong>Decoratee</strong> 자기 자신으로 분장시키는 꼴이 됩니다.</p>
<ul>
<li><p><strong>어댑터 패턴 - 변장</strong>: Adaptee != TargetInterface</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Adaptee adaptee;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>데코레이터 패턴 - 분장</strong>: Decoratee == Decoratee</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decoratee</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Decoratee decoratee; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>데코레이터 패턴은 한번만 분장하기 위해 사용되지 않습니다. 자기 자신을 재귀적으로 계속 분장할 수 있는데요. 아무리 다양한 DecoratorA, DecoratorB 를 만들어 꾸미더라도 결국에 Decoratee 클래스기 때문에 기존 클라이언트에서는 크게 신경쓰지 않고 쓰던 그대로 사용하면 됩니다.</p>
<blockquote>
<p>데코레이터 패턴은 Decorater 클래스가 Decoratee 를 Decoratee 로 분장하는것입니다.<br>Decorator 는 Decoratee 를 상속받기 때문에 그 자신도 Decoratee 가 될 수 있습니다.<br>따라서 Decorator 는 재귀적으로 Decoratee 에 위치할 수 있어 무한정 분장될 수 있습니다.</p>
</blockquote>
<ul>
<li><p><strong>데코레이티</strong>: 꾸미고 싶은 객체</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decoratee</span> </span>&#123;</span><br><span class="line">    <span class="hljs-comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>데코레이터</strong>: 꾸며주는 객체</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decoratee</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Decoratee decoratee; </span><br><span class="line">    <span class="hljs-comment">// ... decoratee 함수를 활용해 더 개선된 decoratee 함수로 확장합니다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>단순한 코드는 위와 같지만 아마 책으로 접하신 데코레이터 패턴 코드는 아래와 같은 구조를 갖고 있었을것입니다.</p>
<ul>
<li><p><strong>추상 데코레이터</strong>: 꾸며주는 추상 객체</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decoratee</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">protected</span> Decoratee decoratee; </span><br><span class="line">    Decorator(Decoratee decoratee) &#123; </span><br><span class="line">        <span class="hljs-keyword">this</span>.decoratee = decoratee </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>구현 데코레이터</strong>: 꾸며주는 구현 객체</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoratorA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span> </span>&#123;</span><br><span class="line">    DecoratorA(Decoratee decoratee) &#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>(decoratee)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-comment">// ... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>정말 단순한 데코레이팅만 원하신다면 처음에 설명해드린 형태로도 충분합니다. 그렇다 하더라도 위와 같이 <strong>추상 데코레이터</strong>와 <strong>구현 데코레이터</strong>를 나누는 걸 추천드리는 이유는 다음과 같은 이점을 갖기 때문입니다.</p>
<ul>
<li>구현 데코레이터에서 공통으로 필요로하는 로직이나 프로퍼티(특히 데코레이티)를 두고 구현 시 활용 가능합니다.</li>
<li>수많은 구현 데코레이터들을 추상 데코레이터 하나로 관리할 수 있습니다.</li>
</ul>
<p><strong>구현보다 인터페이스를 사용하라.</strong>던 <strong>디자인 패턴 제 1원칙</strong> 기억하시나요? 구현이 아닌 인터페이스(혹은 추상클래스)의 이점은 원하는 구현클래스를 붙였다 떼었다 할 수 있는 유용성과 재사용성이었습니다. 예를 들어 구현 데코레이터들을 하나의 리스트나 셋으로 담아 관리하고싶을때 추상 데코레이터 타입의 리스트, 셋을 생성하여 사용할 수 있겠죠.</p>
<h1 id="퍼사드-패턴-묶음"><a href="#퍼사드-패턴-묶음" class="headerlink" title="퍼사드 패턴 - 묶음"></a>퍼사드 패턴 - 묶음</h1><p>마지막으로 배울 패턴은 퍼사드 패턴입니다. 어댑터와 데코레이터 패턴은 <strong>각 하나의 어댑티나 데코레이티를 갖는다</strong>는 <strong>공통점</strong>이 있고, <strong>차이점</strong>은 <strong>어댑터는 다른 클래스로 ‘변장’</strong>하고 <strong>데코레이터는 같은 데코레이터(사실상 데코레이티)로 ‘분장’</strong>한다는 것 이었습니다. 퍼사드 패턴을 이 챕터에서 다룬다는것은 이들과 공통점이 있다는 것일텐데요. 어떤것이 같을까요?</p>
<p>퍼사드 패턴은 어댑터, 데코레이터 패턴의 공통점을 그대로 갖습니다. 어댑티, 데코레이티와 같이 활용하기 위한 클래스를 내부에 갖고있습니다. 다만 어댑터, 데코레이터가 어댑티, 데코레이티를 하나씩만 가졌다면 <strong>퍼사드는 엄청 많은 수의 클래스를 갖습니다.</strong> 그리고 어댑터와 데코레이터의 차이점이 ‘변장’이나 ‘분장’이냐의 차이였다면 퍼사드는 그저 그 자체로 새로운 클래스가 됩니다. <strong>어댑터 패턴</strong>도 클래스 자신이 아닌 <strong>다른 클래스</strong>로 ‘변장’한다고 했는데 그럼 퍼사드 패턴도 마찬가지가 아닐까요? <strong>아닙니다.</strong> 퍼사드 패턴은 특정 클래스가 다른 특정 클래스로 변장하는것이 아닌 <strong>다수의 클래스가 다른 하나의 클래스로 단순히 묶이는 것</strong>입니다.</p>
<ul>
<li><p><strong>(객체) 어댑터</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Adaptee adaptee; </span><br><span class="line">    <span class="hljs-comment">// ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>퍼사드</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> ClassA classA;</span><br><span class="line">    <span class="hljs-keyword">private</span> ClassB classB; </span><br><span class="line">    <span class="hljs-keyword">private</span> ClassC classC; </span><br><span class="line">    <span class="hljs-comment">// ... ClassA, B, C 를 활용한 새 함수들을 만듭니다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>퍼사드는 뒤에 어떠한 extends, implements 도 존재하지 않습니다. 단순히 여러 클래스를 묶어주는 하나의 클래스인 셈입니다. </p>
<p>항상 마지막에 가면 집중력이 흐트러지곤 합니다. 중간쯤 읽다보면 세줄요약을 시급하게 찾는 자신을 발견하셨을겁니다. 그래도 꼭 한번은 다 잃고 아래 세줄요약을 읽어주시기 바랍니다. 그래야 머리속에 한번에 들어갈 수 있으니까요.</p>
<hr>
<p><strong>어댑터 패턴</strong></p>
<blockquote>
<p><strong>하나의 클래스</strong>(어댑티)를 <strong>다른 하나의 클래스</strong>(타겟 인터페이스)로 <strong>‘변장’</strong>합니다.</p>
</blockquote>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Adaptee adaptee; </span><br><span class="line">    <span class="hljs-comment">// ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>데코레이터 패턴</strong></p>
<blockquote>
<p><strong>하나의 클래스</strong>(데코레이티)를 <strong>그 하나의 클래스</strong>(데코레이티)로 <strong>‘분장’</strong>합니다.</p>
</blockquote>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decoratee</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> Decoratee decoratee; </span><br><span class="line">    <span class="hljs-comment">// ... decoratee 함수를 활용해 더 개선된 decoratee 함수로 확장합니다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위 예제 코드는 이해를 위해 간단한 데코레이터 클래스를 작성했습니다. 본문에서 설명드린바와 같이 추상/구현 데코레이터로 사용하는걸 추천드립니다.</p>
<p><strong>퍼사드 패턴</strong></p>
<blockquote>
<p><strong>다수의 클래스</strong>를 <strong>다른 하나의 클래스</strong>로 <strong>묶습</strong>니다.</p>
</blockquote>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span> </span>&#123;</span><br><span class="line">    <span class="hljs-keyword">private</span> ClassA classA;</span><br><span class="line">    <span class="hljs-keyword">private</span> ClassB classB; </span><br><span class="line">    <span class="hljs-keyword">private</span> ClassC classC; </span><br><span class="line">    <span class="hljs-comment">// ... ClassA, B, C 를 활용한 새 함수들을 만듭니다.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

        </div>
        
        
        
    </div>
</div>










    <div class="card">
    
    <div class="card-content article ">
        
        <div class="level article-meta is-size-7 is-uppercase is-mobile is-overflow-x-auto">
            <div class="level-left">
                <!-- <time class="level-item has-text-grey" datetime="2019-02-21T17:33:46.000Z">2019-02-22</time> -->
                <div class="level-item has-text-grey">2019-02-22</div>
                
                <div class="level-item">
                <a class="has-link-grey -link" href="/categories/Design-Pattern/">Design Pattern</a>&nbsp;/&nbsp;<a class="has-link-grey -link" href="/categories/Design-Pattern/Factory/">Factory</a>
                </div>
                
                
                
            </div>
        </div>
        
        <h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal">
            
                <a class="has-link-black-ter" href="/2019/02/22/factory-method-and-abstract-factory-pattern/">3. 팩토리 메소드, 추상 팩토리 패턴</a>
            
        </h1>
        <div class="content">
            <p>디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다.</p>
<ul>
<li><a href="https://aaronryu.github.io/2018/12/30/a-introduction-to-design-patterns/">1. 디자인 패턴에 앞서</a></li>
<li><a href="https://aaronryu.github.io/2019/02/21/two-principles-of-design-patterns/">2. 디자인 패턴의 제 1, 2 원칙</a></li>
</ul>
<p>설명에 사용할 코드는 Java-like Pseudo Code 입니다.</p>
<hr>
<h1 id="여러-상태에-따른-코드"><a href="#여러-상태에-따른-코드" class="headerlink" title="여러 상태에 따른 코드"></a>여러 상태에 따른 코드</h1><p>개발을 하다보면 어떤 <strong>상태에 따라 다른 플로</strong>를 작성해야할 상황이 발생합니다. 단순히 예/아니오 같은 <strong>단일 상태</strong>라면 if 문을 사용하도록 배웠고, <strong>다중 상태</strong>라면 if-else 혹은 switch 를 사용하도록 배웠습니다. 코드는 간단하게는 로직의 나열이라고 볼 수 있는데요. 우리의 실생활에서도 이처럼 다중 상태에 따라 다양한 작업을 수행하곤 합니다. 결국 모든 실생활도 if-else/switch 로 설명이 가능하다는 의미겠지요.</p>
<h2 id="if-else-에-“의존한”-처리"><a href="#if-else-에-“의존한”-처리" class="headerlink" title="if-else 에 “의존한” 처리"></a>if-else 에 “의존한” 처리</h2><ul>
<li><strong>라면 종류별 끓이기</strong><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RamemMaker</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        Water water = <span class="hljs-keyword">new</span> Water(<span class="hljs-number">100</span>);</span><br><span class="line">        Ramen ramen;</span><br><span class="line">        heat(water);</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) &#123;</span><br><span class="line">            ramen = 볶음라면;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"국물"</span>) &#123;</span><br><span class="line">            ramen = 국물라면;</span><br><span class="line">        &#125;</span><br><span class="line">        water.add(ramen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>라면 종류를 상태로 본다면 명시해준 라면 종류 String type 따라서 다른 라면을 끓입니다. 함수 makeRamen(String type) 은 아래와 같이 두 파트로 나눠볼 수 있습니다.</p>
<ol>
<li><strong>상태</strong>:<br> 1.1. <strong>라면 종류</strong>를 고르고 </li>
<li><strong>처리</strong>: 라면을 <strong>끓입니다.</strong> </li>
</ol>
<p>상태와 처리라는 두 책임이 하나의 코드에 모여있군요. 1.상태와 2.처리를 한번 떼어내볼까요.</p>
<h2 id="if-else-를-“분리한”-처리"><a href="#if-else-를-“분리한”-처리" class="headerlink" title="if-else 를 “분리한” 처리"></a>if-else 를 “분리한” 처리</h2><ul>
<li><p><strong>라면 끓이기</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RamemMaker</span> </span>&#123;</span><br><span class="line">    RamenGetter ramenGetter = <span class="hljs-keyword">new</span> RamenGetter();</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        Water water = <span class="hljs-keyword">new</span> Water(<span class="hljs-number">100</span>);</span><br><span class="line">        Ramen ramen = ramenGetter.getRamen(type);</span><br><span class="line">        heat(water);</span><br><span class="line">        water.add(ramen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>라면 종류별 생성</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RamenGetter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Ramen <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> 볶음라면;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"국물"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> 국물라면;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>라면 종류별 생성을 책임지는 <strong>상태 함수</strong>는 <strong>재사용성</strong>을 갖게되었고, <strong>상태</strong> 책임이 더 명확해 졌습니다. 여기서 함수 getRamen(String type)와 같이 <strong>상태에 따라 알맞은 클래스를 만들어서 주입해주는 함수</strong>를 <strong>팩토리</strong>라고 합니다.</p>
<blockquote>
<p><strong>팩토리</strong>는 if-else/switch <strong>상태</strong>에 따라 <strong>다른 클래스를 생성 및 주입해주는 함수</strong>를 의미합니다.</p>
</blockquote>
<p>일반적으로 팩토리 함수는 하나만으로 충분하기 때문에 정적 팩토리로 많이 사용됩니다. 다만 static 으로 정의된 함수는 상속을 통해 하위 클래스에서 해당 함수 사용 및 확장이 불가능하다는 단점만 유념하시면 됩니다.</p>
<h2 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if-else + if-else"></a>if-else + if-else</h2><p>팩토리는 단순히 한 상태에 따른 구현 클래스를 생성합니다. 라면은 <strong>라면 종류</strong>라는 한 상태뿐만 아니라 <strong>라면 업체</strong>라는 또 하나의 상태도 있습니다. 두 개의 상태가 생겼군요. 이를 <strong>이차원 상태</strong>로 보면 아래와 같이 if-else 문 안에 또 하나의 if-else 문을 갖는 구조로 볼 수 있습니다.</p>
<ul>
<li><strong>이차원 상태: 라면 업체 + 라면 종류</strong><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (company == <span class="hljs-string">"A 업체"</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> A_볶음라면;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"국물"</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> A_국물라면;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (company == <span class="hljs-string">"B 업체"</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> B_볶음라면;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"국물"</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">return</span> B_국물라면;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>같은 볶음라면이지만 제조를 어느 업체에서 했는지에 따라서도 나눌 수 있는것이죠. 일차원 상태분기는 비교적 쉬웠습니다. 이차원 상태를 고려하도록 확장하려면 아래와 같이 될텐데요.</p>
<ol>
<li><p><strong>상태</strong>:<br> 1.1. <strong>라면 종류</strong>를 고르고<br> 1.2. <strong>라면 업체</strong>를 고르고 </p>
</li>
<li><p><strong>처리</strong>: 라면을 <strong>끓입니다.</strong> </p>
</li>
</ol>
<p>이번에는 1.상태와 2.처리라는 두 책임뿐 아니라 <strong>두 상태인 1.1.과 1.2.</strong>도 나누어야겠군요.</p>
<ul>
<li><p><strong>라면 끓이기</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RamemMaker</span> </span>&#123;</span><br><span class="line">    RamenGetter ramenGetter = <span class="hljs-keyword">new</span> ACompanyRamenGetter();</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        Water water = <span class="hljs-keyword">new</span> Water(<span class="hljs-number">100</span>);</span><br><span class="line">        Ramen ramen = ramenGetter.getRamen(type);</span><br><span class="line">        heat(water);</span><br><span class="line">        water.add(ramen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>라면 종류별 생성</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RamenGetter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Ramen <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>A 업체의 라면 종류별 생성</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ACompanyRamenGetter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RamenGetter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Ramen <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> A_볶음라면;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> (type == <span class="hljs-string">"국물"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> A_국물라면;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>B 업체의 라면 종류별 생성</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BCompanyRamenGetter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RamenGetter</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Ramen <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> B_볶음라면;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> (type == <span class="hljs-string">"국물"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> B_국물라면;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>라면 종류가 함수 내 if-else 로 분기를 탔다면, 라면 업체는 클래스를 따로 만들어서 분기를 탔습니다. 전자를 <strong>팩토리 함수</strong> 후자를 <strong>팩토리 클래스</strong>로 볼 수 있겠네요. <strong>어떤 회사</strong>의 <strong>어떤 종류</strong>의 라면인지에 따라 그에 맞는 RamenGetter 팩토리 클래스를 선택하면 RamenMaker 는 RamenGetter 가 생성한 라면을 만들어줍니다. </p>
<blockquote>
<p><strong>상태</strong>와 <strong>처리</strong>뿐만 아니라 <strong>두 상태</strong>도 깔끔하게 책임이 분리되었습니다.</p>
</blockquote>
<p>지금까지 살펴본 코드에서는 어떤 라면인지 다양한 <strong>상태</strong>에 따라 RamenMaker 는 makeRamen 라는 <strong>동일한 처리</strong> 함수를 수행합니다. 하지만 잘 생각해보면 볶음라면과 국물라면은 끓이는 법은 동일할지라도 그 이후에 물을 버리느냐에 대한 차이가 있습니다. </p>
<blockquote>
<p>즉 <strong>어떤 상태(What)</strong>인지에 따라 <strong>어떻게 처리(How)</strong>할지가 바뀌어야할 경우가 존재합니다.</p>
</blockquote>
<h1 id="팩토리-메서드-패턴"><a href="#팩토리-메서드-패턴" class="headerlink" title="팩토리 메서드 패턴"></a>팩토리 메서드 패턴</h1><p>상태에 따라서 처리 함수를 바꿔주고 싶은데, RamemMaker 는 하나밖에 존재하지 않습니다. 그러면 RamemMaker 를 인터페이스로 만들어서 ACompanyRamemMaker, BCompanyRamemMaker 와 같이 원하는 상태(라면 회사)에 따라 다른 처리 함수를 수행할 수 있습니다. 심지어 이전 처리 함수를 활용해서말이죠.</p>
<ul>
<li><p><strong>라면 생성 + 라면 끓이기</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RamemMaker</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Ramem <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        Water water = <span class="hljs-keyword">new</span> Water(<span class="hljs-number">100</span>);</span><br><span class="line">        Ramen ramen = getRamen(type);</span><br><span class="line">        heat(water);</span><br><span class="line">        water.add(ramen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>A 업체의 라면 종류별 생성 + 라면 끓이기</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ACompanyRamenMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RamenMaker</span> </span>&#123;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Ramen <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> A_볶음라면;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> (type == <span class="hljs-string">"국물"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> A_국물라면;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.makeRamen(type);</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) &#123;</span><br><span class="line">            drainWaterForFrying();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>기존에는 라면 종류를 RamenGetter 팩토리 클래스를 통해 선택했지만 위 코드에서는 getRamen 추상함수에서 선택하도록 만들었습니다. <strong>상태 추상함수</strong>를 상속하여 오버라이드해서 원하는 <strong>상태 구현함수</strong>를 만들어 사용하는 것입니다.</p>
<blockquote>
<p><strong>팩토리 메서드 패턴</strong>은 팩토리가 생성하는 <strong>구현 클래스</strong>를 팩토리 클래스가 아닌 <strong>추상함수에 의존</strong>합니다</p>
</blockquote>
<ul>
<li><p><strong>팩토리 클래스</strong> - 팩토리는 클래스 RamenGetter 로 존재</p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RamenMaker</span> </span>&#123;</span><br><span class="line">    RamenGetter ramenGetter = <span class="hljs-keyword">new</span> ... ;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>&#123; ...</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>팩토리 메서드 패턴</strong> - 팩토리는 추상함수 getRamen 으로 존재 </p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RamenMaker</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Ramem <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>&#123; ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>왜 팩토리 클래스로도 충분한데 추상함수를 갖는 추상 클래스를 상속받아서 구현하도록 제안할까요?</p>
<blockquote>
<p>RamenMaker 에 <strong>상태 추상로직</strong>과 <strong>처리 구현로직</strong>을 넣어서<br>해당 클래스를 상속받으면 원하는 <strong>상태 구현로직</strong>을 만들 수 있을 뿐더러<br>덩달아 <strong>처리 구현로직</strong>도 <strong>“확장”</strong>할 수 있다는 큰 장점을 갖기 때문입니다. </p>
</blockquote>
<p>선택 추상로직을 클래스로 받았을때는 행위 구현로직에 대해 개입이 전혀 불가능했던것에 비하면 유연성이 매우 높아졌습니다.</p>
<h1 id="추상-팩토리-패턴"><a href="#추상-팩토리-패턴" class="headerlink" title="추상 팩토리 패턴"></a>추상 팩토리 패턴</h1><p>항상 팩토리를 검색하면 “팩토리 메서드 패턴”과 “추상 팩토리 패턴” 두 패턴이 나와 배울때 그 차이를 이해하는데 꽤나 힘들었습니다. 구분하자면 <strong>일차원 조건은 ‘팩토리’</strong>로 충분했으며, <strong>이차원 조건을 위해 ‘팩토리 메서드 패턴’</strong>을 사용했습니다. 다음 <strong>‘추상 팩토리 패턴’은 삼차원 조건을 처리하기위한 패턴</strong>이라고 이해하시면 쉽습니다. 라면업체와 라면종류 뿐만 아니라 라면에 들어가는 재료에 따라서 다른 라면이 생성된다고 가정합시다.</p>
<ol>
<li><p><strong>상태</strong>:<br> 1.1. <strong>라면 종류</strong>를 고르고<br> 1.2. <strong>라면 업체</strong>를 고르고<br> 1.3. <strong>라면 재료</strong>를 고르고</p>
</li>
<li><p><strong>처리</strong>: 라면을 <strong>끓입니다.</strong> </p>
</li>
</ol>
<p>쉬운 이해를 위해 아래와 같이 분류될 수 있습니다.</p>
<ul>
<li><strong>삼차원 상태: 라면 업체 + 라면 종류 + 재료</strong><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (company == <span class="hljs-string">"A 업체"</span>) &#123;</span><br><span class="line">    <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"치즈"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> A_치즈_볶음라면;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"불닭"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> A_불닭_볶음라면;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"국물"</span>) &#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"해물"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> A_해물_국물라면;</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"사골"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> A_사골_국물라면;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (company == <span class="hljs-string">"B 업체"</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>추가된 재료 상태를 지원하기 위해서는 단순히 재료를 생성해서 주입해주는 <strong>팩토리 클래스</strong> 단 한줄만 추가해주면 됩니다. 무언가 떠오르지 않으신가요? 가장 처음에 우리가 배웠던 <strong>팩토리 클래스</strong> 말입니다. 상태에 따른 라면 생성을 위해 팩토리 클래스를 적용하였다가 팩토리 메서드 패턴으로 바꾸었었는데요, 여기서는 그 팩토리 클래스를 다시 활용합니다. 단 이번엔 라면 생성 팩토리가 아닌 재료 생성 팩토리 클래스라는점이 다릅니다.</p>
<ul>
<li><p><strong>라면 끓이기</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RamemMaker</span> </span>&#123;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Ramem <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        Water water = <span class="hljs-keyword">new</span> Water(<span class="hljs-number">100</span>);</span><br><span class="line">        Ramen ramen = getRamen(type);</span><br><span class="line">        heat(water);</span><br><span class="line">        water.add(ramen);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>A 업체의 라면 종류별 끓이기</strong></p>
<figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ACompanyRamenMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RamenMaker</span> </span>&#123;</span><br><span class="line">    IngredientFactory ingredientFactory = <span class="hljs-keyword">new</span> HotIngredientFactory();</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Ramen <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> A_볶음라면(ingredientFactory);</span><br><span class="line">        &#125; <span class="hljs-keyword">else</span> (type == <span class="hljs-string">"국물"</span>) &#123;</span><br><span class="line">            <span class="hljs-keyword">return</span> A_국물라면(ingredientFactory);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="hljs-keyword">super</span>.makeRamen(type);</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) &#123;</span><br><span class="line">            drainWaterForFrying();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>이제 재료에 따라서 A 업체의 볶음라면은 다양한 바리에이션을 갖게 되었습니다. 위 예제에서는 HotIngredientFactory 매운재료를 사용했으니 A_불닭<em>볶음라면이 생성될테고 부드러운 맛을 좋아한다면 MildIngredientFactory 치즈와 같은 재료를 가미한 A</em>치즈_볶음라면을 생성할 수 있습니다.</p>
<p>라면을 만들었던 팩토리 클래스와 재료를 만드는 팩토리 클래스는 무엇을 만드는지가 다르다는것을 알 수 있습니다. 재료를 만드는 팩토리 클래스는 결국에 <strong>라면에 재료라는 상태 하나를 더 추가</strong>하여 한번 더 추상화한것입니다.</p>
<ul>
<li><strong>(구현) 팩토리 클래스</strong><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RamemMaker</span> </span>&#123;</span><br><span class="line">    RamenGetter ramenGetter = <span class="hljs-keyword">new</span> ACompanyRamenGetter();</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        Ramen ramen = ramenGetter.getRamen(type) <span class="hljs-comment">// A_불닭_볶음라면</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>구현 팩토리 클래스 = RamenGetter<br>라면 팩토리 클래스는 그 자체로 <strong>완전한(재료가 다 가미된) 라면(구현 클래스)</strong>을 반환합니다.</p>
</blockquote>
<ul>
<li><strong>추상 팩토리 클래스</strong><figure class="highlight java hljs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ACompanyRamenMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RamenMaker</span> </span>&#123;</span><br><span class="line">    IngredientFactory ingredientFactory = <span class="hljs-keyword">new</span> HotIngredientFactory();</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Ramen <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="hljs-keyword">return</span> A_볶음라면(ingredientFactory); <span class="hljs-comment">// Hot 이므로 A_불닭_볶음라면</span></span><br><span class="line">        ...</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>추상 팩토리 클래스 = IngredientFactory<br>재료 팩토리 클래스는 <strong>불완전한 라면(추상 클래스)에 가미할 재료</strong>들을 반환합니다.<br>즉, 불완전 라면에 재료를 가미하여 완제품 라면(구현 클래스)로 만들어주는 추상 팩토리 클래스입니다.</p>
</blockquote>
<p>두 클래스 RamenGetter, IngredientFactory 모두 내부에서 클래스를 생성해서 주입해주는 ‘팩토리’ 클래스 입니다. 다만 전자의 경우는 <strong>A_불닭_볶음라면이라는 구현 클래스</strong>를 주입해주고, 후자의 경우는 <strong>A_볶음라면이라는 추상 클래스에 들어가는 재료</strong>를 주입해줍니다. A_볶음라면이 A_불닭<em>볶음라면이 될지 A</em>치즈<em>볶음라면이 될지는 추상 팩토리 클래스 IngredientFactory 의 구현에 의존합니다. 위의 예를 보자면 HotIngredientFactory 라는 매운재료를 사용했으니까 A</em>불닭_볶음라면이라는 구현 클래스가 생성 &amp; 반환될 것입니다.</p>
<blockquote>
<p><strong>추상 팩토리 패턴</strong>은 추상 팩토리 클래스를 통해 팩토리가 생성하는 구현 클래스를 동적으로 변경할 수 있습니다.</p>
</blockquote>
<p>이번 챕터에서는 팩토리 - 일차원, 팩토리 메서드 패턴 - 이차원, 추상 팩토리 패턴 - 삼차원을 익혔습니다. 앞으로는 “팩토리 메서드 패턴”, “추상 팩토리 패턴”을 구분 못할일은 없을것입니다. 더불어 누군가가 팩토리 패턴이라고 말한다면 그건 패턴이 아니라 클래스나 함수를 명명하는것이라고 귀띔해줄 수도 있게 되었습니다.</p>
<p>상태가 삼차원도 아니라 4차원, 5차원이라면 어떻게 다루면 될까요? 이 또한 재료뿐만 아니라 육수나 냄비와 같이 모두 추상 팩토리 패턴으로 추상화하면 됩니다. 하지만 상태가 그렇게 복잡해진다면 불필요하게 상태가 많아진것은 아닌지, 조건들을 단순화할 수 있는지 다시 한번 동료 프로그래머와 함께 검토해보시기 바랍니다.</p>
<hr>
<p><strong>팩토리 클래스</strong></p>
<blockquote>
<p><strong>상태</strong>에 따라 그에 맞는 <strong>구현 클래스</strong>를 생성합니다.</p>
</blockquote>
<p><strong>팩토리 메서드 패턴</strong></p>
<blockquote>
<p>추상 클래스의 <strong>상태 추상함수</strong>를 통해 <strong>구현 클래스</strong>를 생성합니다.</p>
</blockquote>
<p><strong>상태 추상함수</strong>가 구현 클래스를 생성한다는 의미로 <strong>팩토리 메서드</strong>라고 합니다.<br>추상 클래스를 상속하여 <strong>상태 추상함수</strong> 오버라이드를 통해 <strong>상태 구현함수</strong>를 구현합니다.<br>추상 클래스의 <strong>처리 구현함수</strong> 또한 오버라이드를 통해 확장할 수 있는 장점이 있습니다.</p>
<p><strong>추상 팩토리 패턴</strong></p>
<blockquote>
<p>추상 팩토리 클래스를 통해 <strong>추상 클래스(불완전 라면)</strong>를 <strong>특정 구현 클래스(완전 라면)</strong>로 결정할 <strong>구현 클래스(재료)</strong>를 생성합니다. </p>
</blockquote>
<p><strong>추상 클래스(불완전 라면)</strong>가 <strong>어떤 구현 클래스(완전 라면)</strong>가 될지는 추상 팩토리 클래스를 상속받은 <strong>구현 팩토리 클래스(재료 팩토리)를 구성(composition)</strong>함으로써 동적으로 결정됩니다.</p>

        </div>
        
        
        
    </div>
</div>











    
<div class="card card-transparent">
    <nav class="pagination is-centered" role="navigation" aria-label="pagination">
        <div class="pagination-previous is-invisible is-hidden-mobile">
            <a class="is-flex-grow has-text-black-ter" href="/page/0/">Previous</a>
        </div>
        <div class="pagination-next">
            <a class="is-flex-grow has-text-black-ter" href="/page/2/">Next</a>
        </div>
        <ul class="pagination-list is-hidden-mobile">
            
            <li><a class="pagination-link is-current" href="/">1</a></li>
            
            <li><a class="pagination-link has-text-black-ter" href="/page/2/">2</a></li>
            
        </ul>
    </nav>
</div>
</div>
                
                    




<div class="column is-3-tablet is-3-desktop is-3-widescreen  has-order-1 column-left is-sticky">
    
        
    
        
<div class="card widget">
    <div class="card-content">
        <div class="menu">
            <h3 class="menu-label">
                Categories
            </h3>
            <ul class="menu-list">
            <li>
        <a class="level is-marginless" href="/categories/Design-Pattern/">
            <span class="level-start">
                <span class="level-item">Design Pattern</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">6</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/Design-Pattern/Adapter-Decorator/">
            <span class="level-start">
                <span class="level-item">Adapter, Decorator</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Design-Pattern/Factory/">
            <span class="level-start">
                <span class="level-item">Factory</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Design-Pattern/Observer/">
            <span class="level-start">
                <span class="level-item">Observer</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Design-Pattern/Singleton/">
            <span class="level-start">
                <span class="level-item">Singleton</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/Language/">
            <span class="level-start">
                <span class="level-item">Language</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/Language/Functional-Programming/">
            <span class="level-start">
                <span class="level-item">Functional Programming</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Language/Kotlin/">
            <span class="level-start">
                <span class="level-item">Kotlin</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Language/Swift-4-iOS/">
            <span class="level-start">
                <span class="level-item">Swift 4+ / iOS</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/Programming/">
            <span class="level-start">
                <span class="level-item">Programming</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">3</span>
            </span>
        </a><ul><li>
        <a class="level is-marginless" href="/categories/Programming/Develop/">
            <span class="level-start">
                <span class="level-item">Develop</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li><li>
        <a class="level is-marginless" href="/categories/Programming/Licenses/">
            <span class="level-start">
                <span class="level-item">Licenses</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">2</span>
            </span>
        </a></li></ul></li><li>
        <a class="level is-marginless" href="/categories/Workplace/">
            <span class="level-start">
                <span class="level-item">Workplace</span>
            </span>
            <span class="level-end">
                <span class="level-item tag">1</span>
            </span>
        </a></li>
            </ul>
        </div>
    </div>
</div>
    
        
<div class="card widget">
    <div class="card-content">
        <nav class="level">
            <div class="level-item has-text-centered">
                <div>
                    
                        <img class="image is-128x128 has-mb-6" src="/images/avatar.png" alt="Aaron Ryu">
                    
                    
                    <p class="is-size-4 is-block">
                        Aaron Ryu
                    </p>
                    
                    
                    <p class="is-size-6 is-block">
                        Software Developer
                    </p>
                    
                    
                </div>
            </div>
        </nav>
        
        
        <div class="level is-mobile">
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Github" href="https://github.com/aaronryu">
                
                <i class="fab fa-github"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="Gitlab" href="https://gitlab.com/aaronryu">
                
                <i class="fab fa-gitlab"></i>
                
            </a>
            
            <a class="level-item button is-white is-marginless" target="_blank" title="RSS" href="/atom.xml">
                
                <i class="fas fa-rss"></i>
                
            </a>
            
        </div>
        
        <nav class="level is-mobile">
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Posts
                    </p>
                    <p class="title has-text-weight-normal">
                        13
                    </p>
                </div>
            </div>
            <div class="level-item has-text-centered is-marginless">
                <div>
                    <p class="heading">
                        Categories
                    </p>
                    <p class="title has-text-weight-normal">
                        13
                    </p>
                </div>
            </div>
        </nav>
        
    </div>
</div>
    
        
<div class="card widget">
    <div class="card-content">
        <h3 class="menu-label">
            Recent
        </h3>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-12-14T17:32:23.000Z">2019-12-15</time></div>
                    <a href="/2019/12/15/one-page-for-regular-expression/" class="has-link-black-ter is-size-6">한 장으로 보는 정규표현식</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Programming/">Programming</a> / <a class="has-link-grey -link" href="/categories/Programming/Licenses/">Licenses</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-08-10T06:31:23.000Z">2019-08-10</time></div>
                    <a href="/2019/08/10/software-licences/" class="has-link-black-ter is-size-6">오픈 소스(공개 소프트웨어)의 다양한 라이센스들</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Programming/">Programming</a> / <a class="has-link-grey -link" href="/categories/Programming/Licenses/">Licenses</a>
                    </p>
                </div>
            </div>
        </article>
        
        <article class="media">
            
            <div class="media-content">
                <div class="content">
                    <div><time class="has-text-grey is-size-7 is-uppercase" datetime="2019-06-29T05:20:40.000Z">2019-06-29</time></div>
                    <a href="/2019/06/29/ios-design-patterns/" class="has-link-black-ter is-size-6">개발 일지 - iOS 아키텍쳐 패턴 MVC, MVVM, VIPER</a>
                    <p class="is-size-7 is-uppercase">
                        <a class="has-link-grey -link" href="/categories/Programming/">Programming</a> / <a class="has-link-grey -link" href="/categories/Programming/Develop/">Develop</a>
                    </p>
                </div>
            </div>
        </article>
        
    </div>
</div>

    
        


    
    
        <div class="column-right-shadow is-hidden-widescreen ">
        
        </div>
    
</div>

                    
                
            </div>
        </div>
    </section>
    <footer class="footer">
    <div class="container">
        <div class="level">
            <div class="level-start has-text-centered-mobile">
                <a class="footer-logo is-block has-mb-6" href="/">
                
                    Crucian Carp
                
                </a>
                <p class="is-size-7">
                &copy; 2019 Aaron Ryu&nbsp;
                Powered by <a href="http://hexo.io/" target="_blank">Hexo</a> & <a href="http://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>
                
                </p>
            </div>
            <div class="level-end">
            
            </div>
        </div>
    </div>
</footer>
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script>
<script>moment.locale("en");</script>


    
    
    
    <script src="/js/animation.js"></script>
    

    
    
    
    <script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script>
    <script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script>
    <script src="/js/gallery.js" defer></script>
    

    
    

<div id="outdated">
    <h6>Your browser is out-of-date!</h6>
    <p>Update your browser to view this website correctly. <a id="btnUpdateBrowser" href="http://outdatedbrowser.com/">Update
            my browser now </a></p>
    <p class="last"><a href="#" id="btnCloseUpdateBrowser" title="Close">&times;</a></p>
</div>
<script src="https://cdn.jsdelivr.net/npm/outdatedbrowser@1.1.5/outdatedbrowser/outdatedbrowser.min.js" defer></script>
<script>
    document.addEventListener("DOMContentLoaded", function () {
        outdatedBrowser({
            bgColor: '#f25648',
            color: '#ffffff',
            lowerThan: 'flex'
        });
    });
</script>


    
    
<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script>
<script>
document.addEventListener('DOMContentLoaded', function () {
    MathJax.Hub.Config({
        'HTML-CSS': {
            matchFontHeight: false
        },
        SVG: {
            matchFontHeight: false
        },
        CommonHTML: {
            matchFontHeight: false
        },
        tex2jax: {
            inlineMath: [
                ['$','$'],
                ['\\(','\\)']
            ]
        }
    });
});
</script>

    
    

<a id="back-to-top" title="Back to Top" href="javascript:;">
    <i class="fas fa-chevron-up"></i>
</a>
<script src="/js/back-to-top.js" defer></script>


    
    

    
    
    
    

    
    
    
    
    
    <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script>
    <script src="/js/clipboard.js" defer></script>
    

    
    
    


<script src="/js/main.js" defer></script>

    
    <div class="searchbox ins-search">
    <div class="searchbox-container ins-search-container">
        <div class="searchbox-input-wrapper">
            <input type="text" class="searchbox-input ins-search-input" placeholder="Type something...">
            <span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="searchbox-result-wrapper ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
    (function (window) {
        var INSIGHT_CONFIG = {
            TRANSLATION: {
                POSTS: 'Posts',
                PAGES: 'Pages',
                CATEGORIES: 'Categories',
                TAGS: 'Tags',
                UNTITLED: '(Untitled)',
            },
            CONTENT_URL: '/content.json',
        };
        window.INSIGHT_CONFIG = INSIGHT_CONFIG;
    })(window);
</script>
<script src="/js/insight.js" defer></script>
<link rel="stylesheet" href="/css/search.css">
<link rel="stylesheet" href="/css/insight.css">
    
</body>
</html>