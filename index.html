<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Crucian Carp</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crucian Carp"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crucian Carp"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Cool heads but warm hearts"><meta property="og:type" content="blog"><meta property="og:title" content="Crucian Carp"><meta property="og:url" content="https://aaronryu.github.io/"><meta property="og:site_name" content="Crucian Carp"><meta property="og:description" content="Cool heads but warm hearts"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://aaronryu.github.io/img/og_image.png"><meta property="article:author" content="Aaron Ryu"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://aaronryu.github.io"},"headline":"Crucian Carp","image":["https://aaronryu.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Aaron Ryu"},"description":"Cool heads but warm hearts"}</script><link rel="alternate" href="/atom.xml" title="Crucian Carp" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/androidstudio.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-134840627-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-134840627-1');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Crucian Carp</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2021-03-14</div></span><span class="level-item"><a class="link-muted" href="/categories/Troubleshooting/">Troubleshooting</a><span> / </span><a class="link-muted" href="/categories/Troubleshooting/Java-8/">Java 8</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/14/thread-and-security-context-holder-mode/">Spring Security: SecurityContextHolder 의 Thread 공유 전략</a></h1><div class="content"><p>다수 정보를 리스트로 조회하는 페이지에서 <strong>현재 로그인한 유저가 가진 권한에 따라 일부 정보를 보여주지 않도록하는 처리가 필요</strong>했습니다. 그래서 먼저 리스트를 API 로부터 가져온 뒤, 현재 Spring Security 로그인 세션에 저장되어있는 권한을 통해 일부 정보를 필터링하여 최종적으로 조회 페이지에 렌더링하도록 작업하였었습니다.</p>
<p>하지만 이상하게 리스트에 노출되는 Row 가 총 10개라면 2 ~ 3개 <strong>약 1/4 에 해당하는 Row 만 해당 ‘세션 권한 필터링’ 로직이 적용</strong>되었고 <strong>나머지 3/4 에 대해서는 적용되지 않는 버그</strong>를 발견하였습니다. 심지어 1/4 에 해당하는 2 ~ 3개는 변칙적으로 계속 변경되는것이었습니다. 예를 들면 새로고침 한번에 2번째 3번째 Row 에만 ‘세션 권한 필터링’ 이 적용되었다가, 새로고침을 한번 더 하면 5번째 6번째 Row 에 ‘세션 권한 필터링’이 적용되는것입니다. 마치 슈뢰딩거의 고양이처럼요…</p>
<p>구현은 다음과 같았습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;SomeInformation&gt; list = someApi.retreive(condition);</span><br><span class="line">list.parallelStream()</span><br><span class="line">    .forEach(each -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!SecurityHelper.hasRole(<span class="string">&quot;ROLE_CAN_SEE_SENSITIVE_NUMBERS&quot;</span>)) &#123;</span><br><span class="line">            each.setSensitiveNumber1(<span class="keyword">null</span>);</span><br><span class="line">            each.setSensitiveNumber2(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityHelper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasRole</span><span class="params">(String role)</span> </span>&#123;</span><br><span class="line">        SecurityContext context = SecurityContextHolder.getContext();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(context))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Authentication authentication = context.getAuthentication();</span><br><span class="line">        <span class="keyword">if</span> (Objects.isNull(auth))) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (GrantAuthority eachAuthority : authentication.getAuthorities()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (role.equals(eachAuthority.getAuthority())) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>실제로는 <strong>테스트했던 로그인 계정에 <code>ROLE_CAN_SEE_SENSITIVE_NUMBERS</code> 권한이 있었기 때문에, 리스트의 모든 Row 들에 sensitiveNumber1, 2 모두 정상 노출되는것이 맞습니다.</strong> 하지만 1/4만 노출되는건 아무리 생각해도 이상하여 <strong>parallelStream.forEach 내부에 로그를 추가</strong>하였더니 아래와 같은 결과가 나왔습니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">INFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-3] [TEST] hasRole: <span class="literal">false</span></span><br><span class="line">INFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-2] [TEST] hasRole: <span class="literal">false</span></span><br><span class="line">INFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-7] [TEST] hasRole: <span class="literal">false</span></span><br><span class="line">INFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-1] [TEST] hasRole: <span class="literal">false</span></span><br><span class="line">INFO 2021-01-01 00:00:01 [http-nio-80-exec-3] [TEST] hasRole: <span class="literal">true</span></span><br><span class="line">INFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-4] [TEST] hasRole: <span class="literal">false</span></span><br><span class="line">INFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-5] [TEST] hasRole: <span class="literal">false</span></span><br><span class="line">INFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-6] [TEST] hasRole: <span class="literal">false</span></span><br><span class="line">INFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-2] [TEST] hasRole: <span class="literal">false</span></span><br><span class="line">INFO 2021-01-01 00:00:01 [http-nio-80-exec-3] [TEST] hasRole: <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>보아하니 ForkJoinPool 즉, ParallelStream 실행을 위해 할당된 <strong>하위 Thread</strong>(<strong><code>ForkJoinPool.commonPool-worker-1~7</code></strong>) 에서는 <strong>hasRole</strong>이 비정상적으로 <strong>false</strong>값을 반환하고, <strong>메인 Thread</strong>(<strong><code>http-nio-80-exec-3</code></strong>) 에서는 <strong>hasRole</strong>이 정상적으로 <strong>true</strong>값을 반환하는걸 알 수 있습니다.</p>
<p><strong>무언가 ParallelStream 과 SecurityContextHolder 혼용이 문제인것으로 보입니다.</strong></p>
<hr>
<h1 id="SecurityContextHolder-의-Thread-간-공유-모드"><a href="#SecurityContextHolder-의-Thread-간-공유-모드" class="headerlink" title="SecurityContextHolder 의 Thread 간 공유 모드"></a>SecurityContextHolder 의 Thread 간 공유 모드</h1><p>ParallelStream 의 Thread 에서 <strong>hasRole = false</strong> 가 반환됐던 1차 원인은 <code>SecurityContext context = SecurityContextHolder.getContext();</code> 호출시 <strong>null</strong>이 반환되고 있었습니다. 반면 메인 Thread 에서 <code>SecurityContextHolder.getContext()</code> 호출시에는 정상적으로 세션 데이터를 가져올 수 있었고, hasRole 에 알맞은 비교 로직까지 수행할 수 있었습니다. 알아보니 아래와 같은 사실을 발견했습니다.</p>
<blockquote>
<p><strong>SecurityContextHolder</strong>는 <strong>SecurityContext 로그인 세션 정보를 어떤 레벨의 Thread 까지 공유할지 모드</strong>를 지정하도록 되어있습니다. 기본값으로는 <strong>MODE_THREADLOCAL</strong>로써 <strong>SecurityContext 정보는 “메인 Thread” 에서만 볼 수 있습니다.</strong></p>
</blockquote>
<blockquote>
<p>총 공유 모드는 3가지로 나뉘어져있습니다.</p>
<ol>
<li><strong>MODE_THREADLOCAL</strong>: (Default) <strong>Local Thread 에서만 공유 가능</strong></li>
<li><strong>MODE_INHERITABLETHREADLOCAL</strong>: Local Thread 에서 생성한 <strong>하위 Thread 에까지 공유 가능</strong></li>
<li><strong>MODE_GLOCAL</strong>: <strong>모든 Thread, 어플리케이션 전체에서 공유 가능</strong></li>
</ol>
</blockquote>
<p><strong>기본 모드</strong>는 <strong>MODE_THREADLOCAL</strong> 였기에, 아무런 설정도 하지 않았던 서버에서는 <strong>메인 Thread</strong>(<strong><code>http-nio-80-exec-3</code></strong>)에서만 SecurityContext 가 반환되었던고, 나머지 <strong>하위 Thread</strong>(<strong><code>ForkJoinPool.commonPool-worker-1~7</code></strong>)에서는 null 이 반환되었던것입니다.</p>
<h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><p>SecurityContextHolder 의 기본 설정은 SecurityContext 정보를 Local Thread 만 공유하도록 되어있기 때문에 SecurityContextHolder 를 직접 하위 Thread 안에서 호출하여 사용하는것보다, <strong>메인 Thread 에서 호출하여 해당 값을 하위 Thread 에서 참조하도록 하는것이, 성능적으로나 가시적으로도 더 깔끔한 코드가 될것입니다.</strong> <strong>ParallelStream 혹은 Async 관련된 기능을 사용 시</strong> 하위 Thread 에서 SecurityContextHolder 를 사용해야하는 경우가 있다면 <strong>SecurityContextHolder 의 공유 모드를 MODE_INHERITABLETHREADLOCAL 로 낮추는것을 고려해야합니다.</strong></p>
<hr>
<p>출처:</p>
<ol>
<li>Spring Security - SecurityContextHolder Strategy:<br><a target="_blank" rel="noopener" href="http://ncucu.me/116">http://ncucu.me/116</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2021-03-14</div></span><span class="level-item"><a class="link-muted" href="/categories/Troubleshooting/">Troubleshooting</a><span> / </span><a class="link-muted" href="/categories/Troubleshooting/Java-8/">Java 8</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/03/14/unboxing-when-use-equal-operator-on-wrapper-class/">Wrapper Class Caching: Integer(Wrapper Class) == 사용시 이슈</a></h1><div class="content"><p>얼마전부터 서버에서 Integer 객체를 == (항등 연산자)를 사용한 코드때문에 간간히 에러 로그가 남는것을 확인했습니다. 신기한건 해당 API 가 매우 자주사용되는데, 간헐적으로 발생한다는 것이었습니다. 간단하게 설명하면 업데이트하려는 리스트 개수와, 업데이트 이전 리스트 개수가 맞는지 검사하는 Validation 로직이었는데, 에러 로그를 확인해보면 <code>업데이트 전 리스트 개수와 업데이트 후 리스트 개수가 324 != 324 로 다릅니다.</code>라고 찍혀있는 것이었습니다. 단순히 팀원들과 **객체 비교는 == 를 사용하면 Reference 메모리 주소값을 비교하기 때문에 당연히 equals 를 사용해야합니다.**라고 공유했지만, 실제로 해당 로직이 이상해서 값을 하나씩 1씩 증가시키며 대입해본 끈기있는 개발자분에 의해 다음과 같은 사실이 밝혀졌습니다.</p>
<blockquote>
<p><strong>Integer 객체 비교는 == 를 사용했을때 127 까지는 ‘true(같음)’을 반환하는데, 그 이상 128 부터는 ‘false(다름)’으로 반환합니다.</strong></p>
</blockquote>
<p>본 글은 왜 그런지에 대한 이유에 대한 짧은 글입니다.</p>
<hr>
<p>Java 뿐만 아니라 Javascript 를 처음배운다면 Class 를 접하실테고, Primitive Type, Reference Type 을 배우실겁니다. 컴퓨터공학/과학과에서 요즘엔 Python 을 배우지않을까 싶은데 C 를 배우게 된다면 <strong>변수에 값을 저장하면 메모리에 어떻게 적재되는지</strong> 배우게 됩니다. 간단하게 아래와 같이 나뉩니다.</p>
<h1 id="Primitive-Type"><a href="#Primitive-Type" class="headerlink" title="Primitive Type"></a>Primitive Type</h1><ul>
<li>변수에 값을 할당하면 그 값 그대로 메모리에 저장</li>
<li><strong>값이 그 값 자체로 사용가능한 타입</strong><ul>
<li><strong>정수형:</strong> byte, short, int, long</li>
<li><strong>실수형:</strong> float, double</li>
<li><strong>문자형:</strong> char</li>
<li><strong>논리형:</strong> boolean</li>
</ul>
</li>
</ul>
<h1 id="Reference-Type"><a href="#Reference-Type" class="headerlink" title="Reference Type"></a>Reference Type</h1><ul>
<li>변수에 값을 가진 객체의 주소를 저장하고, 그 값은 주소가 가리키는 객체 공간에 저장되어있습니다.</li>
<li><strong>값(field)과 유용한 함수(method)들을 하나의 객체로 담은 타입</strong><ul>
<li><strong>Wrapper Class</strong>: 그 중 Primitive Type 값과 유용한 함수들을 하나의 객체로 담은 타입 <ul>
<li><strong>정수형:</strong> Byte, Short, Int, Long</li>
<li><strong>실수형:</strong> Float, Double</li>
<li><strong>문자형:</strong> Character</li>
<li><strong>논리형:</strong> Boolean</li>
</ul>
</li>
<li><strong>그 외</strong>: Array, Class 등</li>
</ul>
</li>
</ul>
<p>본 글에서는 <strong>Primitive Type</strong> 과 <strong>그 값들을 감싼 Wrapper Class</strong>, 이 둘만을 다룹니다.</p>
<hr>
<h1 id="Boxing-amp-Unboxing"><a href="#Boxing-amp-Unboxing" class="headerlink" title="Boxing &amp; Unboxing"></a>Boxing &amp; Unboxing</h1><p>이 두 타입이 Java 에서 혼용할 수 있기 때문에, Primitive Type 과 Wrapper Class 에 저장된 값을 사용하기 위해서 매번 연산자나 함수에서 사용하는 타입에 맞춰서 변환해줄 순 없습니다. 불필요한 코드의 양이 늘어나기에 이는 Java Compiler 가 바이트코드 생성 시 자동변환을 해주게 됩니다. 어떤 타입에서 어떤 타입으로 변환하는지에 따라 boxing, unboxing 으로 나뉘는데 Class 에서 값을 꺼낸다 = unboxing, Class 에 값을 담는다 = boxing 으로 직관적으로 이해 가능합니다.</p>
<h2 id="Boxing"><a href="#Boxing" class="headerlink" title="Boxing"></a>Boxing</h2><p>Primitive Type 값을 Wrapper Class 객체 내부에 감싸(box) 저장하여 Wrapper Class 주소를 반환합니다. <code>Integer a = 10;</code> 이런식으로 선언하면 좌측은 <strong>Integer</strong>(<strong>Wrapper Class</strong>) 우측은 <strong>10</strong>(<strong>Primitive Type</strong>)이기에 우측의 10 값을 new Integer(10) 의 형태로 객체로 자동으로 감싸 반환하게 됩니다. 이를 <strong>Auto-boxing</strong> 이라고 부릅니다. 이 덕분에 함수 파라미터가 다음과 같더라도 <code>private void pleaseGiveMeReference(Integer a)</code> 함수 호출시에 <code>pleaseGiveMeReference(10)</code>으로 호출 할 수 있는것입니다.</p>
<h2 id="Unboxing"><a href="#Unboxing" class="headerlink" title="Unboxing"></a>Unboxing</h2><p>Primitive Type 값을 가진 Wrapper Class 객체를 <code>int a;</code>, <code>Integer b = new Integer(10)</code> 과 같은곳에 사용하려면 Primitive Type 으로 값을 꺼내어(unbox) <code>int a = b</code> 의 결과는 <code>int a = 10</code> 이 됩니다. 이를 <strong>Auto-unboxing</strong> 이라고 부릅니다. 이 또한 위에 <strong>Boxing</strong> 에서 살펴봤듯이, 이 덕분에 함수 파라미터가 다음과 같더라도 <code>private void pleaseGiveMePrimitive(int a)</code> 함수 호출시에 <code>Integer wrapped = 10</code> 객체를 다음 함수에 <code>pleaseGiveMePrimitive(wrapped)</code> 이렇게 호출 할 수 있는것입니다.</p>
<hr>
<p>글의 맨 처음에 문제가 되었던 <code>==</code> 은 실제 값의 비교이기에 Primitive Type 비교할때만 우리의 직관대로 동작합니다 Wrapper Class 을 비교한다면 <code>Integer a</code> 변수에 저장된 <code>객체에 대한 메모리 주소</code>만을 비교하기에 아무리 같은 값을 갖고있는 두 객체를 비교하더라도 결과값은 ‘false(불일치)’일것입니다. 명심해야할 것은 <strong><code>==</code> 연산자는 “절대로” Auto-boxing, Auto-unboxing 을 지원하지 않습니다.</strong> 심지어 Integer 처럼 Auto-boxing, Auto-unboxing 를 지원하더라도 말입니다.</p>
<p>그렇다면 왜 서버에서 <code>Integer == Integer</code> 는 127 까지는 제대로 동작하고 128 부터는 우리가 생각하는대로 동작하지 않는것일까요? <strong><code>==</code> 연산자는 Auto-unboxing 이 안된다면서요. 설마 조건에 따라 되는걸까요?</strong></p>
<p><strong>아닙니다.</strong></p>
<hr>
<h1 id="Wrapper-Class-Caching-Java-5"><a href="#Wrapper-Class-Caching-Java-5" class="headerlink" title="Wrapper Class Caching (Java 5+)"></a>Wrapper Class Caching (Java 5+)</h1><p>Java 5 에서는 메모리 효율을 위해 <strong>Wrapper Class Caching</strong> 을 도입했습니다. <strong>“일부” Wrapper Class</strong>(Byte, Short, Integer, Long, Character) 에 대해서 작은 값에 대해서 메모리에 캐싱하여, 작은 값에 대한 객체를 생성하면 캐싱해놓은 Wrapper Class 객체를 반환해주는 것입니다. Integer 의 예로 1, 2, 10 같은 값들은 사용 빈도수가 굉장히 크기때문에 일일히 이에 대한 Wrapper Class 객체를 생성해주면 메모리 입장에서 <code>Integer a = 10;</code>, <code>Integer b = 10;</code> … <strong>100개를 정의한다면 100개에 대한 메모리를 다 할당</strong>해놓아야하는것입니다. 이에 따라 <strong>빈도수가 큰 객체는 미리 만들어두고 10 값에 대한 Wrapper Class 객체는 미리 만들어놓은 단 하나의 객체만을 사용하도록</strong> 하는것입니다. <code>Integer a = 10;</code>, <code>Integer b = 10;</code> … 모두 캐싱된 <code>new Integer(10)</code> 객체를 사용하기때문에 <code>Integer a</code>, <code>Integer b</code> <strong>모두 같은 객체 주소값</strong>을 가지며, <strong>메모리는 단 1개에 대해서만 할당</strong>하면 됩니다.</p>
<p>한 객체로 여러 변수들에 사용가능하도록 했기때문에 이를 <strong>Immutable Wrapper Object</strong> 라고도 부르는듯 합니다. <strong>Wrapper Class Caching</strong> 이란것이 <strong>“일부” Wrapper Class</strong> 에만 적용된다고 강조했던 이유는 Float 는 캐싱하지 않고, Character 는 음수값을 제외한 0 ~ 127 만 캐싱하는 등 타입별 지원되는 캐싱 스펙이 다르기 때문입니다. 상제한 스펙은 자바 공식 스펙 문서를 참조하시기 바랍니다.<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/#5.1.7">^1</a> 아무래도 적은 수에 대해서만 캐싱한것은 빈도수가 적은수에 대해서만 집중함일것이고, 2^8(256)을 넘는다면 bit 개수에 따라 캐싱 메모리도 늘어나므로 어느 정도 합의점을 본것으로 느껴집니다.</p>
<blockquote>
<p><strong>Wrapper Class 중 빈도수가 높은 작은 값들에 대한 객체들을 미리 선언해놓고, 코드상에서 해당 값으로 Wrapper Class 객체를 생성하려하면 이미 저장된 객체를 반환합니다.</strong></p>
</blockquote>
<blockquote>
<p><strong>Integer 에 대한 Wrapper Class Caching 은 -128 ~ 127 값에 대한 객체를 캐싱</strong>해놓습니다.</p>
</blockquote>
<hr>
<h1 id="결론"><a href="#결론" class="headerlink" title="결론"></a>결론</h1><blockquote>
<p><strong>Wrapper Class 의 동일 여부는 equals() 를 사용합시다.</strong></p>
</blockquote>
<p>그렇다면 이제 <code>Integer == Integer</code> 가 어떨때 동작하였고, 어떨때 동작하지 않는지 이유가 명확해졌습니다. Integer 는 <strong>-128 ~ 127</strong> 까지의 값에 대한 객체는 Java 의 <strong>Wrapper Class Caching</strong>에 의해 매번 정의할때마다 메모리에 생성하지 않고, 미리 캐싱되어있는 객체를 사용하게 됩니다. 그리하여 <code>Integer a = 10</code>, <code>Integer b = 10</code> <strong>모두 같은 객체 주소값</strong>을 가지기때문에 <code>a == b</code> 는 <strong><code>10 == 10</code> 값이 같다는 이유가 아닌 <code>9ab2e1 == 9ab2e1</code> 주소가 같다는 이유로 ‘true(같음)’을 반환</strong>하는것이었습니다.</p>
<p>에러 발생 빈도수가 적었던것도 해당 로직 특성상 127 이상의 값이 나올일이 없었던것일테고, 테스트시 발견 못한것은 테스트 값을 상식적인 값 범주만 했을뿐 Integer 최대, 최소 경계값에 대한 테스트케이스는 놓쳤기 때문이라 생각합니다. 다시 한번 <strong>값 비교는 equals 를 사용</strong>해야한다는 것과, <strong>항상 경계값에 대한 테스트케이스는 필수</strong>다라는 당연한 사실을 다시 깨닫고 갑니다.</p>
<hr>
<p>Java 는 예나 지금이나 참 어려운 언어인것같습니다. 이런걸 접하다보면 예전에 1년간 맛보았던 Kotlin 으로 다시 돌아가고 싶은 마음이 듭니다(…). 그래도 이런 작은 부분들까지 메모해놓고 알아둔다면 앞으로의 지식에 큰 도움이 언젠간 되겠죠. JVM, Java Compiler 에서는 개발자 편의를 위해 지원해주는 기능이 몇가지가 있는데, 이번 캐싱 이슈뿐만 아니라 Java Generic 개념에서도 메모리 효율을 위해 컴파일 시 개발자가 개발한 <strong>Interface 구현체를 모두 Interface 로 자동 변환하여, 컴파일 타임에서 걸러지지 못한 에러가 런타임에서 에러로 발생</strong>하는 이슈도 있습니다. 이는 추후 포스팅으로 설명하도록 하겠습니다.</p>
<hr>
<p>출처:</p>
<ol>
<li>Immutable Objects / Wrapper Class Caching:<br><a target="_blank" rel="noopener" href="https://wiki.owasp.org/index.php/Java_gotchas#Immutable_Objects_.2F_Wrapper_Class_Caching">https://wiki.owasp.org/index.php/Java_gotchas#Immutable_Objects_.2F_Wrapper_Class_Caching</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2021-02-14</div></span><span class="level-item"><a class="link-muted" href="/categories/Framework/">Framework</a><span> / </span><a class="link-muted" href="/categories/Framework/Spring/">Spring</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/14/a-tutorial-for-spring-mvc-and-security/">Spring MVC, Security 동작 원리와 처리 흐름</a></h1><div class="content"><h1 id="Web-Server-static-페이지"><a href="#Web-Server-static-페이지" class="headerlink" title="Web Server (static 페이지)"></a>Web Server (<strong>static 페이지</strong>)</h1><p>웹 초기에는 서버에 정적인 문서(html)를 저장해서 유저가 요청하면 해당 파일을 유저의 브라우저에서 다운받아 보여주는 방식이었습니다. 예를 들면 특정 서버 <code>aaron.com</code> 에 있는 <code>hello.html</code> 문서를 보고싶다면 브라우저에 <code>aaron.com/hello.html</code> 을 호출하면 되는것입니다. 아주 예전에 대학교에서 교수가 자신의 연구실 서버를 이용해서 강의자료를 배포할때 아래와 같은 페이지에 들어가서 다운받았던 기억이 납니다.</p>
<blockquote>
<p><strong>서버에 있는 페이지</strong>를 유저들에게 보여줍니다.</p>
</blockquote>
<center><img src="/2021/02/14/a-tutorial-for-spring-mvc-and-security/static-web-page-example.png" class="" title="This is an example image"></center>

<p>서버에서 제공하고자 하는 파일들을 실제 서버 내부에 일일히 적재를 해야했으며, 서버에 존재하지 않는 파일에 접근한다면 <code>404 Not Found Error</code> 오류를 보게 됩니다. 이렇게 유저에게 정적인 페이지를 제공하는 서버를 <strong>Web Server</strong>(<strong>웹 서버</strong>)라고 부르며 많이 접해봤을 <strong>Apache, Nginx</strong> 가 이에 해당합니다.</p>
<h2 id="Nginx-의-요청-처리-흐름"><a href="#Nginx-의-요청-처리-흐름" class="headerlink" title="Nginx 의 요청/처리 흐름"></a>Nginx 의 요청/처리 흐름</h2><h3 id="요청-처리시"><a href="#요청-처리시" class="headerlink" title="요청 처리시"></a>요청 처리시</h3><p><strong>웹 서버</strong>의 예로 <strong>nginx</strong> 에서는 유저 요청을 아래의 과정으로 처리합니다.</p>
<center><img src="/2021/02/14/a-tutorial-for-spring-mvc-and-security/web-server-description.png" class=""></center>

<h4 id="요청-처리시-1"><a href="#요청-처리시-1" class="headerlink" title="요청 처리시"></a>요청 처리시</h4><ul>
<li>유저는 <strong>웹 서버</strong>에게 특정 페이지(<code>index.html</code>)를 요청합니다.</li>
<li><strong>웹 서버</strong>는 <code>index.html</code> 검색 후, 있다면 유저에게 반환합니다.</li>
</ul>
<hr>
<h1 id="Web-Application-dynamic-페이지"><a href="#Web-Application-dynamic-페이지" class="headerlink" title="Web Application (dynamic 페이지)"></a>Web Application (<strong>dynamic 페이지</strong>)</h1><p>Javascript 의 등장으로 초기 <strong>웹 서버</strong>처럼 유저에게 단순한 문서를 공유하는 <strong>일방적인</strong> 서비스를 제공하는것에서 그치지 않고, 유저와의 인터렉션을 통해 회원가입도 가능하고, 글도 쓸 수 있고, 작성한 글들을 서로 볼 수 있는 등의 <strong>양방향의</strong> 서비스에 대한 요구사항이 생겨나게 되었습니다. 이를 위해서는 <strong>일반적인 어플리케이션처럼 데이터베이스와의 연결도 필요</strong>하고, 회원의 상태에 따른 <strong>동적 페이지 렌더링</strong> 등이 필요해졌습니다. 서버는 <strong>서버에 있는 자원</strong>만 반환하는것이 아니라 유저가 요청한 정보를 <strong>요청받은 시점에 알맞은 자원(페이지)를 만들어서 반환</strong>하게 됩니다.</p>
<blockquote>
<p><strong>서버에 없는 페이지</strong>를 유저들에게 <strong>매 요청때마다 동적으로 만들어서</strong> 보여줍니다.</p>
</blockquote>
<p>웹으로 어플리케이션과 같은 요구사항을 처리하기 위해서는 <strong>웹 서버</strong>와 <strong>여러 언어로 개발된 프로그램</strong>을 연결하여 유저의 요청을 서버를 통해 프로그램으로 전달해야합니다. 이렇게 웹 서버와 프로그램 사이를 연결해주는 방식을 <strong>CGI</strong>(<strong>Common Gateway Interface</strong>)라고하며 여러 언어로 개발되어있습니다. 그 중 Java 에서는 <strong>Web Server 요청/반환과 Java Application 사이를 연결해주는 Servlet 객체가 등장합니다.</strong> Servlet 은 유저 요청 하나마다 하나씩 생성되기 때문에 <strong>여러 요청에 따른 Servlet 자원 관리</strong>가 필요합니다. 이 역할을 하는것이 <strong>Web Container</strong> 이며 Servlet 입장에선 Servlet Container 로 부르기도 합니다. 유저의 요청/반환을 관할하는 <strong>Web Server</strong> + 요청에 따른 적합한 Java Application 구동을 위한 Servlet 관리자 <strong>Web Container</strong> 이 둘을 합쳐 <strong>Web Application(웹 어플리케이션)</strong> 이라고 부릅니다.</p>
<blockquote>
<p><strong>Web Application</strong> = <strong>Web Server</strong> + <strong>Web Container</strong>(= Servlet Container)</p>
</blockquote>
<blockquote>
<p><strong>Web Container</strong> 는 유저의 요청에 따라 <strong>Servlet 자원에 대한 생명주기를 관리</strong>합니다</p>
<ul>
<li><strong>생성(init) -&gt; 처리(service) -&gt; 파기(destory)</strong></li>
</ul>
</blockquote>
<center><img src="/2021/02/14/a-tutorial-for-spring-mvc-and-security/servlet-container-life-cycle.png" class="" title="출처: [JSP] 서블릿(Servlet)이란? - https:&#x2F;&#x2F;mangkyu.tistory.com&#x2F;14"></center>

<h2 id="Tomcat-의-요청-처리-흐름"><a href="#Tomcat-의-요청-처리-흐름" class="headerlink" title="Tomcat 의 요청/처리 흐름"></a>Tomcat 의 요청/처리 흐름</h2><h3 id="요청-처리시-2"><a href="#요청-처리시-2" class="headerlink" title="요청 처리시"></a>요청 처리시</h3><p><strong>웹 어플리케이션</strong>의 예로 <strong>tomcat</strong> 에서는 유저 요청을 아래의 과정으로 처리합니다.</p>
<center><img src="/2021/02/14/a-tutorial-for-spring-mvc-and-security/web-application-description.png" class=""></center>

<p>웹 서버 그림과 비교했을때 웹 서버 아래에 추가된것은 모두 웹 컨테이너에 관련된 것입니다. Web Container 를 시작으로 아래서 위로 역순으로 살펴보겠습니다. 옆에 회색으로 표시한 명칭은 실제 클래스/인터페이스명입니다.</p>
<blockquote>
<h4 id="ServletContext-Web-Container"><a href="#ServletContext-Web-Container" class="headerlink" title="ServletContext (Web Container)"></a>ServletContext (<strong>Web Container</strong>)</h4><p>‘Servlet 객체 주기 관리를 위한 웹 컨테이너’에 해당합니다. <strong>관리라는 의미로 Context 를 사용</strong>했습니다.<br>모든 요청에 대한 Servlet 생명주기는 이 <strong>ServletContext</strong>가 모두 관리합니다.</p>
</blockquote>
<blockquote>
<h4 id="ServletContextListener"><a href="#ServletContextListener" class="headerlink" title="ServletContextListener"></a><strong>ServletContextListener</strong></h4><p>‘Servlet 객체 주기 관리를 위한 웹 컨테이너’ <strong>ServletContext 최초 구동시(Listener) 수행할 작업을 정의</strong>합니다.</p>
</blockquote>
<blockquote>
<h4 id="web-xml-Deployment-Description"><a href="#web-xml-Deployment-Description" class="headerlink" title="web.xml (Deployment Description)"></a>web.xml (<strong>Deployment Description</strong>)</h4><p>Deployment Description 이라는 명칭에서 알 수 있듯이 웹 컨테이너 구동시, Servlet 을 위한 2가지 설정을 합니다.</p>
<ul>
<li>B) <strong>ServletContextListener 인터페이스 구현체</strong> (어떤것을 실행할지)</li>
<li>A) <strong>‘어떤 요청’에 ‘어떤 타입’의 Servlet 객체</strong>를 생성할지</li>
</ul>
</blockquote>
<p>추가된 요소들을 살펴보았으니 위 웹 어플리케이션 그림의 유저 요청 처리 방식을 따라가보겠습니다.</p>
<h4 id="최초-구동시"><a href="#최초-구동시" class="headerlink" title="최초 구동시"></a>최초 구동시</h4><ul>
<li>tomcat 웹 어플리케이션이 최초 구동시 가장 먼저 <strong>웹 컨테이너</strong>(<strong>ServletContext</strong>)를 구동합니다.</li>
<li>B) <strong>ServletContext</strong> 구동 시 web.xml 에 설정한 <strong>ServletContextListener</strong> 를 같이 수행합니다.</li>
</ul>
<h4 id="요청-처리시-3"><a href="#요청-처리시-3" class="headerlink" title="요청 처리시"></a>요청 처리시</h4><ul>
<li>유저는 <strong>웹 서버</strong>에게 특정 페이지(<code>index.html</code>)를 요청합니다.</li>
<li><strong>웹 서버</strong>는 <code>index.html</code> 검색 후, 존재하지 않기 때문에 <strong>웹 컨테이너</strong>(<strong>ServletContext</strong>)에게 요청을 이관합니다.</li>
<li>A) <strong>ServletContext</strong> 는 web.xml 에서 <code>index.html</code> <strong>요청에 맞는 타입의 Servlet 를 생성</strong>합니다.</li>
<li>생성된 Servlet 은 유저가 요청한 페이지를 동적으로 생성하여 유저에게 반환 후 파기(destory)됩니다.</li>
</ul>
<hr>
<h1 id="Spring-MVC-Framework"><a href="#Spring-MVC-Framework" class="headerlink" title="Spring MVC Framework"></a>Spring MVC Framework</h1><p>Java Servlet 을 활용한 웹 어플리케이션 개발이 활성화되면서 여러 디자인 패턴들을 적용하여 Java 웹 개발을 더 쉽게 도와주는 Spring Framework 가 등장하게됩니다. 초기 웹 어플리케이션이 페이지를 동적으로 렌더링하기 위해 <strong>각 요청마다 Servlet 을 할당</strong>하여 요청을 처리하였다면, Spring 은 <strong>각 요청마다 Servlet 보다 작은 단위인 Bean 을 할당하여</strong> 요청을 처리합니다.</p>
<blockquote>
<p>요청을 처리하는 단위가 <strong>Servlet</strong> 이라면 Servlet 관리를 위한 <strong>Servlet Container</strong><br>요청을 처리하는 단위가 <strong>Bean</strong> 이라면 Bean 관리를 위한 <strong>Bean Container</strong> 가 필요합니다.<br>이 Bean Container 를 <strong>Spring Container</strong> 로 부릅니다.</p>
</blockquote>
<blockquote>
<p><strong>Servlet Container</strong> 는 각 URL 요청들을 <strong>Serlvet</strong> 을 단위로 처리하지만<br><strong>Spring Container</strong> 는 각 URL 요청들을 <strong>Bean</strong> 을 단위로 처리합니다.</p>
</blockquote>
<p><strong>Spring 은 기본적으로 MVC 모델로 Model, View, Controller 세 그룹의 역할로 분리 개발</strong>을 돕는 프레임워크이기에 아무리 디자인 패턴에 대한 지식이 전무한 개발자일지라도 유지보수성, 재사용성이 뛰어난 웹 어플리케이션을 만들 수 있습니다. 또한 <strong>데이터베이스 접근을 위한 JPA, 트랜잭션, 보안 등 웹 어플리케이션에서 필요로하는 모든것을 Bean 설정으로 제공</strong>하기 때문에 어떤 초보자라도 탄탄한 이해만 바탕이 된다면 웹 어플리케이션을 손쉽게 만들 수 있습니다. 디자인 패턴이 실무적으로 어떻게 적용되었는지 공부하는데엔 Spring 만한것이 없는것같다는 어느 시니어의 말씀이 기억에 남습니다.</p>
<hr>
<h1 id="Spring-Web-Application"><a href="#Spring-Web-Application" class="headerlink" title="Spring + Web Application"></a>Spring + Web Application</h1><p>Spring MVC 동작 과정을 쉽게 이해하기 위해서는 <strong>MVC</strong> 와 <strong>Front Controller 패턴</strong> (<strong>2-레벨 Controller</strong>) 만 알면 됩니다.</p>
<h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a><strong>MVC</strong></h4><p>Model, View, Controller 로써 유저의 요청을 효율적으로 처리하기 위한 모델입니다. 유저가 어떤 페이지를 요청하면</p>
<ol>
<li>요청에 적합한 <strong>Controller 가 요청을 받아</strong>서</li>
<li>요청 페이지에 필요로 하는 정보인 <strong>Model 을 조회/생성</strong>하고</li>
<li>조회/생성한 Model 을 통해 <strong>최종 페이지인 View 를 생성</strong>하여 유저에게 <strong>반환</strong>하는 모델입니다.</li>
</ol>
<h4 id="Front-Controller-패턴"><a href="#Front-Controller-패턴" class="headerlink" title="Front Controller 패턴"></a><strong>Front Controller 패턴</strong></h4><p>요청을 받는 부분을 Controller 라고 하였는데 <strong>tomcat 은 요청을 Servlet 이라는 Controller 에서 처리하고, Spring 은 요청을 Bean 이라는 Controller 에서 처리</strong>합니다. <strong>2-레벨 Controller</strong> 의 의미는 <strong>(1) 맨 앞의 tomcat 이 모든 요청을 단일 Servlet으로 먼저 받아</strong>, 요청 URL 이 무엇인지에 따라서 <strong>(2) Spring 의 Controller Bean 에 재할당</strong>해주게 됩니다. 가장 앞의 <strong>(1) tomcat 단일 Servlet</strong> 을 ‘요청을 가장 앞에서 먼저 받는다’는 의미에서 <strong>Front Controller</strong> 라 부르고, 그 뒤에 <strong>(2) Spring Controller Bean</strong> 을 실제 페이지 생성에 사용된다는 의미에서 <strong>Page Controller</strong> 라고 부릅니다.</p>
<h2 id="Spring-MVC-의-요청-처리-흐름"><a href="#Spring-MVC-의-요청-처리-흐름" class="headerlink" title="Spring MVC 의 요청/처리 흐름"></a>Spring MVC 의 요청/처리 흐름</h2><h3 id="최초-구동시-1"><a href="#최초-구동시-1" class="headerlink" title="최초 구동시"></a>최초 구동시</h3><p><strong>Spring + tomcat</strong> 에서는 유저 요청을 어떻게 처리하는지 알아보기에 앞서, tomcat 과 Spring 이 처음 구동될때 어떤 객체들이 생성되어 준비되는지 먼저 알아보겠습니다. Web Container 아래에 <strong>Spring Container</strong> 가 새로 추가된것을 볼 수 있습니다.</p>
<center><img src="/2021/02/14/a-tutorial-for-spring-mvc-and-security/spring-web-application-description-1-init.png" class=""></center>

<p>위 그림과 같이 tomcat 에 Spring 을 연결하여 사용하려면 tomcat 설정파일인 web.xml 에 2 가지 설정이 필요합니다.</p>
<blockquote>
<h4 id="web-xml-Deployment-Description-1"><a href="#web-xml-Deployment-Description-1" class="headerlink" title="web.xml (Deployment Description)"></a>web.xml (<strong>Deployment Description</strong>)</h4><ul>
<li>B) <strong>ServletContextListener 인터페이스 구현체</strong> - <strong>Root WebApplicationContext</strong><br>-&gt; <strong>Spring 공용 Bean (@Service, @Repository, @Component…) 객체들을 미리 생성</strong>해놓기 위함</li>
<li>A) <strong>‘모든 요청’은 Front Controller 에 해당하는 단일 Servlet 객체</strong>(<strong>DispatcherServlet</strong>)가 처리한다.</li>
</ul>
</blockquote>
<h4 id="최초-구동시-2"><a href="#최초-구동시-2" class="headerlink" title="최초 구동시"></a>최초 구동시</h4><ul>
<li>tomcat 웹 어플리케이션이 최초 구동시 가장 먼저 <strong>웹 컨테이너</strong>(<strong>ServletContext</strong>)를 구동합니다.</li>
<li>B) <strong>ServletContext</strong> 구동 시 web.xml 에 설정한 Spring <strong>Root WebApplicationContext</strong>가 동시에 구동됩니다.</li>
</ul>
<hr>
<h3 id="요청-처리시-4"><a href="#요청-처리시-4" class="headerlink" title="요청 처리시"></a>요청 처리시</h3><p>위 최초 구동 후 <strong>tomcat 은 모든 요청을 단일 Servlet(명칭은 DispatcherServlet) 으로 받을 준비가 완료</strong>되었고, <strong>Spring 도 Controller Bean 이 결과를 반환하기 위해 필요로하는 모든 Bean 들이 Root WebApplicationContext 로 준비가 완료</strong>되었습니다. 이제 유저가 요청을 보내면 tomcat 과 Spring 이 어떻게 처리하여 결과를 반환하는지 아래 그림으로 살펴보겠습니다.</p>
<center><img src="/2021/02/14/a-tutorial-for-spring-mvc-and-security/spring-web-application-description-2-request.png" class=""></center>

<p>Spring 의 키워드는 IoC, DI 라고 할 수 있는데, 간단하게 설명하자면 기존에는 개발자가 new 를 통해 객체를 직접 생성하고, 직접 주입해줬다면 Spring 에서는 어떤 인터페이스, 클래스를 사용할것인지만 표기해놓으면 <strong>ApplicationContext</strong>(BeanFactory 상속) 라고 불리는 Spring Container 가 객체를 Bean 이라는 단위로 알아서 생성하고 알아서 주입해주는 개념입니다. 이렇게 Spring 에서는 <strong>Java 의 모든 객체를 Bean 으로 부르며 사용합니다.</strong></p>
<blockquote>
<p><strong>Spring Container</strong> = <strong>ApplicationContext</strong></p>
</blockquote>
<blockquote>
<p>Spring 에서 Bean 은 웹 어플리케이션 관점에서 크게 <strong>2 개의 타입</strong>으로 구분될 수 있습니다.<br>그에 따라 Bean 의 생명주기를 관리하는 Spring Container 도 2 개의 타입으로 나뉘어집니다.</p>
<ul>
<li>요청이 들어왔을때 적합한 처리를 위해 <strong>요청과 상관없이 모든 Servlet 들이 공유하는 공용 Bean</strong><ul>
<li>예: <strong>@ComponentScan</strong> 으로 등록된 <strong>@Service, @Repository, @Component</strong> 등</li>
<li>생명주기 관리: Spring Container 1 (<strong>Root</strong> Web<strong>ApplicationContext</strong>)</li>
</ul>
</li>
<li>요청이 들어왔을때 할당되는 Servlet 처럼, <strong>요청이 들어왔을때만 생성하면 되는 Bean</strong><ul>
<li>예: <strong>@ComponentScan</strong> 으로 등록된 <strong>@Controller, @Interceptor</strong> 등</li>
<li>생명주기 관리: Spring Container 2 (<strong>Servlet</strong> Web<strong>ApplicationContext</strong>)</li>
</ul>
</li>
</ul>
</blockquote>
<p>위 그림을 보면 <strong>최초 구동시</strong>에 생성된 Spring Container 1 아래에 또 하나의 Spring Container 2 가 생겨난걸 볼 수 있습니다. parent 와 child 라고 써져있는것은 두 컨테이너 간 계층이 있다는 의미이며, 단순히 child 인 <strong>Servlet</strong> Web<strong>ApplicationContext</strong> 의 Bean 들은 부모인 <strong>Root</strong> Web<strong>ApplicationContext</strong> 의 Bean 들을 참조할 수 있지만 그 반대로는 참조할 수 없음을 의미합니다. <strong>Root</strong> Web<strong>ApplicationContext</strong> 이 모든 Servlet 들이 공유하는 Bean 생명주기를 관리하는것이라 생각하면 당연한것입니다.</p>
<h4 id="요청-처리시-5"><a href="#요청-처리시-5" class="headerlink" title="요청 처리시"></a>요청 처리시</h4><ul>
<li>유저는 <strong>웹 서버</strong>에게 특정 페이지(<code>index.html</code>)를 요청합니다.</li>
<li><strong>웹 서버</strong>는 <code>index.html</code> 검색 후, 존재하지 않기 때문에 <strong>웹 컨테이너</strong>(<strong>ServletContext</strong>)에게 요청을 이관합니다.</li>
<li>A) <strong>ServletContext</strong> 는 web.xml 에서 어떤 요청이든 <code>/</code> <strong>단일 DispatcherServlet 을 생성</strong>합니다.</li>
<li>DispatcherServlet 은 <strong>유저가 요청한 페이지에 해당하는 Spring Controller</strong>가 있는지 <strong>HandlerMapping 을 탐색</strong>합니다.<ul>
<li>Spring Controller 를 <strong>Handler</strong> 라고 부릅니다</li>
</ul>
</li>
<li>DispatcherServlet 은 찾은 <strong>Spring Controller Bean</strong>를 <strong>HandlerAdapter</strong>를 통해 호출합니다.</li>
<li><strong>HandlerAdapter</strong>은 <strong>HelloController Bean</strong>를 호출합니다.</li>
<li><strong>HelloController</strong>는 Root WebApplicationContext 의 여러 Bean 들을 활용하여 결과를 <strong>DispatcherServlet</strong>에 반환합니다.</li>
<li><strong>DispatcherServlet</strong>는 Controller 로부터 받은 결과로 <strong>ViewResolver</strong>, <strong>View</strong>에서 <strong>결과 페이지</strong>(<strong><code>index.html</code></strong>)를 생성합니다.</li>
<li><strong>DispatcherServlet</strong>는 <strong>ViewResolver</strong>, <strong>View</strong>가 만든 <strong>결과 페이지</strong>(<strong><code>index.html</code></strong>)를 유저에게 반환합니다.</li>
</ul>
<p>위 과정의 코드레벨에서의 흐름은 다음 블로그 링크<a target="_blank" rel="noopener" href="https://galid1.tistory.com/526">^1</a>에 잘 정리되어있어 참고하시면 상세히 알 수 있습니다. </p>
<p>이렇게 Spring MVC 에서 어떻게 유저의 요청을 받아서 처리하고 반환하는지를 그림으로 알아보았습니다. 요청 URL 에 따라 Controller Bean 이 할당된다는것은 알았지만, 이렇게 상세하게 알아보니 컨트롤러나 서비스에서 Exception 이 발생하였을때 로그에 남는 Stacktrace 의 메서드와 클래스들의(invoke, DispatcherServlet, preHandle, postHandle 등) 의미를 좀 더 알 수 있었습니다.</p>
<hr>
<h2 id="Spring-Interceptor-와-Filter-의-차이점"><a href="#Spring-Interceptor-와-Filter-의-차이점" class="headerlink" title="Spring Interceptor 와 Filter 의 차이점"></a>Spring Interceptor 와 Filter 의 차이점</h2><p>Spring 을 활용하여 개발한 웹 어플리케이션들은 일부 혹은 모든 사용자에게 오픈되어 서비스를 제공하기때문에 보안이 필요합니다. Spring Security 는 기본적으로 로그인과 세션에 관련된 모듈 및 설정을 손쉽게 사용가능하도록 제공하지만, <strong>웹 어플리케이션에 인입되는 모든 요청에 따로 개발한 인증 모듈을 적용</strong>하거나, <strong>요청 URL 에 따라 다른 처리</strong> 등이 필요하다면, 개발자가 해당 로직들을 직접 만들어 유저 요청이 실제 Spring Controller 에게 전달되기 전에 수행되도록 해당 로직을 추가해야합니다. 이때 사용되는것이 <strong>Interceptor</strong> 와 <strong>Filter</strong> 입니다.</p>
<p>우리는 앞서 Spring 을 사용한 웹 어플리케이션은 크게 <strong>Tomcat (Web Container)</strong> 와 <strong>Spring (Spring Container)</strong> 의 2개로 구성된다는것을 배웠습니다. <strong>Interceptor</strong> 와 <strong>Filter</strong> 도 Spring Controller 에 요청이 도달하기 이전에 원하는 중간 작업을 위해 사용된다는 목적에선 동일하지만, 관리주체 및 실행시간이 <strong>Tomcat</strong> 과 <strong>Spring</strong> 으로 나뉘어집니다.</p>
<blockquote>
<p><strong>Filter 는 Servlet 스펙의 일부이고 Servlet(Tomcat)에 의해 호출되지만</strong><br><strong>Interceptor 는 Spring 에 의해 호출됩니다.</strong><br>(It’s perfectly fine as Filter’s are part of Servlet specification. Filters are called by your Server(tomcat). while Interceptors are called by Spring<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26908910/spring-mvc-execution-order-filter-and-interceptor">^2</a>)</p>
</blockquote>
<p>아래는 Interceptor 와 Filter 의 관리주체 및 실행시간을 이해하기 쉽게 표현한 그림입니다.</p>
<center><img src="/2021/02/14/a-tutorial-for-spring-mvc-and-security/spring-web-application-description-3-filter-and-interceptor.png" class=""></center>

<h3 id="Filter-Tomcat"><a href="#Filter-Tomcat" class="headerlink" title="Filter (Tomcat)"></a>Filter (Tomcat)</h3><ul>
<li>Servlet (J2EE 7 표준)스펙에 정의<ul>
<li>웹 어플리케이션(tomcat) <strong>Deployment Descriptor(web.xml)에 설정</strong><ul>
<li>이 부분에 대한것도 최신 Spring 에서 설정 가능</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><strong>1개</strong>의 함수로 <strong>DispatcherServlet 이전/이후에 호출</strong><ul>
<li>함수명: <strong>doFilter()</strong><ul>
<li>요청이 DispatcherServlet.service() 에 진입하기 <strong>직전</strong>(init() 후)에 <strong>호출</strong></li>
<li>결과를 DispatcherServlet.service() 가 반환하는 <strong>직후</strong>(destroy() 전)에 <strong>호출</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>doFilter 함수가 <strong>요청 진입시 &amp; 결과 반환시, 2번 호출</strong>되기 때문에, <strong>암/복호화같은 요청 전 &amp; 반환 후 두 곳에 전역적으로 처리해야하는 로직에 적합</strong>합니다.</li>
</ul>
<h3 id="Interceptor-Spring"><a href="#Interceptor-Spring" class="headerlink" title="Interceptor (Spring)"></a>Interceptor (Spring)</h3><ul>
<li>Spring Framework 스펙에 정의<ul>
<li>Spring <strong>WebApplicationContext에 설정</strong></li>
</ul>
</li>
</ul>
<ul>
<li> <strong>3개</strong>의 함수로 <strong>Controller 이전/이후에 호출</strong><ul>
<li>함수명: <strong>preHandle()</strong><ul>
<li>요청이 Controller 에 진입하기 <strong>직전</strong>에 <strong>호출</strong></li>
</ul>
</li>
<li>함수명: <strong>postHandle()</strong><ul>
<li>결과를 Controller 가 반환하는 <strong>직후</strong>에 <strong>호출</strong></li>
</ul>
</li>
<li>함수명: <strong>afterCompletion()</strong><ul>
<li>Controller 결과에 따라 <strong>View 를 생성한 직후</strong>에 <strong>호출</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>컨트롤러 진입 혹은 결과 반환 <strong>시점에 디테일하게 처리해야하는 로직에 적합</strong>합니다. 예를 들어 특정 URL 로 진입되는 요청에 대해서는 컨트롤러 진입 직전에 해당 URL 에 특화된 정보들을 미리 세션에 설정하여 컨트롤러 내부 로직에서 활용할 수 있게 할 수 있습니다. 다른 URL 이라면 본 로직을 수행하지 않도록 조건을 추가할 수도 있습니다.</li>
</ul>
<p>필터와 인터셉터는 관리주체가 다르기 때문에 다음과 같은 상황이 발생합니다.</p>
<ul>
<li>필터는 Spring Container 관리주체가 아니기 때문에 필터 로직 내부에서 Spring 의 Bean 을 사용하려면 <code>@Autowired</code> 같은 빈 주입이 아닌, 먼저 Spring <code>WebApplicationContext</code> 객체를 가져와서 그 안에 설정된 Bean 을 하드코딩을 통해 직접 가져와서 사용해야합니다.</li>
</ul>
<h2 id="다수-Interceptor-와-Filter-의-호출-순서"><a href="#다수-Interceptor-와-Filter-의-호출-순서" class="headerlink" title="다수 Interceptor 와 Filter 의 호출 순서"></a>다수 Interceptor 와 Filter 의 호출 순서</h2><p>필터와 인터셉터는 상황에 따라 여러개를 지정하여 사용할 수 있습니다. 다수의 필터 혹은 인터셉터 사용시 각각의 호출 순서는 설정에 따라 바꿀 수 있는데, 필터도 사실은 DispatcherServlet 호출 전/후에 호출되는 Servlet 설정이기 때문에 tomcat 에서 관리하는것이라 하더라도 인터셉터와 마찬가지로 Spring 설정을 통해 설정할 수 있습니다.</p>
<p><strong>2개의 필터</strong>와 <strong>2개의 인터셉터</strong>를 사용할때 어떻게 동작하는지 순서를 살펴보기 위해 DispatcherServlet 과 HandlerAdaptor 를 중점적으로 살펴보면 아래와 같습니다.</p>
<center><img src="/2021/02/14/a-tutorial-for-spring-mvc-and-security/order-of-filters-and-interceptors.png" class=""></center>

<p>정확한 순서는 아래 간략하게 요약한 그림으로 알 수 있습니다.</p>
<ol>
<li>doFilter (F1)</li>
<li>doFilter (F2)</li>
<li>preHandler (I1)</li>
<li>preHandler (I2)</li>
<li><strong>Controller 요청 처리</strong></li>
<li>postHandler (I2)</li>
<li>postHandler (I1)</li>
<li><strong>View 렌더링</strong></li>
<li>afterCompletion (I2)</li>
<li>afterCompletion (I1)</li>
<li>doFilter (F2)</li>
<li>doFilter (F1)</li>
</ol>
<center><img src="/2021/02/14/a-tutorial-for-spring-mvc-and-security/summary-order-of-filters-and-interceptors.png" class=""></center>

<p>웹 서버에서 웹 어플리케이션, 웹 서버와 웹 어플리케이션을 연결하기 위한 CGI 의 예로 Servlet 그리고 Container 를 알아보고, Spring Container 와 Filter, Interceptor 의 차이 그리고 실행 순서에 대해 알아보았습니다. Spring 을 공부하시거나 사용하시는 다른 개발자 분들에게 본 글이 도움이 되었길 바랍니다. 참조한 글들도 좋은 글들이니 시간이 되시면 한번씩 훑어보시는걸 추천드립니다.</p>
<hr>
<p>출처: </p>
<ol>
<li>Spring 동작 원리 #1:<br><a target="_blank" rel="noopener" href="https://asfirstalways.tistory.com/334">https://asfirstalways.tistory.com/334</a></li>
<li>Spring 동작 원리 #2:<br><a target="_blank" rel="noopener" href="https://devpad.tistory.com/24">https://devpad.tistory.com/24</a></li>
<li>Spring 동작 원리 #3:<br><a target="_blank" rel="noopener" href="https://taes-k.github.io/2020/02/16/servlet-container-spring-container/">https://taes-k.github.io/2020/02/16/servlet-container-spring-container/</a></li>
<li>Tomcat 이 Spring 호출하는 방법:<br><a target="_blank" rel="noopener" href="http://www.deroneriksson.com/tutorial-categories/java/spring/introduction-to-the-spring-framework">http://www.deroneriksson.com/tutorial-categories/java/spring/introduction-to-the-spring-framework</a></li>
<li>Java Servlet:<br><a target="_blank" rel="noopener" href="https://mangkyu.tistory.com/14">https://mangkyu.tistory.com/14</a></li>
<li>Web Server, Web Application 차이:<br><a target="_blank" rel="noopener" href="https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html">https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html</a></li>
<li>Spring DispatcherServlet 동작 원리 #1:<br><a target="_blank" rel="noopener" href="https://jess-m.tistory.com/15">https://jess-m.tistory.com/15</a></li>
<li>Spring DispatcherServlet 동작 원리 #2:<br><a target="_blank" rel="noopener" href="https://dynaticy.tistory.com/entry/Spring-MVC-Dispatcher-Servlet-%EB%82%B4%EB%B6%80-%EC%B2%98%EB%A6%AC-%EA%B3%BC%EC%A0%95-%EB%B6%84%EC%84%9D">https://dynaticy.tistory.com/entry/Spring-MVC-Dispatcher-Servlet-%EB%82%B4%EB%B6%80-%EC%B2%98%EB%A6%AC-%EA%B3%BC%EC%A0%95-%EB%B6%84%EC%84%9D</a></li>
<li>Spring web.xml 설명 #1:<br><a target="_blank" rel="noopener" href="https://sphere-sryn.tistory.com/entry/%EC%8A%A4%ED%94%84%EB%A7%81%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%9D%98-%EA%B0%80%EC%9E%A5-%EA%B8%B0%EB%B3%B8%EC%84%A4%EC%A0%95-%EB%B6%80%EB%B6%84%EC%9D%B8-webxml%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90">https://sphere-sryn.tistory.com/entry/%EC%8A%A4%ED%94%84%EB%A7%81%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%9D%98-%EA%B0%80%EC%9E%A5-%EA%B8%B0%EB%B3%B8%EC%84%A4%EC%A0%95-%EB%B6%80%EB%B6%84%EC%9D%B8-webxml%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90</a></li>
<li>Spring web.xml 설명 #2:<br><a target="_blank" rel="noopener" href="https://gmlwjd9405.github.io/2018/10/29/web-application-structure.html">https://gmlwjd9405.github.io/2018/10/29/web-application-structure.html</a></li>
<li>Spring 2개 타입의 ApplicationContext:<br><a target="_blank" rel="noopener" href="https://jaehun2841.github.io/2018/10/21/2018-10-21-spring-context/#web-application-context">https://jaehun2841.github.io/2018/10/21/2018-10-21-spring-context/#web-application-context</a></li>
<li>Servlet Container &amp; Spring Container:<br><a target="_blank" rel="noopener" href="https://velog.io/@16616516/%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88">https://velog.io/@16616516/%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88</a></li>
<li>Spring MVC 코드 기반 동작 원리:<br><a target="_blank" rel="noopener" href="https://galid1.tistory.com/526">https://galid1.tistory.com/526</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2021-02-07</div></span><span class="level-item"><a class="link-muted" href="/categories/Workplace/">Workplace</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/07/things-that-i-should-have-known-when-i-was-a-junior-developer/">신입 개발자였던 내게 해주고싶은 조언들</a></h1><div class="content"><h1 id="부족했던-나의-신입시절"><a href="#부족했던-나의-신입시절" class="headerlink" title="부족했던 나의 신입시절"></a>부족했던 나의 신입시절</h1><p>개발자로 살아온지 3년반이 되었습니다. 물리학자의 삶을 꿈꿨었지만, 중학교때 게임을 만들자고 배웠던 C 언어와 고등학교때 hamachi 로 VPN 과 네트워크에 흥미를 가진것을 시작으로 학석사를 지난 뒤 시대 기술 흐름에 타고싶다는 욕심으로 첫 직장으로 쿠팡에 들어갔었습니다.</p>
<p><strong>신입때는 너무 어렸었습니다.</strong> 튀는걸 너무 좋아해서 옷도 행실도 너무 자유분방했던것같고, <strong>개발을 잘하면 모르겠는데 제대로 할줄아는것도 없으면서 열정만 높았어서 이것저것 손대는것들만 많았으니 팀적으로도 개인적으로도 남는것이 그리 많진 않았었습니다.</strong> 개발적으로는 Spring, Java 와 React 에 좀 더 집중했었으면 어떨까 아쉬움은 있지만, 나름 큰 회사에 비지니스에서 개발까지 풀스택에 가까운 다양한 경험들을 통해 배운것들은 많아서 큰 후회는 없습니다. 그래도 제가 과거의 <strong>제 신입시절로 돌아간다면 해주고 싶은 몇가지 조언들</strong>이 있습니다.</p>
<hr>
<h1 id="주변에서의-조언-요청"><a href="#주변에서의-조언-요청" class="headerlink" title="주변에서의 조언 요청"></a>주변에서의 조언 요청</h1><p>쉬는날엔 개발에 흥미를 가진 학생과 Spring 나 머신러닝 스터디를 진행하며 몇 조언도 주었었는데, 얼마전에 한명으로부터 자기 주변의 신입 개발자분들한테 해줄 조언에 대해 질문받았습니다. 짧게 답변해주려다가 내 부족했던 신입시절을 회고할겸, 블로그로 작성해놓으면 다른 스터디에서도 본 글을 추천해주면 되겠다 싶어서 이렇게 글을 작성하게 되었습니다. 워낙 다양한 스택의 신입 개발자분들이 많아서 각 분야에 맞게 학습하시는게 좋을것같아 따로 본 글에 기술적인것들은 제외하였습니다.</p>
<h2 id="개발자-한번-더-생각해보세요"><a href="#개발자-한번-더-생각해보세요" class="headerlink" title="개발자, 한번 더 생각해보세요"></a>개발자, 한번 더 생각해보세요</h2><center><img src="/2021/02/07/things-that-i-should-have-known-when-i-was-a-junior-developer/dont-be-a-programmer.png" class=""></center>

<p>최근 산업구조의 변화때문에 개발직군에 대한 수요가 폭증하기 시작했고, 현재의 취업난은 구직하는 분들에게 개발자가 매력적인 대안으로 다가오면서 <strong>직군을 개발자로 바꿔 이직하시거나 학생들은 전과를 하는 경우</strong>가 주변에서 종종 보이기 시작합니다. <strong>유능한 개발자가 돈을 많이 벌기도하고, 회사의 대우도 좋은 편이고, 창의적 직군이다보니 흔히말하는 꼰대가 생존할 수 없는 분야라 개발자 문화가 선진화되어있어서 좋아보일 수 있습니다.</strong> 하지만 이는 나 자신이 유능한 개발자일때 한하여 얻을 수 있는 장점들입니다. 어떤 분야와도 마찬가지로 그 사이에는 무수히 많은 인고의 시간들이 있습니다.</p>
<hr>
<h3 id="대체-가능한-인력"><a href="#대체-가능한-인력" class="headerlink" title="대체 가능한 인력"></a>대체 가능한 인력</h3><p>개발자는 <strong>유능하지 않으면 사실 해당 인력을 대체하기가 굉장히 쉬운 직군</strong>이기도 합니다. 제 주변의 시니어 개발자분들은 모두 SI 업체에서 혹독한 개발경험을 거쳐 오셔서 관련 이야기를 많이 들어왔었는데, 개발자들의 실력 분포는 승자독식이라고 보면 됩니다. 상위 적은 % 의 유능한 개발자들만 주도적으로 프로젝트를 운영할 수 있고 그 외의 개발자들은 수동적으로 할당 받은 개발만 할 수 있습니다. <strong>이 능동성과 수동성의 차이가 내가 있을 기업, 내가 받을 연봉, 주변에 능력있는 개발자들의 유무를 크게 가른다고 생각하시면 됩니다.</strong> 제 주변의 모든 존경스러운 시니어분들은 SI 에서 끊임없는 공부와 노력을 끝으로 올라오신 분들입니다. 이 말을 즉슨 내가 어디에 속하는지가 중요한것이 아니라 나의 태도가 중요하다는 것입니다. </p>
<hr>
<h3 id="유능한-개발자의-특성"><a href="#유능한-개발자의-특성" class="headerlink" title="유능한 개발자의 특성"></a>유능한 개발자의 특성</h3><p>유능한 개발자와 무능한 개발자의 분포가 굉장히 편파적인 이유는 유능해지기 그만큼이나 어렵다고 생각하셔야합니다. 경쟁은 상대적인데다가 노력하는 개발자들도 많기때문에 조금만 부족하더라도 장기적으로는 도태될 수 있습니다. 그렇다면 개발자는 어떤 사람들이 잘할 수 있을까요?</p>
<ol>
<li><strong>업무 외 시간에도 코딩 및 공부를 순수하게 즐길 줄 알아야합니다.</strong></li>
</ol>
<p>직장에서 업무를 마치고 집 돌아와서 <strong>혼자 쉬는시간에도, 직장에서 있었던 여러 이슈나 내가 주고받았던 코드리뷰들을 한번 더 복습하고 이유와 원인을 분석할 수 있어야합니다.</strong> 예를 들면, 오늘 처음으로 docker 를 이용한 배포 프로세스를 경험해봤다면 docker 에 대한 궁금한 점들을 공부하는식이죠. 개인 프로젝트가 있다면 좋습니다. 아니라면 다른 오픈소스를 하나, 둘 개선해보거나 잘 짜여진 오픈소스 코드를 뜯어보거나 디버깅을 통해 한라인씩 실행시켜보는것도 코드 역량을 올릴 수 있는 좋은 방법이기도 합니다.</p>
<ol start="2">
<li><strong>평생 공부할 수 있어야합니다.</strong></li>
</ol>
<p><strong>즐기는것도 필요하지만 개발자는 그만두기 이전까지 계속해서 공부해야하는 직군</strong>입니다. <strong>Spring</strong> 만하더라도 과거에는 <code>.xml</code> 기반으로 Bean 인젝션을 처리했었지만 이젠 <code>@Annotaion</code> 기반으로 처리합니다. <strong>React.js</strong> 도 과거에는 class 기반의 component 를 사용했지만 이제는 함수형 Hook 을 사용합니다. JVM 과 ES 표준은 항상 끊임없이 변화하고 매 개발 컨퍼런스에서는 자신들의 새 개념을 발표합니다. 세상을 빠르게 돌아가도록 하는건 기술이고 최근 그 기술의 선봉에 개발자들이 있습니다. 이 빠른 흐름에 뒤쳐지지 않기 위해서는 <strong>매 새로운 개념을 ‘과거의 탄탄한 개발지식을 바탕’으로 흡수하여 그 다음을 준비할 줄 아는 인재가 되어야합니다.</strong></p>
<p><strong>개발은 어떤 유저가 하나의 웹/앱에 수행한 클릭이 <code>프론트 UI -&gt; 네트워크 -&gt; 보안 -&gt; 백엔드 서버 -&gt; 서버 인프라 -&gt; DB</code> 모든 기술 스택의 사이클을 한바퀴 돌아 원하는 결과를 볼 수 있게하는것입니다.</strong> 각 분야는 의사로 치면 전문의들이 있을 정도로 그 깊이가 매우 깊습니다. 내가 어떤 분야의 전문의가 되더라도 모든 사이클에 대한 적당한 깊이의 이해가 있어야지</p>
<ul>
<li>개발하는데 있어서 다양한 상황을 동시에 고려하여 신뢰성 높은 결과를 만들/조언할 수 있고</li>
<li>문제가 생겼을때 빠른 원인 파악 및 대처를 할 수 있습니다.</li>
</ul>
<hr>
<h3 id="개발자는-사실-분석가입니다"><a href="#개발자는-사실-분석가입니다" class="headerlink" title="개발자는 사실 분석가입니다."></a>개발자는 사실 분석가입니다.</h3><p>개발자를 꿈꿀때 흔히 생각하는 모습은 키보드를 통해 코드를 끊임없이 쳐서 새로운걸 생산해내는것일 것입니다. <strong>개발의 절반만 보안, 성능, 안정성, 확장성을 고려하여 새로운 코드를 생성하는것</strong>이고, 그조차도 내가 만들었던 혹은 타인이나 스택오버플로의 코드의 많은 부분을 참조하여 <strong>재생산</strong>하게됩니다. <strong>나머지 절반은 테스팅과 디버깅</strong>입니다.</p>
<p>회사에서 업무를 수행하게 되면 하나의 프로젝트를 한 사람이 모든 역할과 책임을 갖고 만들지 않습니다. 만약 그렇다하더라도 해당 코드는 다음 세대에 새 개발자가 물려받게됩니다. <strong>개발은 다수 개발자와의 협업입니다. 즉, 다수 개발자들의 코드더미에 내 작은 코드를 넣는 과정의 반복입니다. 비대면, 비동기적 협업인 셈입니다.</strong> 그렇기때문에 하나의 피쳐를 개발한다 하더라도 타 개발자가 개발한 코드를 온전히 이해할수 있어야지 원치않는 에러를 내지 않게됩니다. 테스트를 진행하다보면 분명히 의도적인 결과가 도출되지 않을때가 있는데, 내가 만든 코드뿐만 아니라 타 개발자의 코드도 같이 디버깅 할 줄 알아야합니다. <strong>라인별로 의도를 파악하고, 코드의 흐름을 파악하는건 직접 개발능력보다 더 중요합니다.</strong> 아무리 좋은 침을 쓴다한들 한의사가 맥을 잘짚지 않으면 소용없는것과 마찬가집니다.</p>
<p>코드의 유지보수성은 한때 엄청 큰 이슈였고, 이를 위해 Spring 의 IoC, 책임분리 개념들이 이를 돕기위해 나왔었던것입니다. 남들이 어떤 문서없이도 코드를 이해할 수 있도록 만드는것이 가장 좋지만, 문서와 커멘터리는 개발자와 협업에 있어서 그 못지않게 중요합니다. <strong>개발은 협업이란걸 잊으면 안됩니다.</strong></p>
<hr>
<h2 id="좋은-시니어-개발자가-되기"><a href="#좋은-시니어-개발자가-되기" class="headerlink" title="좋은 시니어 개발자가 되기"></a>좋은 시니어 개발자가 되기</h2><p>생각했던것과 조금은 다른 개발자의 역량에 대해 알아봤습니다. 그럼에도 개발자가 되고싶은 마음이 크다면 이제는 신입때부터 어떻게해야 몇년뒤에 동료들이 같이 일하고싶어하는 시니어로 성장할 수 있을지에 대해 말해보겠습니다. 짧게 요약하자면 <strong>내가 작성한 코드에 대한 근거/이유를 어느 누구에게도 명료히 이야기할 수 있어야하고, 주력인 언어나 프레임워크에 대한 깊은 이해가 있어야합니다.</strong></p>
<hr>
<h3 id="이슈와-리뷰는-꼭-메모-복습"><a href="#이슈와-리뷰는-꼭-메모-복습" class="headerlink" title="이슈와 리뷰는 꼭 메모/복습"></a>이슈와 리뷰는 꼭 메모/복습</h3><p><strong>개발중에 발생하는 이슈, 코드리뷰는 꼭 ‘왜’에 대해 꼼꼼히 메모해놓고 복습하는것이 필요합니다.</strong> 앞서 말씀드렸듯이 개발자는 평생 공부해야하는 직업일 정도로 익혀야할 정보가 많기 때문에 따로 메모/복습이 없다면 매번 똑같은 실수를 반복하게됩니다. 기억을 잘하기 위해서는 스터디같은것을 통해 누군가에게 가르치는게 좋은 방법입니다.</p>
<hr>
<h3 id="코드-작성-이유-설명"><a href="#코드-작성-이유-설명" class="headerlink" title="코드 작성 이유 설명"></a>코드 작성 이유 설명</h3><p><strong>내가 어떤 작업을 왜 이렇게 했는지 누군가에게 제대로 설명할 수 있어야합니다.</strong> 신입이나 경력 개발자를 뽑을때 인터뷰로 유심히 보는 부분이기도 합니다. 누가 이렇게 하라던데요? 스택오버플로에서 이렇게 쓰더라구요.의 근거는 당연하지만 좋지 않습니다. <strong>이유없이, 그냥 되니까 사용하는 코드는 거의 없어야합니다.</strong> 물론 시간의 한계 때문에 모든 이유를 다 알 순 없습니다만 적어도 내 주력 분야에 대해서는 설득할 수 있어야합니다.</p>
<hr>
<h3 id="언어-프레임워크-선택과-집중"><a href="#언어-프레임워크-선택과-집중" class="headerlink" title="언어/프레임워크 선택과 집중"></a>언어/프레임워크 선택과 집중</h3><p><strong>신입때는 주력 언어, 프레임워크, DB 가 적고 깊을수록 좋습니다.</strong> 특히나 최신 기술을 사용하고 각 팀마다 개발스택이 다양한 (좋은) 회사를 처음 가게된다면 뷔페에 온듯양 두 눈이 휘둥그레져서 이것저것 다 먹어보고싶은 마음은 백번천번 이해합니다. <strong>하지만 주니어라면 내 주력 기술이 단 하나라도 있어야 그를 통해 다른 기술들과의 차이점을 알고, 특징들을 더 잘 이해할 수 있습니다.</strong> 타 기술을 이해하는데에 뿐만 아니라 커리어적으로도 3년~5년의 긴 시간이 흘렀을때 그 주력 기술이 나의 강점이 되어 후배들을 이끌 수 있게됩니다.</p>
<p>모든것을 다 익히고싶은 마음은 당장은 안타깝지만 정보량이 정말 방대하기 때문에 하나라도 제대로할 줄 아는 <strong>선택과 집중의 지혜가 필요합니다.</strong> 풀스택은 내 분야에 대한 제대로 된 이해가 꼿꼿히 바로서야 그 위에 ㅡ 자를 그려서 T 자형 인재가 될 수 있는것입니다. ㅣ만 제대로 세운다면 그 이후 ㅡ 는 더 넓고 방대하게 뻗어나갈 수 있으니 당장의 욕심을 내려놓고 내 분야에 집중합시다.</p>
<p>언어/프레임워크 선택은 <strong>내가 가고싶어하는 분야에서 많이 선호되고 보편적으로 사용하는것</strong>을 선택해야합니다. 웹 서비스 개발이라면 Java, Spring 그리고 SQL 은 MySQL 만 제대로 공부해놓는다면 NoSQL 의 개념과 MVCC 등을 이해하는데 큰 도움이 됩니다. 게임 개발이라면 유니티를 위해 C# 을 배운다거나 머신러닝을 위해서는 tensorflow 를 위한 python 을 공부할 수 있을것입니다.</p>
<hr>
<h3 id="틈틈히-시간날때마다-공부"><a href="#틈틈히-시간날때마다-공부" class="headerlink" title="틈틈히 시간날때마다 공부"></a>틈틈히 시간날때마다 공부</h3><p>신입분들은 새 회사에서 크게 세가지를 배우실겁니다. 내외부 팀 구성 및 본인의 팀 내 팀원들, 비지니스, 개발 기술스택. 쿠팡처럼 비지니스가 방대한 회사를 가셨다면 당장 그것만 이해하는데 1여년을 다 사용해야할수도 있지만, <strong>틈틈히 개인의 주력 언어, 프레임워크를 좀 더 끈질기게 공부하신다면 좋은 기회가 왔을때 더 잘 캐치하여 성과를 올릴 수 있으실겁니다.</strong></p>
<p>혹자는 2~3년 세상에 난 없는 사람이라고 생각하면서 끈기있게 공부에 전력을 쏟으면 더 빠른 시간안에 시니어가 될 수 있다곤 하지만, 그렇게 추천드리긴 인간적으로 어렵다고 생각됩니다. 이러한 이유로 오타쿠 혹은 코딩/공부를 미친듯이 좋아하는 분들이 천재 개발자가 되는것이라 생각합니다. 결국엔 공부의 총량이 결정하는 셈입니다.</p>
<hr>
<h3 id="코드리뷰는-필수"><a href="#코드리뷰는-필수" class="headerlink" title="코드리뷰는 필수"></a>코드리뷰는 필수</h3><p><strong>코드리뷰가 매우 활성화되어있는 회사로 가는것을 추천드립니다. 적어도 한명의 사수가 꾸준히 코드리뷰를 해줄 수 있는 기업에서 일하는것이 좋습니다.</strong> 멘토-멘티 문화가 바로잡혀있다면 정말 최고입니다. <strong>한줄의 코드에는 그렇게 작성한 수많은 이유들이 있습니다.</strong> 주니어 개발자들은 이걸 왜 이렇게 개발하였는지 알기위해서 몇달을 공부해야하지만, 대로 된 멘토가 있다면 일주일에 모든 이유를 배울 수 있습니다. 물론 그 지혜는 꼭 메모해놓는것이 필요합니다. <strong>그런 문화가 없다면 동기들과 혹은 스터디를 통해 서로의 코드와 지식을 나누고 리뷰하는 모임을 만드는것이 좋습니다.</strong> 회사 동기들은 대외비인 회사 내부 코드들을 리뷰해줄수있다는 장점이 있고, 스터디를 통해서는 지정한 언어/프레임워크를 다양한 시각에서 토론해볼 수 있다는 장점이 있습니다. 비슷한 이유로 개발자 모임같은 대외 활동을 늘리는것도 시니어 분들에 의해 많이 추천됩니다.</p>
<hr>
<h3 id="커뮤니케이션-능력"><a href="#커뮤니케이션-능력" class="headerlink" title="커뮤니케이션 능력"></a>커뮤니케이션 능력</h3><p>사람들을 대하지 않는다는 비대면의 특성때문에 전 개발자를 선택하였었지만, <strong>흔히 아싸의 이미지를 갖는 개발자의 이미지와는 달리 결국 개발자는 사람을 대하는 직업입니다.</strong> 실제로 매체에서 접하는 비사회적인 nerd 들은 본인의 역량은 굉장히 뛰어날지 모르겠지만, 회사는 팀별로 설정된 목표를 가지고 함께 나아가는 곳이기에 협업과 커뮤니케이션 능력이 없다면 활용불가능한 자원에 불가합니다. 신입 개발자로써 두 분야의 사람을 접하게 될텐데 <strong>비지니스 분야</strong>, <strong>디자인 분야</strong>입니다. 이들과는 (1) 요구사항과 (2) 개발 한계에 대해 이야기할일이 많을것입니다. 또한 같은 분야의 개발자들과도 (1) 코드에 대한 리뷰/이유 설명과 (2) 정보 교환을 위해서도 커뮤니케이션은 필수입니다. 타인의 의견을 항상 경청, 존중해야할줄 알아야하며 내 근거에 대해서 조리있게 설명할 줄 알아야합니다.</p>
<hr>
<p>사실 처음에는 풀스택 개발자가 되기위해서 알아야할 기본적인 <strong>프론트엔드, 백엔드, 보안, 네트워크, 인프라</strong>에 대한 기술적인 내용들을 이야기하고 싶었습니다. 하지만 워낙 양이 방대하기 때문에 이건 앞으로 블로그글이나 오프라인으로 스터디를 통해 전달해야할거같습니다.</p>
<p>벌써 3년 반이란 세월이 지났지만 아직도 항상 부족함을 느끼며 공부하고 있기 때문에 이런 조언글을 쓰는게 적합한가 싶기도합니다. 신입때 내게 아쉬웠던 점들을 풀어쓴 글이 이제 막 신입으로 들어오는 후배나 개발직을 준비하는 분들에게 도움이 될것이라 생각합니다. 짧은 시간에 작성한것이라 부족함이 많을 수 있음에도 끝까지 읽어주셔서 감사합니다. :) 모든 개발자 분들 화이팅하셨으면 좋겠고 언젠간 좋은 위치에서 만나뵈면 좋을것같습니다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2021-02-07</div></span><span class="level-item"><a class="link-muted" href="/categories/Workplace/">Workplace</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/07/how-to-debug-hexo-using-vscode/">VSCode 에서 Hexo 디버깅 하는 방법</a></h1><div class="content"><h1 id="Hexo-테마-커스터마이징"><a href="#Hexo-테마-커스터마이징" class="headerlink" title="Hexo 테마 커스터마이징"></a>Hexo 테마 커스터마이징</h1><p>hexo 에서 원하는 테마를 선택하더라도 수정하고 싶은 부분들이 있을 수 있습니다. 아무리 테마에서 yaml 기반의 config 를 제공한다고 하더라도, 더 세밀한 부분까지 원하는대로 바꾸고싶다면 테마 코드를 직접 수정해야합니다. Hexo 설치형 블로그를 시작하면서 제가 선택했던 Icarus 테마는 크게 두가지 타입의 코드로 나뉘어져있습니다.</p>
<ul>
<li><strong>.styl</strong> : bulma 를 기반으로한 CSS 설정들이 있습니다.</li>
<li><strong>.jsx</strong> : .md 로 작성한 글들을 페이지에 어떻게 렌더링할지 정의되어있습니다.</li>
</ul>
<h2 id="styl-커스터마이징"><a href="#styl-커스터마이징" class="headerlink" title=".styl 커스터마이징"></a>.styl 커스터마이징</h2><p>너비, 높이, 폰트사이즈, 색깔등의 설정은 .styl 코드에서 설정하면 되며, 브라우저에서 페이지 각 요소의 CSS 설정들을 분석하여 그에 해당하는 설정이 있다면 값을 수정하고, 없다면 bulma 의 설정을 그대로 사용하는것이므로 오버라이딩을 위해 원하는 설정을 추가해줍니다.</p>
<center><img src="/2021/02/07/how-to-debug-hexo-using-vscode/debugging-styl.png" class=""></center>

<h2 id="jsx-커스터마이징"><a href="#jsx-커스터마이징" class="headerlink" title=".jsx 커스터마이징"></a>.jsx 커스터마이징</h2><p>글이나 위젯을 페이지에 렌더링 하는 부분은 .jsx 코드에서 설정하면됩니다. 화면에 어떻게 렌더링되는지, 내가 수정한 코드가 제대로 동작하는지 알기위해 디버깅을 필요로합니다. hexo 블로그 운영은 VSCode 를 통해 하고있어서 VSCode 에서 hexo 를 디버깅하고 있습니다.</p>
<center><img src="/2021/02/07/how-to-debug-hexo-using-vscode/debugging-jsx.png" class=""></center>

<h1 id="디버깅-설정"><a href="#디버깅-설정" class="headerlink" title="디버깅 설정"></a>디버깅 설정</h1><p>VSCode 의 디버깅 설정은 디버깅 창에서 RUN 우측 디버깅 리스트에서 <code>Add Configuration...</code> 를 통해 가능합니다.</p>
<center><img src="/2021/02/07/how-to-debug-hexo-using-vscode/vscode-add-configuration.png" class=""></center>

<p><code>Add Configuration...</code> 선택하게되면 현재 프로젝트 디렉토리에서 <code>.vscode</code> 라는 디렉토리 한개와 그 안에 <code>launch.json</code> 파일 하나를 생성하고, 해당 파일로 이동하여 어떤 설정을 추가할지 아래와 같이 리스트를 보여줍니다.</p>
<center><img src="/2021/02/07/how-to-debug-hexo-using-vscode/vscode-add-configuration-options.png" class=""></center>

<p>리스트에서 <code>Node.js: Launch Program</code>을 선택하면 설정이 한개 추가되는데,</p>
<center><img src="/2021/02/07/how-to-debug-hexo-using-vscode/node-launch-program.png" class=""></center>

<p>아래와 같이 수정 입력하면 됩니다.</p>
<figure class="highlight json"><figcaption><span>launch.json</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.2.0&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;configurations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">&quot;type&quot;</span>: <span class="string">&quot;node&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;request&quot;</span>: <span class="string">&quot;launch&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;Hexo Debugging&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;program&quot;</span>: <span class="string">&quot;$&#123;workspaceFolder&#125;/node_modules/hexo-cli/bin/hexo&quot;</span>,</span><br><span class="line">            <span class="attr">&quot;args&quot;</span>: [</span><br><span class="line">                <span class="string">&quot;server&quot;</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>로컬에 살행한 <code>hexo server</code> 에 대한 디버깅이기 때문에 타켓 프로그램은 <code>hexo-cli</code> 의 <code>bin/hexo</code> 이며, <code>args</code> 에 <code>server</code> 가 들어가는것을 보실 수 있습니다. 이제 디버깅을 하면서 즐겁게 나만의 커스텀 테마를 만드시면 됩니다. 더 나아가서 그렇게 만든 나만의 테마를 사람들과 공유할수도, 이미 있는 테마에 git contributor 로 확장된 기능을 추가할수도 있을것입니다.</p>
<hr>
<ol>
<li><a target="_blank" rel="noopener" href="https://gary5496.github.io/2018/03/nodejs-debugging/">https://gary5496.github.io/2018/03/nodejs-debugging/</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/57125171/how-to-debug-inspect-hexo-blog">https://stackoverflow.com/questions/57125171/how-to-debug-inspect-hexo-blog</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2021-02-02</div></span><span class="level-item"><a class="link-muted" href="/categories/Workplace/">Workplace</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/">Hexo, Icarus 새 버전으로 마이그레이션 및 커스터마이징</a></h1><div class="content"><h1 id="21년-첫-블로그-글-발행시-오류"><a href="#21년-첫-블로그-글-발행시-오류" class="headerlink" title="21년 첫 블로그 글 발행시 오류"></a>21년 첫 블로그 글 발행시 오류</h1><p>업무를 하면서 정말 많은 것들을 경험하고, 배우지만 정작 시간을 내서 정리하여 어딘가에 작성해놓으지 않으면 기억이나지 않더군요. 사내 위키를 잘 활용했었는데, 아무래도 더 많은 분들과 정보 및 의견을 공유하고 싶어서 블로그에 다시 글을 올리려했습니다. 얼마전에 겪었던 이슈에 관련된 글을 hexo 로 작성하여 <code>hexo g -d</code> 를 통해 발행하려하니 갑자기 오류가 발생했습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer.</span><br><span class="line">Received an instance of Object at copyFile</span><br></pre></td></tr></table></figure>
<p>구글링을 해보니 <strong>node 버전을 Downgrade</strong> 하여야하며, 현재 <strong>hexo 5.0.0 버전 이후로 픽스되었다</strong>는 스레드<a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues/4263">^1</a>를 찾았습니다. 생각해보니 작년말에 개발 공부를 위해 라이브러리나 프레임워크 버전들을 일괄적으로 다 올렸었습니다. 그중에 node.js 가 15 버전으로 업데이트 되어있었습니다. node.js 최신 버전을 아무래도 글로벌로 업데이트하였어서 hexo 에서 npm 동작시 충돌이 일어나는것같습니다.</p>
<h1 id="Hexo-최신-버전-마이그레이션"><a href="#Hexo-최신-버전-마이그레이션" class="headerlink" title="Hexo 최신 버전 마이그레이션"></a>Hexo 최신 버전 마이그레이션</h1><p>사용중이던 버전은 <code>Hexo 3.8.0 / Icarus 2.3.0</code> 인데 확인해본 최신 버전은 <code>Hexo 5.3.0 / Icarus 4.1.1</code> 이었습니다. Hexo 먼저 버전업을 위해서 <strong>package.json</strong> 에 기존 패키지들을 모두 지우고 hexo 버전을 <code>5.3.0</code> 버전으로 바꾸었습니다. <code>npm install</code> 수행 후 깨지는 패키지들을 일일히 넣어주기 귀찮아서, 새 디렉토리에서 <code>hexo init</code> 하여 자동 생성된 <strong>package.json</strong> 을 참조했습니다.</p>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/version-change-log.png" class=""></center>

<h1 id="최신-Hexo-와-구-Icarus-충돌"><a href="#최신-Hexo-와-구-Icarus-충돌" class="headerlink" title="최신 Hexo 와 구 Icarus 충돌"></a>최신 Hexo 와 구 Icarus 충돌</h1><p>hexo 버전 업데이트 후 <code>hexo server</code> 로 로컬에 페이지를 띄워보니 <strong>icarus 테마 파일에서 계속해서 특정 변수를 찾을 수 없음 등의 오류</strong>가 발생하였습니다. 구글링하니 이 또한 버전문제로 파악되어 <strong>기존의 icarus 테마의 커스터마이징 설정 <code>_config.yml</code> 만을 백업한 채 모두 지우고</strong> icarus 를 최신버전으로 (1) npm install 이 아닌 <strong>(2) git submodule</strong> 을 통해 (커스터마이징을 위해) 설치하였습니다. 다시 실행하니 <strong>jsx 코드만 덩그러니 노출되는 문제</strong>가 발생하였는데 jsx 라서 <strong>react.js</strong> 인줄알았더니 <strong>inferno.js</strong> 로 개발되어있어서 해당 라이브러리를 설치하여 해결하었습니다.</p>
<h1 id="Icarus-JSX-커스터마이징"><a href="#Icarus-JSX-커스터마이징" class="headerlink" title="Icarus JSX 커스터마이징"></a>Icarus JSX 커스터마이징</h1><p>어떤 테마든 수정을 해야하는 깐깐한 성격탓에 예전 icarus 테마는 ejs 코드를 분석해서 커스터마이징을 따로 하였었습니다. <strong>예전엔 ejs-based 였던 icarus 가 이젠 jsx-based 로 되어서, 이전 커스터마이징 코드를 그대로 사용할 순 없고, 또 다시 분석해서 수정해야했습니다.</strong> 프론트 개발을 쭉 react.js 로 해왔었고 icarus 개발 프레임워크인 inferno.js 도 react-like 를 표방하는만큼 디버깅만 할 줄 알면 크게 어렵진 않을것같았고, 실제로도 그랬습니다. 다만, icarus 프로젝트가 jsx 로 변환되면서 과거에 난잡했던 ejs 구조에서 컴포넌트 단위로 모듈화가 잘되어졌기 때문에 <strong>페이지마다 렌더링을 다르게해야하는 부분은 공통 컴포넌트에 예외 조건을 넣는 방식</strong>으로 처리해야했습니다. 아래 커스터마이징한 코드들을 보시면 이해가 되실겁니다.</p>
<h2 id="VSCode-를-통한-Hexo-디버깅"><a href="#VSCode-를-통한-Hexo-디버깅" class="headerlink" title="VSCode 를 통한 Hexo 디버깅"></a>VSCode 를 통한 Hexo 디버깅</h2><p>테마를 수정하기 위해서는 가장 먼저 hexo, icarus jsx 들이 페이지로 어떻게 렌더링 되는지 알아야합니다. 로컬에서 hexo 테스트를 위해 실행하는 <code>hexo server</code> 명령어는 hexo-cli 에 정의되어있는 npm 스크립트를 실행한것입니다. 테마 설정을 바꾸거나 글을 수정하면 바로 로컬 페이지에 적용이되는데 이는 npm 를 통해 동적으로 렌더링하고 있기 때문입니다. 저는 icarus 테마가 어떻게 동작하는지 이해하고, 수정한 제 코드가 제대로 동작하는지 확인하기 위해 VSCode 를 통해 디버그를 진행하였습니다. VSCode 에서 디버깅하는 방법은 해당 글 <a href="/2021/02/07/how-to-debug-hexo-using-vscode/">VSCode 에서 Hexo 디버깅 하는 방법</a>에서 잘 설명해놓았으니 참고하시면 됩니다.</p>
<h2 id="네비게이션바-로고"><a href="#네비게이션바-로고" class="headerlink" title="네비게이션바 로고"></a>네비게이션바 로고</h2><p>제일 상단의 네비게이션바에 기본적으로는 로고 이미지를 올리도록 설정되어있지만, 해당 블로그를 표현할 수 있는 단어로 치환 및 폰트 사이즈를 설정하였습니다.</p>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/named-logo-navbar.png" class=""></center>

<figure class="highlight yaml"><figcaption><span>_config.icarus.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Path or URL to the website&#x27;s logo</span></span><br><span class="line"><span class="attr">logo:</span></span><br><span class="line">    <span class="attr">text:</span> <span class="string">Crucian</span> <span class="string">Carp</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><figcaption><span>include/style/navbar.styl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.navbar-logo</span></span><br><span class="line">    <span class="string">img</span></span><br><span class="line">        <span class="attr">max-height:</span> <span class="string">$logo-height</span></span><br><span class="line">    <span class="attr">font-size:</span> <span class="number">1.</span><span class="string">4rem</span></span><br></pre></td></tr></table></figure>
<h2 id="좌측-위젯-프로필-재설정"><a href="#좌측-위젯-프로필-재설정" class="headerlink" title="좌측 위젯 - 프로필 재설정"></a>좌측 위젯 - 프로필 재설정</h2><p>본 블로그에서는 웹 검색에 이점을 버리더라도 글의 구성을 제일 심플하게 하고싶었기 때문에 Tag 를 모두 사용하지 않습니다. 좌측 위젯에 프로필에서 <strong>Post 개수</strong>와 <strong>Category 개수</strong>만 보여주도록 <strong>Tag 개수는 표기하지 않도록 코드를 삭제</strong>하였습니다.</p>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/tag-removed-profile.png" class=""></center>

<figure class="highlight jsx"><figcaption><span>layout/widget/profile.jsx (아래 코드 모두 삭제)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;level-item has-text-centered is-marginless&quot;</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;heading&quot;</span>&gt;&#123;counter.tag.title&#125;&lt;/p&gt;</span><br><span class="line">        &lt;a href=&#123;counter.tag.url&#125;&gt;</span><br><span class="line">            &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;title&quot;</span>&gt;&#123;counter.tag.count&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>layout/widget/profile.jsx (아래 코드 모두 삭제)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tag: &#123;</span><br><span class="line">    count: tagCount,</span><br><span class="line">    title: _p(<span class="string">&#x27;common.tag&#x27;</span>, tagCount),</span><br><span class="line">    url: url_for(<span class="string">&#x27;/tags&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="포스트-상단-시간포맷-변경"><a href="#포스트-상단-시간포맷-변경" class="headerlink" title="포스트 상단 시간포맷 변경"></a>포스트 상단 시간포맷 변경</h2><p>icarus 테마는 기본적으로 포스트 상단에 <strong>글 최초 작성 이후 얼마나 지났는지</strong>, <strong>업데이트 후 얼마나 지났는지</strong> 표기해주는데, 개인적으로는 과거 네이버같은 WYSIWYG 블로그에서 표기해주는 포스트 <strong>최초 작성일을 날짜 형태</strong>로 보는것을 선호해서 이 또한 바꿔주었습니다.</p>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/erased-elapsed-time.png" class=""></center>

<figure class="highlight jsx"><figcaption><span>layout/common/article.jsx (time 을 div 로 변경 및 Update Date 삭제)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;level-left&quot;</span>&gt;</span><br><span class="line">    &#123;<span class="comment">/* Creation Date */</span>&#125;</span><br><span class="line">    &#123;page.date &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;level-item&quot;</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="xml">        __html: _p(`<span class="tag">&lt;<span class="name">div</span>&gt;</span>$&#123;date(page.date)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`)</span></span><br><span class="line"><span class="xml">    &#125;&#125;&gt;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">    &#123;<span class="comment">/* author */</span>&#125;</span><br><span class="line">    &#123;page.author ? <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;level-item&quot;</span>&gt;</span> &#123;page.author&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> : <span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="폰트-변경"><a href="#폰트-변경" class="headerlink" title="폰트 변경"></a>폰트 변경</h2><p>폰트는 hexo 블로그 처음 시작할때 글들을 모두 한글로 작성할것이라 자간 간격이 아주 조금은 벌어져있는것이 가독성이 좋다고 판단하여 hexo 사용 처음부터 사용해왔던 나눔고딕 폰트를 계속 사용하기로 했습니다.</p>
<figure class="highlight jsx"><figcaption><span>include/style/base.styl ('Nanum Gothic' 폰트 추가 및 기존 미사용 폰트 삭제)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$family-sans-serif ?= <span class="string">&#x27;Ubuntu&#x27;</span>, <span class="string">&#x27;Nanum Gothic&#x27;</span>, sans-serif</span><br><span class="line">$family-code ?= <span class="string">&#x27;Source Code Pro&#x27;</span>, monospace, <span class="string">&#x27;Microsoft YaHei&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="위젯-amp-포스트-너비-재설정"><a href="#위젯-amp-포스트-너비-재설정" class="headerlink" title="위젯 &amp; 포스트 너비 재설정"></a>위젯 &amp; 포스트 너비 재설정</h2><p><strong>icarus 에서 제공하는 위젯은 (1) 우측, (2) 좌측</strong>이 있는데 이 둘을 모두 사용하면 중간에 포스트 너비가 짧아져 가독성을 떨어트릴수있다고 판단했습니다. <strong>좌측 위젯만 사용</strong>했음에도 위젯 너비가 포스트 너비에 비해 길다고 생각하여 조율해주었습니다.</p>
<ul>
<li><strong>4(좌측 위젯) + 8(글) = 12</strong></li>
</ul>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/previous-width.png" class=""></center>

<ul>
<li><strong>3(좌측 위젯) + 9(글) = 12</strong></li>
</ul>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/newest-width.png" class=""></center>

<p>icarus 의 너비 분배는 <strong>bulma css 12 셀 규칙</strong>을 사용합니다. 기존엔 아래와 같았습니다.</p>
<ul>
<li>4(좌측 위젯) + 8(글) = <strong>12</strong></li>
<li>8(글) + 4(우측 위젯) = <strong>12</strong></li>
<li>3(좌측 위젯) + 6(글) + 3(우측 위젯) = <strong>12</strong></li>
</ul>
<p>여기서 본 블로그는 위젯을 포스트의 가독성을 위해 좌측 하나만 사용할것이기 때문에</p>
<ul>
<li>3(좌측 위젯) + 9(글) = <strong>12</strong></li>
<li>9(글) + 3(우측 위젯) = <strong>12</strong></li>
</ul>
<p>포스트의 너비는 <strong>8</strong>에서 <strong>9</strong>으로 위젯은 <strong>4</strong>에서 <strong>3</strong>으로 재정의하였습니다.</p>
<figure class="highlight jsx"><figcaption><span>layout/common/widgets.jsx (위젯 하나의 너비 4 -> 3)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColumnSizeClass</span>(<span class="params">columnCount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (columnCount) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;is-3-tablet is-3-desktop is-3-widescreen&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;is-3-tablet is-3-desktop is-2-widescreen&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>layout/layout.js (포스트 너비 8 -> 9)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;columns&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=&#123;classname(&#123;</span><br><span class="line">        column: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;order-2&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;column-main&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;is-12&#x27;</span>: columnCount === <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;is-9-tablet is-9-desktop is-9-widescreen&#x27;</span>: columnCount === <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;is-9-tablet is-9-desktop is-8-widescreen&#x27;</span>: columnCount === <span class="number">3</span></span><br><span class="line">    &#125;)&#125; dangerouslySetInnerHTML=&#123;&#123; <span class="attr">__html</span>: body &#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;Widgets site=&#123;site&#125; config=&#123;config&#125; helper=&#123;helper&#125; page=&#123;page&#125; position=&#123;<span class="string">&#x27;left&#x27;</span>&#125; /&gt;</span><br><span class="line">    &lt;Widgets site=&#123;site&#125; config=&#123;config&#125; helper=&#123;helper&#125; page=&#123;page&#125; position=&#123;<span class="string">&#x27;right&#x27;</span>&#125; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="About-내-위젯-플러그인-제거"><a href="#About-내-위젯-플러그인-제거" class="headerlink" title="About 내 위젯, 플러그인 제거"></a>About 내 위젯, 플러그인 제거</h2><p>상단 네비게이션바에서 About 을 클릭하시면 저에 대한 개략적인 정보를 아실수있습니다. 또한 개인 Resume 페이지를 따로 만들어서 굳이 Google docs 나 Linkedin 으로 접속하지 않아도 저의 이력을 한눈에 볼 수 있도록 Resume 페이지도 따로 마련해두었습니다.</p>
<p>구 icarus 의 ejs 시절에는 About, Resume 페이지 모두 각각 따로 ejs 페이지가 있었기때문에 해당 페이지만 수정하면 되었었지만, <strong>새 icarus 의 jsx 에서는 포스트에 대한 컴포넌트가 about, resume 등 모든 페이지의 기본 컴포넌트로 사용</strong>되고있었습니다. 정적 리스트를 만들어서 특정 페이지에 대해서만 위젯과 플러그인을 표시하지 않도록 필터링 하는 로직을 넣었습니다.</p>
<ul>
<li>위젯도 위젯이지만 buy me a coffee 가 킬링포인트입니다.</li>
</ul>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/previous-about-page.png" class=""></center>

<ul>
<li>About 페이지는 저를 표현하는것만으로 충분합니다.</li>
</ul>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/newest-about-page.png" class=""></center>

<figure class="highlight jsx"><figcaption><span>layout/layout.jsx (About, Resume 여부 조건)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isAboutPage = [ <span class="string">&quot;about/index.html&quot;</span>, <span class="string">&quot;resume/index.html&quot;</span> ].includes(page.path);</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>layout/layout.jsx (좌측, 우측 위젯에 About, Resume 여부 조건 추가)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Head site=&#123;site&#125; config=&#123;config&#125; helper=&#123;helper&#125; page=&#123;page&#125; /&gt;</span><br><span class="line">&lt;body <span class="class"><span class="keyword">class</span></span>=&#123;<span class="string">`is-<span class="subst">$&#123;columnCount&#125;</span>-column`</span>&#125;&gt;</span><br><span class="line">    &lt;Navbar config=&#123;config&#125; helper=&#123;helper&#125; page=&#123;page&#125; /&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;section&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;columns&quot;</span>&gt;</span><br><span class="line">                &lt;div <span class="class"><span class="keyword">class</span></span>=&#123;classname(&#123;</span><br><span class="line">                    column: <span class="literal">true</span>,</span><br><span class="line">                    <span class="string">&#x27;order-2&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="string">&#x27;column-main&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="string">&#x27;is-12&#x27;</span>: columnCount === <span class="number">1</span>,</span><br><span class="line">                    <span class="string">&#x27;is-9-tablet is-9-desktop is-9-widescreen&#x27;</span>: columnCount === <span class="number">2</span>,</span><br><span class="line">                    <span class="string">&#x27;is-9-tablet is-9-desktop is-8-widescreen&#x27;</span>: columnCount === <span class="number">3</span></span><br><span class="line">                &#125;)&#125; dangerouslySetInnerHTML=&#123;&#123; <span class="attr">__html</span>: body &#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">                &#123;!isAboutPage &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Widgets</span> <span class="attr">site</span>=<span class="string">&#123;site&#125;</span> <span class="attr">config</span>=<span class="string">&#123;config&#125;</span> <span class="attr">helper</span>=<span class="string">&#123;helper&#125;</span> <span class="attr">page</span>=<span class="string">&#123;page&#125;</span> <span class="attr">position</span>=<span class="string">&#123;</span>&#x27;<span class="attr">left</span>&#x27;&#125; /&gt;</span></span>&#125;</span><br><span class="line">                &#123;!isAboutPage &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Widgets</span> <span class="attr">site</span>=<span class="string">&#123;site&#125;</span> <span class="attr">config</span>=<span class="string">&#123;config&#125;</span> <span class="attr">helper</span>=<span class="string">&#123;helper&#125;</span> <span class="attr">page</span>=<span class="string">&#123;page&#125;</span> <span class="attr">position</span>=<span class="string">&#123;</span>&#x27;<span class="attr">right</span>&#x27;&#125; /&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>layout/common/article.jsx (About, Resume 여부 조건)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isAboutPage = [ <span class="string">&quot;about/index.html&quot;</span>, <span class="string">&quot;resume/index.html&quot;</span> ].includes(page.path);</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>layout/common/article.jsx (포스트 하단 모든 플러그인에 About, Resume 여부 조건 추가)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/* Licensing block */</span>&#125;</span><br><span class="line">&#123;!isAboutPage &amp;&amp; !index &amp;&amp; article &amp;&amp; article.licenses &amp;&amp; <span class="built_in">Object</span>.keys(article.licenses)</span><br><span class="line">    ? <span class="xml"><span class="tag">&lt;<span class="name">ArticleLicensing.Cacheable</span> <span class="attr">page</span>=<span class="string">&#123;page&#125;</span> <span class="attr">config</span>=<span class="string">&#123;config&#125;</span> <span class="attr">helper</span>=<span class="string">&#123;helper&#125;</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* Tags */</span>&#125;</span><br><span class="line">&#123;!isAboutPage &amp;&amp; !index &amp;&amp; page.tags &amp;&amp; page.tags.length ? <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-tags is-size-7 mb-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;mr-2&quot;</span>&gt;</span>#<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;page.tags.map(tag =&gt; &#123;</span></span><br><span class="line"><span class="xml">        return <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;link-muted mr-2&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;tag&quot;</span> <span class="attr">href</span>=<span class="string">&#123;url_for(tag.path)&#125;</span>&gt;</span>&#123;tag.name&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;)&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* &quot;Read more&quot; button */</span>&#125;</span><br><span class="line">&#123;!isAboutPage &amp;&amp; index &amp;&amp; page.excerpt ? <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;article-more button is-small is-size-7&quot;</span> <span class="attr">href</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">url_for</span>(<span class="attr">page.link</span> || <span class="attr">page.path</span>)&#125;#<span class="attr">more</span>`&#125;&gt;</span>&#123;__(&#x27;article.more&#x27;)&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* Share button */</span>&#125;</span><br><span class="line">&#123;!isAboutPage &amp;&amp; !index ? <span class="xml"><span class="tag">&lt;<span class="name">Share</span> <span class="attr">config</span>=<span class="string">&#123;config&#125;</span> <span class="attr">page</span>=<span class="string">&#123;page&#125;</span> <span class="attr">helper</span>=<span class="string">&#123;helper&#125;</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* Donate button */</span>&#125;</span><br><span class="line">&#123;!isAboutPage &amp;&amp; !index ? <span class="xml"><span class="tag">&lt;<span class="name">Donates</span> <span class="attr">config</span>=<span class="string">&#123;config&#125;</span> <span class="attr">helper</span>=<span class="string">&#123;helper&#125;</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* Post navigation */</span>&#125;</span><br><span class="line">&#123;!isAboutPage &amp;&amp; !index &amp;&amp; (page.prev || page.next) ? <span class="xml"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;post-navigation mt-4 level is-mobile&quot;</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">&#123;/* Comment */&#125;</span></span><br><span class="line"><span class="xml">&#123;!isAboutPage &amp;&amp; !index ? <span class="tag">&lt;<span class="name">Comment</span> <span class="attr">config</span>=<span class="string">&#123;config&#125;</span> <span class="attr">page</span>=<span class="string">&#123;page&#125;</span> <span class="attr">helper</span>=<span class="string">&#123;helper&#125;</span> /&gt;</span> : null&#125;</span></span><br></pre></td></tr></table></figure>
<p>지금 보고 계신 이 블로그와 본 포스트는 위 요소들을 모두 커스터마이징한 Icarus 테마로 구성된것입니다. 몇년전에 hexo 나 icarus 를 적용하셨었고, 마이그레이션을 앞두고 계시거나 커스텀하게 수정하는걸 원하시는 분께 본 글이 도움이 되셨으면 좋겠습니다. 이후로 CSS, JSX 에 자잘한 수정이 있을순 있으나 따로 다 업데이트하진 않으려합니다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2021-01-31</div></span><span class="level-item"><a class="link-muted" href="/categories/Troubleshooting/">Troubleshooting</a><span> / </span><a class="link-muted" href="/categories/Troubleshooting/Java-8/">Java 8</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/31/problems-when-using-parallel-stream-with-hash-map/">ParallelStream 과 HashMap 의 Rehashing 이슈</a></h1><div class="content"><h1 id="Single-SQL-Query-gt-MSA-APIs-전환-시-성능-저하"><a href="#Single-SQL-Query-gt-MSA-APIs-전환-시-성능-저하" class="headerlink" title="Single SQL Query -&gt; MSA APIs 전환 시 성능 저하"></a>Single SQL Query -&gt; MSA APIs 전환 시 성능 저하</h1><p>최근 Monolithic Architecture 구조의 레가시 시스템을 MSA 구조로 바꾸는 리플랫폼을 진행하였었습니다. 기존 레가시 시스템은 <strong>여러 서브도메인에 해당하는 테이블들이 단일 쿼리에 수많은 Join 으로 연결되어있어서 “단 하나의 쿼리”를 통해 결과를 얻을 수 있어 성능은 매우 좋았지만, 재사용성 및 유지보수성에 있어서는 최악의 구조</strong>를 갖고있었습니다. <strong>예약, 결제, 정산, 상품 등 각 서브도메인들을 서비스들로 나누어서 “다수의 API 호출”들로 요청을 처리하도록 변환하니 재사용성 및 유지보수성은 올라갔지만</strong> SQL Join 을 사용하던 것을 API 로 바꾸다보니 <strong>수행의 파편화 및 네트워크 시간에 의해 성능이 저하</strong>되어 이 해결이 또 다른 리플랫폼의 챌린지 포인트였습니다.</p>
<h1 id="Java-Stream-gt-ParallelStream-을-통한-성능-개선"><a href="#Java-Stream-gt-ParallelStream-을-통한-성능-개선" class="headerlink" title="Java Stream -&gt; ParallelStream 을 통한 성능 개선"></a>Java Stream -&gt; ParallelStream 을 통한 성능 개선</h1><p>단일 쿼리에서는 Join 하나만으로 여러 테이블에 분산된 정보를 하나의 Dto 로 모아서 반환할 수 있습니다. 하지만 각 테이블들을 도메인 기반으로 예약 서비스, 계정 서비스 등으로 나눈다면 <strong>간단했던 Join 문은 각각 테이블에 해당하는 다수의 API들을 호출한 뒤, 하나의 Dto 로 Id 기반으로 합치는 작업을 필요</strong>로 하게됩니다. 이런 작업에서 Id 기반의 Join 을 프로그램으로 구현할때 저는 개인적으로 성능을 위해 <strong>Hash Join</strong> 전략과 유사하게 작성하게 되는데 이는 각 API 결과의 <strong>HashMap 을 필요</strong>로 함을 뜻합니다.</p>
<p>List -&gt; HashMap 변환은 간단하지만, List 결과값이 매우 비대한 경우 <strong>각 도메인에 해당하는 테이블별로 HashMap 변환만 하더라도 몇초의 시간을 소비</strong>하기 때문에 이 시간을 줄이고자 <code>Stream</code> 에서 <code>ParallelStream</code> 로 변환하는 작업을 거쳤습니다. 이실직고하자면 빠르다는 사실 하나만으로 주니어였던 제겐 왜 안써? 싶은 존재였습니다. 성능은 굉장히 빨라졌고, 긴 시간동안 잘 동작하는 듯 했지만 예상치 못했던 몇 이슈로 다가오게 됩니다.</p>
<h1 id="ParallelStream"><a href="#ParallelStream" class="headerlink" title="ParallelStream"></a>ParallelStream</h1><p>ParallelStream 는 Java 8 에서 도입된 <strong>멀티스레드 프로그래밍을 매우 쉽게 활용할 수 있게 해주는 도구</strong>입니다. 학부때도 <strong>멀티스레드</strong>가 제일 복잡하고 힘들었었는데, 이걸 단 하나의 코드로 쉽게 사용하게 해준다니 스레드 관리가 불편했던 저에겐 굉장히 매력적으로 다가왔습니다. 또한 타 웹페이지에서 고전적 for-each, stream, parallelStream 성능 비교를 보면 당연하겠지만 말도 안되게 빠른 성능을 제공해주는걸 알 수 있습니다.</p>
<h2 id="ForkJoinPool-ParallelStream-의-Thread-관리"><a href="#ForkJoinPool-ParallelStream-의-Thread-관리" class="headerlink" title="ForkJoinPool: ParallelStream 의 Thread 관리"></a>ForkJoinPool: ParallelStream 의 Thread 관리</h2><p>스레드 관리가 쉬워진 이유는 기존에 Java 에서 사용하던 스레드 관리 방식을 확장한 <strong>ForkJoinPool</strong> 이라는 관리 방식을 사용하기 때문입니다. 이름과 같이 <strong>Fork + Join 을 통해 어떤 복잡한 작업도 작은 단위로 세분화하여 여러 스레드들이 나누어 작업한 뒤 완료된 결과를 하나의 결과로 합치게</strong> 되는데, 그것이 ParallelStream 의 방식이기도 합니다.</p>
<h3 id="ExecutorService-기존"><a href="#ExecutorService-기존" class="headerlink" title="ExecutorService (기존)"></a>ExecutorService (기존)</h3><ul>
<li>1개의 Queue (1: Main Queue)</li>
<li>Thread Pool 에서 쉬고있는 Thread 에게 Main Queue 의 작업(Job)을 할당</li>
</ul>
<h3 id="ForkJoinPool-신규-‘Fork’-‘Join’"><a href="#ForkJoinPool-신규-‘Fork’-‘Join’" class="headerlink" title="ForkJoinPool (신규, ‘Fork’ + ‘Join’)"></a>ForkJoinPool (신규, ‘Fork’ + ‘Join’)</h3><ul>
<li>2개의 Queue (1: Main Queue, 2: ExecutorService Queue)<ul>
<li><strong>ForkJoinPool</strong> = <strong>Queue 가 추가된</strong> ExecutorService 구현체</li>
</ul>
</li>
</ul>
<ul>
<li>Thread Pool 에서 쉬고있는 Thread 에게 Main Queue 의 작업(Job)을 할당 <strong>후 추가 프로세스가 존재</strong><ul>
<li><strong>Fork</strong>: 해당 Thread 는 할당받은 작업(Job)을 <strong>수행가능한 작은 단위의 작업들로 분할</strong></li>
<li><strong>Steal</strong>: 한 Thread 가 다수의 작업(Job) 부담을 갖게되므로 <strong>타 Thread 들이 작업을 나눠서 수행</strong></li>
<li><strong>Join</strong>: 세분화되어 여러 Thread 에서 <strong>수행완료된 작업 결과는 쪼개어졌던 Thread 에서 다시 합쳐 반환</strong></li>
</ul>
</li>
</ul>
<p>ParallelStream 는 <strong>Spliterator</strong> 와 <strong>ForkJoinPool</strong> 기반[^1]으로 Fork + Join 을 통해 작업을 작은 단위로 분할한 뒤 실시간으로 어느 하나의 스레드에 작업 부담(Workload)가 몰리지 않도록 여러 Thread 들이 작은 단위의 작업들을 서로 나누어서 효율적으로 자원을 사용하게됩니다. 결과적으로는 더 빠르게 결과를 반환하게되며, <strong>ParallelStream == 성능</strong>으로 인식되는 이유입니다.</p>
<h1 id="HashMap-amp-ParallelStream-사용시-무한루프-이슈"><a href="#HashMap-amp-ParallelStream-사용시-무한루프-이슈" class="headerlink" title="HashMap &amp; ParallelStream 사용시 무한루프 이슈"></a>HashMap &amp; ParallelStream 사용시 무한루프 이슈</h1><h2 id="Rehashing"><a href="#Rehashing" class="headerlink" title="Rehashing"></a>Rehashing</h2><p>ParallelStream 을 통해 서비스 성능 개선을 이룬 뒤 많은 시간이 지나서 갑자기 해당 서버 인스턴스 CPU 가 75% 를 넘어서서 오랜시간동안 계속 내려오지 않는 온콜이 발생하였었습니다. 점유율이 오랜시간동안 75% 에서 내려오지 않자 <strong>무한 루프에 진입한것으로 보여 쓰레드 덤프를 분석해보니 parallelStream 에서 할당된 스레드에서 block 인채 멈춰있는걸 발견하였습니다.</strong></p>
<p>문제의 로직은 ParallelStream 내부에서 HashMap 의 <code>put</code> 함수를 사용한 부분이었습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Boolean&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">sampleList.parallelStream().forEach(each -&gt;</span><br><span class="line">  result.put(each.getId(), isSample)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>간단하게 생각하면 List 가 아닌 Map 이기때문에 주입되는 순서도 상관없고, 값이 잘 들어갈것처럼 보입니다. <strong>하지만 HashMap 는 Rehashing 이 있다는 정말 기초적인것을 놓친 생각이었습니다.</strong> HashMap 은 Key-Value Pair 를 주입(put)할 때 아래의 과정을 거쳐 이뤄집니다.</p>
<ol>
<li>새로 추가하는 Key 에 대한 Hash 를 생성하고</li>
<li><strong>Hash 테이블 인덱스에 for-loop 를 통해 존재여부 판단 후</strong>, 해당 Hash Key 에 포인터를 통해 Value 을 적재하게 됩니다.</li>
<li>특정 Hash Key 에 포인터로 연결된 Value 개수가 일정 수를 넘으면 <strong>Rehashing</strong> 을 통해 Hash 인덱스를 나누어 Value 들을 재적재하게 됩니다.</li>
</ol>
<h2 id="Rehashing-Race-Condition"><a href="#Rehashing-Race-Condition" class="headerlink" title="Rehashing: Race Condition"></a>Rehashing: Race Condition</h2><p>위 과정 중에 <strong>2. 새 Value 포인터로 연결</strong>과 <strong>3. Rehashing</strong>, 두 부분에서는 포인터를 변경하게 되는데 <strong>기본 HashMap 의 경우엔 이 포인터 변경 부분이 thread-safe 하지 않습니다.</strong> 따라서 다수의 스레드가 <strong>2번</strong>과 <strong>3번</strong>을 동시에 수행한다면 즉, <strong>같은 Hash 인덱스의 포인터를 변경하려 하면 문제가 발생할 수 있습니다.</strong> 두 스레드가 같은 Hash Key 에 대한 포인터들을 재설정하는 과정에서 서로 꼬여 포인트간 사이클이 발생하게 됩니다. <strong>2번</strong>, <strong>3번</strong> 모두 <code>put</code> 실행시 수행되는 로직이고, 여기서 생긴 <strong>포인터 사이클</strong>에 Hash 테이블 인덱스에 대한 for-loop 존재여부 조회가 들어서면서 무한 루프에 빠진것입니다.</p>
<p>HashMap 과 ParallelStream 를 동시에 사용시 이러한 Race Condition 으로 인한 무한 루프 문제도 있지만, 실제로 정상 수행되더라도 HashMap 에는 몇개의 Key 가 유실되는 경우도 발생합니다. 이 또한 다수의 스레드가 Hash Key 에 포인터로 Value 를 동시에 주입하면서, 몇개만 포인터가 정상할당되고 나머지는 무시되는 문제에서 발생합니다. 이로 인해 <strong>새로운 Key 를 10000 개 <code>put</code>으로 주입하였는데, 실제 HashMap 에 저장된 Key 는 10000 개보다 적은 황당한 경우도 발생합니다.</strong></p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p>Java 의 ParallelStream 내부에서 thread-safe 하지 못한 어떤 작업, 본 글에서는 HashMap 의 <code>put</code>, 을 수행하면 Race Condition 발생으로 인해 몇개의 thread 작업들이 타 thread 에 의해 무시되게 되어서 예상치 못한 결과를 얻게됩니다. HashMap 의 경우엔 아래의 이슈가 발생합니다.</p>
<ul>
<li>Hash Key 에 연결된 Value 간 포인터 사이클이 발생 후, for-loop 존재여부 조회 시 무한루프</li>
<li>10000 번 <code>put</code> 수행하더라도, 몇 Value 포인터 주입이 무시되어 결과 HashMap 사이즈가 10000 미만</li>
</ul>
<p>당시까지 ParallelStream 로 말미암아 생긴 이슈들이 많았기에, 온콜 해결을 위해서 서비스 전체 로직에서 ParallelStream 이 사용되는 부분을 모두 걷어내었었습니다. 위 문제를 해결하기 위해서는 HashMap 을 ConcurrentHashMap 으로만 바꾸는것으로도 해결이 가능합니다. 물론 ParallelStream 동작 원리는 <strong>Spliterator</strong> 와 <strong>ForkJoinPool</strong> 기반이기 때문에  Divide-and-Conquer 라는 기본 원칙인 분할(split) 과 합치는(merge) 작업에 메모리, CPU 자원 소요 비중이 커질 수 있습니다. 따라서 루프 횟수가 몇 십만, 몇 백만건까지의 유즈케이스가 존재한다면 꼭 스트레스 테스트가 필요할것 입니다.</p>
<hr>
<p>참조</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://hamait.tistory.com/612">https://hamait.tistory.com/612</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.naver.com/tmondev/220945933678">https://blog.naver.com/tmondev/220945933678</a></li>
<li><a target="_blank" rel="noopener" href="http://www.h-online.com/developer/features/The-fork-join-framework-in-Java-7-1762357.html">http://www.h-online.com/developer/features/The-fork-join-framework-in-Java-7-1762357.html</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@itugs/custom-forkjoinpool-in-java-8-parallel-stream-9090882472db">https://medium.com/@itugs/custom-forkjoinpool-in-java-8-parallel-stream-9090882472db</a></li>
<li><a target="_blank" rel="noopener" href="https://java-8-tips.readthedocs.io/en/stable/parallelization.html#conclusion">https://java-8-tips.readthedocs.io/en/stable/parallelization.html#conclusion</a></li>
</ol>
<p>[^1] <a target="_blank" rel="noopener" href="https://java-8-tips.readthedocs.io/en/stable/parallelization.html">https://java-8-tips.readthedocs.io/en/stable/parallelization.html</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2020-08-27</div></span><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Javascript/">Javascript</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/27/how-does-a-javascript-engine-work/">Javascript 엔진 개요 및 실행 과정으로 살펴보는 Hoisting 과 Closure</a></h1><div class="content"><h1 id="자바스크립트"><a href="#자바스크립트" class="headerlink" title="자바스크립트"></a>자바스크립트</h1><p>자바스크립트는 웹 페이지의 세 요소중 하나입니다.</p>
<ul>
<li><strong>HTML</strong>: 웹 페이지(문서) 포맷을 정의하는 마크업 언어</li>
<li><strong>CSS</strong>: 웹 페이지(문서)의 디자인 요소에 대한 언어</li>
<li><strong>Javascript</strong>: 웹 페이지(문서)와 사용자 사이의 interaction 이벤트에 대한 모든 처리</li>
</ul>
<p>자바스크립트는 일반 프로그래밍 언어와 동일하게 함수 선언 및 호출를 통해 바로 동기적(Synchronous)으로 실행할수도 있고, 콜백을 통해 특정 이벤트 시점에 비동기적(Synchronous)으로 수행하게 만들수도 있습니다. 실행을 위해서는 개발자가 작성한 자바스크립트 언어를 실행 가능한 언어로 변형하여 실행, 실행 순서 및 메모리를 관리하는 엔진이 필요합니다.</p>
<blockquote>
<p><strong>하나의 브라우저</strong>는 <strong>HTML/CSS 엔진</strong>과 <strong>자바스크립트 엔진</strong>으로 구성되어있습니다.</p>
</blockquote>
<p>흔히 알고 있는 Chrome, Internet Exploerer, Safari 등 다양한 웹 브라우저마다 각자 자신들만의 <strong>HTML/CSS/Javascript 엔진</strong>를 갖고 있습니다. <strong>자바스크립트 엔진</strong> 중 유명한것이라면 Chrome 브라우저와 node.js 에서 사용되고있는 V8 가 있습니다. 앞으로 설명할 <strong>자바스크립트 엔진 및 런타임</strong><a target="_blank" rel="noopener" href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf">^9</a>은 이 V8 기준으로 설명할것입니다. 잠깐 앞으로 계속 언급될 <strong>자바스크립트 엔진</strong>과 <strong>자바스크립트 런타임</strong> 용어를 확실히 짚고 넘어가겠습니다. 더 상세한 설명은 소제목 <strong>자바스크립트 엔진 및 런타임</strong> 에서 하겠습니다.</p>
<blockquote>
<p><strong>자바스크립트 런타임</strong>은 자바스크립트 동작을 위해 필요로 하는 <strong>자바스크립트 엔진</strong>을 포함한 API 및 기능의 집합입니다.<br><strong>자바스크립트 엔진</strong>은 좁은 의미로 자바스크립트 인터프리팅 역할을 전담하는것으로 Java 의 JVM 으로 이해하면 됩니다.</p>
</blockquote>
<p>예를 들면 <strong>V8 자바스크립트 엔진</strong>기반의 <strong>자바스크립트 런타임</strong>으로 우리가 사용하는 Chrome 이 동작되는것입니다.</p>
<h1 id="자바스크립트-인터프리트-언어"><a href="#자바스크립트-인터프리트-언어" class="headerlink" title="자바스크립트 = 인터프리트 언어"></a>자바스크립트 = 인터프리트 언어</h1><blockquote>
<p><strong>자바스크립트</strong>는 스크립트 언어이자 엔진을 통해 처리되는 <strong>인터프리트 언어</strong>입니다. 다만, <strong>컴파일 과정</strong>을 갖고 있습니다.</p>
</blockquote>
<p><strong>자바스크립트 엔진</strong>은 일반적인 쉘 스크립트가 한 라인씩 바로 실행되는 <strong>인터프리트 언어</strong>와는 조금 다른 실행 구조를 갖고있습니다. 먼저, 실행할 전체 함수를 실행 직전에 간단히 변수 및 함수 선언들만 스캔하는 <strong>(A) JIT 컴파일 과정</strong>을 거쳐, 그 후 <strong>(B) 수행 과정</strong>의 사이클로 실행<a target="_blank" rel="noopener" href="https://dev.to/genta/is-javascript-a-compiled-language-20mf">^5</a>됩니다. 여기서 <strong>(1) JIT 컴파일 과정</strong>은 실제 우리들이 흔히 알고있는 C++, Java 와 같은 컴파일 언어에서 중간코드를 만드는 <strong>AOT(Ahead-of-Time) 컴파일 과정</strong>과는 다릅니다.<a target="_blank" rel="noopener" href="https://dev.to/deanchalk/comment/8h32">^7</a> 자바스크립트를 인터프리트 언어라고 알고있었는데 좀 놀랍죠. 이렇게 자바스크립트 엔진에 단순히 컴파일 과정이 있다는 사실만으로 자바스크립트를 <strong>컴파일 언어</strong>로 언급하기도 합니다만 엄연히 기존 컴파일 언어의 정의와 다르고<a target="_blank" rel="noopener" href="https://gist.github.com/kad3nce/9230211#compiler-theory">^8</a>, 자바스크립트 엔진은 함수 실행 시점에 컴파일을 진행하므로 <strong>인터프리트 언어</strong>입니다.<a target="_blank" rel="noopener" href="https://dev.to/deanchalk/comment/8h32">^7</a></p>
<blockquote>
<p>자바스크립트 엔진은 <strong>(A) JIT 컴파일 과정</strong>과 <strong>(B) 수행 과정</strong> 이렇게 두 개로 나뉩니다.<br>결론적으로 <strong>자바스크립트는 컴파일 과정을 가진 인터프리트 언어</strong>로 요약할 수 있지 않을까합니다.</p>
</blockquote>
<h1 id="자바스크립트-엔진-및-런타임"><a href="#자바스크립트-엔진-및-런타임" class="headerlink" title="자바스크립트 엔진 및 런타임"></a>자바스크립트 엔진 및 런타임</h1><p><strong>자바스크립트 런타임</strong>은 크게 2 개의 구성요소로 나눠질 수 있고, 개별적으로는 5 개로 나누어 볼 수 있습니다.</p>
<ol>
<li><strong>자바스크립트 엔진</strong> = <strong>(1) Heap</strong>, <strong>(2) Stack</strong>(Call stack)</li>
<li><strong>(3) Web APIs</strong>, <strong>(4) Callback queue</strong>, <strong>(5) Event loop</strong></li>
</ol>
<p><strong>자바스크립트 엔진</strong>은 <strong>(1) Heap</strong> 그리고 <strong>(2) Stack</strong> 만을 의미하며 <strong>싱글 스레드</strong>로 모든 코드를 수행합니다.. 자바스크립트의 비동기를 학습할때 배우는 <strong>(3) Web APIs</strong>, <strong>(4) Callback queue</strong>, <strong>(5) Event loop</strong>들은 정확히는 <strong>자바스크립트 엔진</strong>의 구성요소가 아닙니다. <strong>자바스크립트 엔진</strong>이 <strong>싱글 스레드</strong>로 모든 코드를 수행한다면 동기적 실행밖에 안될텐데 어떻게 비동기를 지원한다는 것일까요? 비동기 지원을 위해 바로 자바스크립트 런타임에서 <strong>(3), (4), (5)</strong> 세 요소를 추가한것입니다.</p>
<p><strong>자바스크립트 엔진</strong>의 <strong>(2) Stack</strong> 은 일반 프로그램 언어들의 Stack 과는 다른데요. 타 프로그램 언어들은 함수 실행에 따라 Call stack 에 각 로컬 함수들의 변수 등의 Context 정보들을 다 같이 쌓습니다. 로컬 함수에만 국한된 정보들을 갖는다는 이유로 Context 를 Scope 라고도 부릅니다. 반면, <strong>자바스크립트 엔진</strong>도 Call stack 에 함수 호출 순서를 적재합니다만, 변수 및 함수 선언과 할당 정보는 Heap 에 따로 저장히여 Call Stack 에는 본 Heap 에 대한 포인터만 갖고 있습니다. 구체적으로 정리하면 아래와 같습니다.</p>
<ol>
<li><strong>자바스크립트 엔진</strong></li>
</ol>
<ul>
<li><strong>(1) Heap</strong>: 각 함수 별 <strong>선언 및 할당되는 모든 변수 및 함수를 적재</strong>하는 메모리 영역</li>
<li><strong>(2) Stack</strong>(Call Stack): 함수 실행 순서에 맞게 위 Heap 에 대한 포인터 <strong>적재 및 실행</strong></li>
</ul>
<ol start="2">
<li><strong>비동기 지원</strong></li>
</ol>
<ul>
<li><strong>(3) Web APIs</strong>: 기본 자바스크립트에 없는 DOM, ajax, setTimeout 등의 <strong>라이브러리 함수들</strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/%EC%B0%B8%EC%A1%B0/API">^10</a>. 브라우저나 OS 등에서 C++ 처럼 다양한 언어로 구현되어 제공</li>
<li><strong>(4) Callback Queue</strong>: 위 Web APIs 에서 발생한 콜백 함수들이 차곡차곡 여기에 <strong>적재</strong></li>
<li><strong>(5) Event Loop</strong>: 위 Callback Queue에 적재된 함수를 Stack 로 하나씩 옮겨서 <strong>실행되도록 하는 스레드</strong></li>
</ul>
<h1 id="자바스크립트-엔진-실행-과정"><a href="#자바스크립트-엔진-실행-과정" class="headerlink" title="자바스크립트 엔진 실행 과정"></a>자바스크립트 엔진 실행 과정</h1><blockquote>
<p>자바스크립트 엔진은 <strong>(A) JIT 컴파일 과정</strong>과 <strong>(B) 수행 과정</strong> 이렇게 두 개로 나뉩니다.</p>
</blockquote>
<h2 id="A-Compilation-Phase"><a href="#A-Compilation-Phase" class="headerlink" title="(A) Compilation Phase"></a>(A) Compilation Phase</h2><p>매 함수 실행 시 (자바스크립트 첫 실행 함수는 main() 입니다.) ASTs 생성 및 바이트코드로 변경하고 JIT 컴파일 기법(바이트코드 캐싱을 통해 불필요한 컴파일 시간을 줄이는것)을 위해 프로파일러로 함수 호출 횟수를 저장/추적합니다. 우리가 기억하면 될 것은 본 과정에서 <strong>변수의 ‘선언’</strong>(선언과 할당 중) 그리고 <strong>함수의 ‘선언’**을 **Heap 에 적재</strong>한다는것입니다.</p>
<blockquote>
<p>자바스크립트 <strong>변수의 ‘선언’**은 **var a</strong> 입니다. (<strong>a = 5</strong> 는 ‘할당(Assignment)’입니다.)</p>
</blockquote>
<blockquote>
<p>자바스크립트 <strong>함수의 ‘선언’**은 **function a()</strong> 입니다.</p>
</blockquote>
<blockquote>
<p><strong>Compilation Phase</strong>에선 <strong>변수 및 함수</strong>의 <strong>‘선언(Declaration)’**만 추출하여 **Heap 에 적재</strong>합니다.<br>변수와 함수의 선언을 자바스크립트 실행 이전에 컴파일로 저장하여 실제 실행 시 변수와 함수 선언 여부를 검색합니다.</p>
</blockquote>
<p>예를 들어 아래 자바스크립트 파일을 처음 실행하게 되면 파일 전체에 컴파일 과정을 수행하게됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line">  c = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">6</span>;</span><br><span class="line">  e = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = <span class="number">0</span>;</span><br><span class="line">    d = <span class="number">3</span>*d;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> g();</span><br><span class="line">  <span class="keyword">var</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<ol>
<li>자바스크립트 첫 실행을 위한 main() 함수의 <strong>Global Scope (window)</strong> 영역을 Heap 에 생성합니다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- </span><br><span class="line">- </span><br></pre></td></tr></table></figure></li>
<li>변수 선언 <strong>var a</strong>을 찾아서 <strong>Global Scope (window)</strong> 영역에 <strong>a</strong> 를 적재합니다.</li>
<li>변수 할당 <strong>b = 1</strong>은 할당이므로 본 영역에 <strong>b</strong> 를 적재하지 않습니다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a =</span><br><span class="line">- </span><br></pre></td></tr></table></figure></li>
<li>함수 선언 <strong>function f(z)**을 찾아서 **Global Scope (window)</strong> 영역에 <strong>f</strong> 를 적재합니다.</li>
<li>함수 적재시엔 f 함수의 바이트코드(blob)에 대한 포인터값을 함께 적재합니다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a =</span><br><span class="line">- f = a pointer <span class="keyword">for</span> f functions bytecode</span><br></pre></td></tr></table></figure>
자바스크립트 코드를 첫번째 라인에서 20번째 라인까지 컴파일 과정을 마치면 Heap 구성은 마지막과 같습니다.</li>
</ol>
<h2 id="B-Execution-Phase"><a href="#B-Execution-Phase" class="headerlink" title="(B) Execution Phase"></a>(B) Execution Phase</h2><p><strong>변수</strong>의 <strong>‘할당(Assignment)’**과 실제 **함수</strong>를 <strong>호출 및 실행</strong>합니다.</p>
<blockquote>
<p>자바스크립트 <strong>변수의 ‘할당’**은 **a = 1</strong> 입니다.<br><strong>a = 1</strong> 할당 시 이전 컴파일 과정에서 선언된 변수 <strong>a</strong> 가 있는지 확인합니다.<br>만약 존재하지 않는다면 <strong>a</strong> 변수 <strong>‘선언’과 동시에 ‘할당’하여 적재</strong>합니다.</p>
</blockquote>
<blockquote>
<p>자바스크립트 <strong>함수의 ‘호출 및 실행’**은 **a()</strong> 입니다.<br><strong>a()</strong> 실행 시 첫번째로, 이전 컴파일 과정에서 선언된 함수 <strong>a()</strong> 가 있는지 확인합니다.<br><strong>a()</strong> 실행 시 두번째로, Heap 에는 새 함수를 위한 <strong>Local Execution Scope 영역을 생성</strong>하고, Call Stack 에는 생성된 Heap 에 대한 포인터를 갖는 함수 <strong>a()</strong> 정보를 적재합니다.<br><strong>a()</strong> 실행 시 마지막으로, 컴파일을 수행하여 <strong>본 함수 내 변수 및 함수</strong>를 <strong>위 Local Execution Scope 영역에 적재</strong>합니다.</p>
</blockquote>
<blockquote>
<p><strong>Execution Phase</strong>에선 <strong>변수</strong>의 <strong>‘할당(Assignment)’**값들을 **Heap 에 적재</strong>하고 <strong>함수</strong>는 <strong>호출 및 실행</strong>합니다.</p>
</blockquote>
<p>매 함수 호출때마다 스택에 함수 내 변수 및 함수를 같이 적재하는 스택 베이스 언어과 달리 자바스크립트는 스택에는 함수 호출 순서와 실제 변수 및 함수 정보들은 Heap 에 대한 포인터를 갖습니다. Heap 에 함수 <strong>a()</strong> 를 위한 <strong>Local Execution Scope</strong> 는 a() 함수가 호출되기 이전에 Heap 에 존재했던 **Global Scope (window)**에 대한 포인터를 갖고있어서, 엔진 내에서 아래와 같은 처리가 가능합니다.</p>
<ul>
<li>a() 함수 내에서 <strong>a = 1</strong> 변수 할당 시 먼저 <strong>Local Execution Scope</strong> 에 a 변수의 선언을 찾고,<br>존재하지 않는다면 이전 <strong>Global Scope</strong> 로 돌아가 검색할 수 있습니다.</li>
<li>a() 함수 실행이 끝나게 되면 Call Stack 을 통해 현재 Heap 영역을 <strong>Global Scope</strong> 로 다시 되돌립니다.</li>
</ul>
<p>위에서 예시로 살펴본 자바스크립트 파일에 컴파일 과정을 마친 뒤 수행 과정은 아래와 같이 진행됩니다.</p>
<ol start="6">
<li>컴파일 이후 아래의 Heap 을 갖고 다시 자바스크립트 파일 코드의 맨 첫번째 라인에서 실행이 시작됩니다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a =</span><br><span class="line">- f = a pointer <span class="keyword">for</span> f functions bytecode</span><br></pre></td></tr></table></figure></li>
<li>변수 할당 <strong>a = 2</strong>을 찾아서 <strong>Global Scope (window)</strong> 영역에 변수 <strong>a</strong> 존재 여부를 확인합니다.</li>
<li>변수 <strong>a</strong> 가 존재하므로 해당 <strong>a</strong> 에 <strong>2 를 할당</strong>합니다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a = <span class="number">2</span></span><br><span class="line">- f = a pointer <span class="keyword">for</span> f functions bytecode</span><br></pre></td></tr></table></figure></li>
<li>변수 할당 <strong>b = 1</strong>을 찾아서 <strong>Global Scope (window)</strong> 영역에 변수 <strong>b</strong> 존재 여부를 확인합니다.</li>
<li>변수 <strong>b</strong> 가 선언되어있지 않아 <strong>b 선언</strong> 및 <strong>1 을 할당</strong>합니다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a = <span class="number">2</span></span><br><span class="line">- f = a pointer <span class="keyword">for</span> f functions bytecode</span><br><span class="line">- b = <span class="number">1</span></span><br></pre></td></tr></table></figure></li>
<li>함수 호출 <strong>f(1)**을 찾아서 **Global Scope (window)**영역에서 **f()</strong> 선언 여부를 확인합니다.</li>
<li>함수 <strong>f() blob</strong> 컴파일 및 수행을 위해 Heap 에 <strong>새 Local Execution Scope</strong> 영역을 생성합니다.<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a = <span class="number">2</span></span><br><span class="line">- f = a pointer <span class="keyword">for</span> f functions bytecode</span><br><span class="line">- b = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"># Local Execution Scope for f()</span><br><span class="line">- (hidden) A pointer <span class="keyword">for</span> previous scope (= Global Scope (<span class="built_in">window</span>))</span><br><span class="line">- </span><br><span class="line">- </span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>f(1)</strong> 함수 실행 시 새로이 생성된 <strong>Local Execution Scope</strong>에 다시 <strong>Compilation Phase</strong> 과정을 통해 변수와 함수를 적재하게 되고 <strong>Execution Phase</strong> 과정을 수행하게 됩니다. 또 <strong>f(1)</strong> 함수 내부에 또 다른 함수가 있다면 이 과정을 계속해서 재귀적으로 반복합니다. </p>
<ol start="13">
<li>함수 f() 의 <strong>Compilation Phase</strong> 과정을 마치면 아래와 같이 됩니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global Scope (window)</span></span><br><span class="line">- a = 2</span><br><span class="line">- f = a pointer <span class="keyword">for</span> f <span class="built_in">functions</span> bytecode</span><br><span class="line">- b = 1</span><br><span class="line"></span><br><span class="line"><span class="comment"># Local Execution Scope for function f()</span></span><br><span class="line">- (hidden) a pointer <span class="keyword">for</span> previous scope (= Global Scope (window))</span><br><span class="line">- z = </span><br><span class="line">- d = </span><br><span class="line">- e = </span><br></pre></td></tr></table></figure></li>
<li>함수 f() 의 <strong>Execution Phase</strong> 과정을 마치면 함수 <strong>f()</strong> 내 <strong>변수 할당</strong> 및 <strong>함수 g() 의 Scope 가 생성</strong>되게 됩니다.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Global Scope (window)</span></span><br><span class="line">- a = 2</span><br><span class="line">- f = a pointer <span class="keyword">for</span> f <span class="built_in">functions</span> bytecode</span><br><span class="line">- b = 3</span><br><span class="line"></span><br><span class="line"><span class="comment"># Local Execution Scope for function f()</span></span><br><span class="line">- (hidden) a pointer <span class="keyword">for</span> previous scope (= Global Scope (window))</span><br><span class="line">- z = 1</span><br><span class="line">- d = 6</span><br><span class="line">- e = 1</span><br><span class="line">- c = 4</span><br><span class="line"></span><br><span class="line"><span class="comment"># Local Execution Scope for function g()</span></span><br><span class="line">- (hidden) a pointer <span class="keyword">for</span> previous scope (= Local Execution Scope <span class="keyword">for</span> <span class="keyword">function</span> f())</span><br><span class="line">- e =</span><br></pre></td></tr></table></figure>
<h1 id="자바스크립트-엔진-특성"><a href="#자바스크립트-엔진-특성" class="headerlink" title="자바스크립트 엔진 특성"></a>자바스크립트 엔진 특성</h1></li>
</ol>
<h2 id="Function-level-scope-var"><a href="#Function-level-scope-var" class="headerlink" title="Function-level scope: var"></a>Function-level scope: var</h2><p>자바스크립트 실행은 결국 <strong>함수에 따라 (A) 컴파일, (B) 수행이 재귀적으로 이뤄집니다.</strong> 처음 자바스크립트 실행 시 <strong>main() 함수에 대한 (A), (B)</strong> 처리를 시작으로 내부에 새로운 함수 호출이 일어나면 <strong>새 함수에 대한 (A), (B)</strong> 처리 그리고 또 내부 함수 호출이 있다면 <strong>그 함수에 대한 (A), (B)</strong> … 이런식으로 처리를 반복하게 됩니다.</p>
<blockquote>
<p><strong>특정 함수 내 변수 var 의 선언</strong>은 <strong>본 함수 (A) 컴파일</strong>에 정의되기 때문에 <strong>변수 var 의 scope</strong>는 <strong>function-level</strong>이 됩니다.</p>
</blockquote>
<p>if, for 문과 같은 block-level({}) 단위 변수를 위해 ES6 스펙에선 <strong>Block-level scope: const, let</strong>이 새로 소개되었습니다.</p>
<h2 id="Scope-Chain"><a href="#Scope-Chain" class="headerlink" title="Scope Chain"></a>Scope Chain</h2><p>자바스크립트 엔진 실행 과정에서 살펴보았듯 특정 함수에 대한 <strong>(B) 수행 단계</strong>에서 <strong>변수 할당 시</strong> 본 함수의 Heap 영역에 변수 선언이 되어있는지 먼저 검사하게 됩니다. 만약 <strong>본 함수 내 변수가 선언되어있지 않았다</strong>면 해당 함수의 Heap 에서는 변수 선언을 찾을 수 없게됩니다. 이때 <strong>해당 함수가 호출되기 이전의 함수</strong>로 <strong>(hidden) A pointer for previous scope</strong> 를 통해 올라가면서 해당 함수 Heap Scope 에 <strong>변수가 선언되었는지 확인</strong>합니다. 어떠한 함수에서도 <strong>변수 선언</strong>이 되어있지 않다면 가장 처음에 호출된 main() 함수까지 올라가면서 검색하게 됩니다. 함수 호출 스택에 따라 가장 처음의 main() 함수까지 <strong>각 함수 Heap Scope 에 변수 선언 존재여부를 연쇄적으로 Chaining 하며 찾기때문에 이를 Scope Chain 이라고 부릅니다.</strong></p>
<h2 id="Variable-Hoisting"><a href="#Variable-Hoisting" class="headerlink" title="Variable Hoisting"></a>Variable Hoisting</h2><p><strong>(A) 컴파일 단계</strong>에서 <strong>변수를 선언</strong>을 먼저하고, 그 다음 <strong>(B) 수행 단계</strong>에서 <strong>변수를 할당</strong>하기 때문에 같은 function-level 이라면 아래와 같이 변수 선언과 할당을 나누어서 하더라도 자바스크립트 엔진에서는 <strong>변수 선언이 먼저 된 것으로 처리</strong>됩니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a = <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>위 예시처럼 <strong>var a</strong> 선언이 <strong>같은 function-level 내에서 최상단에 ‘말려올라간것’처럼 수행</strong>되기도 하지만, 만약 <strong>함수 내 변수가 선언되어있지 않았다</strong>면 Scope Chain 을 통해 main() 함수까지 올라가면서 변수 선언을 찾습니다. 최종적으로 main() 함수 Heap Scope 에도 선언되어있지 않다면 main() 함수 영역에 변수를 선언해주게 됩니다. main() 에서 호출한 어떤 함수이든 Scope Chain 을 통해 방금 선언해준 변수를 바라볼테니 이는 <strong>전역 변수</strong>인것입니다. (<strong>main() 의 Heap Scope 영역 명칭은 Global Scope (window)**이기도 합니다.) 특정 함수내에 변수를 할당하였지만 본 변수는 어느 함수에도 존재하지 않는 변수이기에 **main() 함수까지 ‘말려올라가서’ 전역 변수를 선언한것이 됩니다.</strong> <strong>변수 선언이 ‘말려올라갔다’는 의미에서 이 모든 경우를 Variable Hoisting 이라고 표현</strong>합니다.</p>
<h2 id="Variable-Shadowing"><a href="#Variable-Shadowing" class="headerlink" title="Variable Shadowing"></a>Variable Shadowing</h2><p>특정 함수의 Heap Scope 에 변수 선언이 되어있다면 해당 변수에 대한 변수 할당은 현재 함수 Heap Scope 에 선언되어있는 변수에 대입됩니다. 만약에 해당 함수를 호출하는 이전 함수에 해당 변수와 똑같은 명칭의 변수가 선언되어있다고 할지라도 현재 함수 Heap Scope 에 이미 존재하기때문에 이전 함수의 Heap Scope 까지 Scope Chain 할 필요가 없습니다. <strong>이전 함수에 같은 명칭의 변수가 있다고하더라도 현재 함수는 그 존재를 알 수도 알 필요도 없기 때문에 이를 Variable Shadowing</strong> 이라 부릅니다.</p>
<h2 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h2><p>함수 직접 수행이 끝나면 Stack 에서 수행 완료된 함수의 정보를 없애면서 Heap 메모리 내 수행 완료된 함수의 Heap Scope 도 없애게 됩니다. 메모리 청소의 의미로 Garbage Collection 이라고 부릅니다. 전체 자바스크립트 파일 실행이 끝나게되면 가장 마지막으로 main() 함수의 Global Scope(Window) 도 사라지게 됩니다. Reference Count 를 통한 Garbage Collection 를 하는 스위프트 언어도 있지만 <strong>자바스크립트는 단순히 함수(포인터)의 Reachability 를 기반으로 Garbage Collection 를 수행</strong>합니다. 함수 직접 수행이 아닌 함수 수행을 변수에 할당한 경우엔 함수 수행이 끝났다고 하더라도 할당된 변수로 또 함수 수행이 가능하기 때문에 본 함수에 대한 Garbage Collection 를 안하는 경우가 존재하는데 바로 아래서 설명할 Closure 개념입니다.</p>
<h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><p><strong>자바스크립트 엔진 실행</strong> 설명시 다뤘던 예제에서 function f 를 바로 실행하지 않고 var myFunction 를 선언하여 그에 할당해보았습니다.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">2</span>;</span><br><span class="line">b = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">z</span>) </span>&#123;</span><br><span class="line">  b = <span class="number">3</span>;</span><br><span class="line">  c = <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="number">6</span>;</span><br><span class="line">  e = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">g</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> e = <span class="number">0</span>;</span><br><span class="line">    d = <span class="number">3</span>*d;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> g;</span><br><span class="line">  <span class="keyword">var</span> e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFunction = f(<span class="number">1</span>); <span class="comment">// 새로 추가된 코드</span></span><br><span class="line">myFunction();</span><br></pre></td></tr></table></figure>
<p>함수 호출을 변수에 할당하게 되면 함수의 호출은 일회성으로 호출이 끝나면 사라지는것이 아니라 <strong>myFunction</strong> 이란 변수를 통해서 계속해서 반복 호출이 가능하기 때문에 f 함수 호출을 위해 생성된 f 함수의 Heap Scope 는 지워질 수 없습니다. 조금 쉽게 생각하자면 f 함수 Heap Scope 에는 f 함수 수행을 위해 넘긴 파라미터 값 1 도 들고있기 때문에 Heap Scope 를 Garbage Collection 할 수 없는것입니다. 이처럼 함수 호출을 변수에 할당하게 되면 <strong>f 함수의 Heap Scope</strong> 와 <strong>f 를 호출한 함수의 Heap Scope</strong> 가 <strong>파라미터 1 을 기준으로 강하게 묶여있기 때문에 f 함수 실행이 끝났음에도 불구하고 f 함수의 Heap Scope 가 Garbage Collection 되지 않습니다.</strong></p>
<p>Closure 는 함수의 Heap Scope 와 해당 함수를 호출하는 함수의 Heap Scope 를 연결하는것으로, 함수 호출이 끝나더라도 Scope 는 여전히 해당 함수를 호출한 함수의 Scope 에 ‘갇혀있는’ 개념입니다.</p>
<hr>
<p>1: <a target="_blank" rel="noopener" href="https://youtu.be/QyUFheng6J0">https://youtu.be/QyUFheng6J0</a><br>2: <a target="_blank" rel="noopener" href="https://www.quora.com/Is-JavaScript-a-compiled-or-interpreted-programming-language">https://www.quora.com/Is-JavaScript-a-compiled-or-interpreted-programming-language</a><br>3: <a target="_blank" rel="noopener" href="https://medium.com/@almog4130/javascript-is-it-compiled-or-interpreted-9779278468fc">https://medium.com/@almog4130/javascript-is-it-compiled-or-interpreted-9779278468fc</a><br>4: <a target="_blank" rel="noopener" href="https://blog.usejournal.com/is-javascript-an-interpreted-language-3300afbaf6b8">https://blog.usejournal.com/is-javascript-an-interpreted-language-3300afbaf6b8</a><br>5: <a target="_blank" rel="noopener" href="https://youtu.be/QyUFheng6J0?t=435">https://youtu.be/QyUFheng6J0?t=435</a><br>6: <a target="_blank" rel="noopener" href="https://dev.to/genta/is-javascript-a-compiled-language-20mf">https://dev.to/genta/is-javascript-a-compiled-language-20mf</a><br>7: <a target="_blank" rel="noopener" href="https://dev.to/deanchalk/comment/8h32">https://dev.to/deanchalk/comment/8h32</a><br>8: <a target="_blank" rel="noopener" href="https://gist.github.com/kad3nce/9230211#compiler-theory">https://gist.github.com/kad3nce/9230211#compiler-theory</a><br>9: <a target="_blank" rel="noopener" href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf">https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf</a><br>10: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/%EC%B0%B8%EC%A1%B0/API">https://developer.mozilla.org/ko/docs/Web/%EC%B0%B8%EC%A1%B0/API</a><br>11: <a target="_blank" rel="noopener" href="https://medium.com/@antwan29/browser-and-web-apis-d48c3fd8739">https://medium.com/@antwan29/browser-and-web-apis-d48c3fd8739</a></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2020-08-20</div></span><span class="level-item"><a class="link-muted" href="/categories/Deployment/">Deployment</a><span> / </span><a class="link-muted" href="/categories/Deployment/Docker/">Docker</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/20/an-introduction-to-docker/">Docker 간단하게 살펴보는 기본 개념</a></h1><div class="content"><h1 id="왜-Docker-를-사용하는가"><a href="#왜-Docker-를-사용하는가" class="headerlink" title="왜 Docker 를 사용하는가?"></a>왜 Docker 를 사용하는가?</h1><p>하나의 서버에 다양한 Application 들을 구동시키려면 여러 VM 들을 올려놓고 각 Application 마다 VM 을 할당해주는 방법도 있지만, Docker 는 각 Application 을 VM 보다 가벼운 Container 단위로 패키징 및 관리를 가능하게 합니다.</p>
<h1 id="Container-는-무엇인가"><a href="#Container-는-무엇인가" class="headerlink" title="Container 는 무엇인가?"></a>Container 는 무엇인가?</h1><h2 id="VM-vs-‘Container’"><a href="#VM-vs-‘Container’" class="headerlink" title="VM vs ‘Container’"></a>VM vs ‘Container’</h2><p><strong>VM</strong> 개념은 <strong>단일 Host OS</strong> 위에 <strong>다수의 Guest OS</strong> 를 갖고 각각 Application 을 단일 Guest OS 에 매핑한것인 반면</p>
<blockquote>
<p>[ Host OS - [ <strong>VM</strong>: Guest OS - Libs - App ] ]</p>
</blockquote>
<p><strong>Container</strong> 는 <strong>단일 Host OS</strong> 위에 <strong>다수의 Application 을 바로 구동</strong>할 수 있는 VM 보다 가벼운 단위입니다. <strong>Host</strong> OS 와 <strong>Container</strong> 사이 포트 포워딩이나 파일시스템(디렉토리) 연동 등은 후술할 Image 설정으로 가능합니다.</p>
<blockquote>
<p>[ Host OS - [ <strong>Container</strong>: Libs - App ] ]</p>
</blockquote>
<p>VM 은 Hypervisor 에 의해 물리적 자원 관리가 된다면 Container 는 Docker 에 의해 논리적으로 자원 분배가 됩니다. </p>
<ul>
<li>VM 은 Hypervisor 에 의한 하드웨어 가상화</li>
<li>Container 는 Docker 에 의한 Host OS 가상화</li>
</ul>
<p>과거 학부때 데모 실행을 위해 멀티 노드 하둡구성시 사용 경험이 있는 LXC(Linux Container) 개념이 Docker 의 초기 버전의 구현이었다고 합니다만 이후 Docker 는 자체 컨테이너를 사용한다고 합니다.</p>
<h2 id="Image-and-‘Container’"><a href="#Image-and-‘Container’" class="headerlink" title="Image and ‘Container’"></a>Image and ‘Container’</h2><p>Docker 를 처음 접하며 명확히 구별하지 못했던 개념이 있습니다. ‘Image’와 ‘Container’입니다. Image 는 VM 에서의 개념과 동일하기에 쉽게 이해하실 수 있습니다.</p>
<ul>
<li><strong>Image</strong> 는 Container 구동을 위한 파일시스템과 구동에 필요한 설정들이 모여있는 <strong>정적 설정</strong>이며,</li>
<li><strong>Container</strong> 는 위 Image 를 기반으로 실제 구동(Runtime)된 <strong>동적 인스턴스</strong>라고 보면 됩나다.</li>
</ul>
<h1 id="왜-Container-를-사용하는가"><a href="#왜-Container-를-사용하는가" class="headerlink" title="왜 Container 를 사용하는가?"></a>왜 Container 를 사용하는가?</h1><h2 id="Application-단위-관리"><a href="#Application-단위-관리" class="headerlink" title="Application 단위 관리"></a>Application 단위 관리</h2><p>Application 단위로 패키징을 가능하게 함으로써 개발 시 역할/책임(R&amp;R)을 분리할 수 있습니다. 웹 서비스를 개발하면 하나의 서버 인스턴스에 다양한 역할들이 들어있는데, 각각 독립된 Container 로 분리할 수 있습니다.</p>
<ul>
<li><strong>nginx</strong>: 정적 페이지 제공 및 SPA 프론트엔드</li>
<li><strong>tomcat</strong>: 프론트엔드에 제공될 API 서버</li>
<li><strong>logstash</strong>: nginx, tomcat 에서 발생하는 log 들을 log 적재 서버에 전송</li>
<li><strong>온콜(서비스 상태 추적)</strong>: nginx, tomcat 에서 발생하는 오류 로그 및 CPU, memory 등 자원 상태를 상태 관리 서버에 전송</li>
<li><strong>성능 측정(예, pinpoint)</strong>: tomcat 에서 타 서버들의 API 콜에 대한 횟수, 지연시간 등을 성능 관리 서버에 전송</li>
</ul>
<p>즉, 위 예시와 같이 하나의 서버 인스턴스에 총 5개의 Container 가 작동될 수 있습니다.</p>
<p>만약 프론트엔드에 제공할 API 서버뿐만 아니라 외부에서 직접 호출할 수 있는 API 서버를 추가하고싶다면 tomcat 컨테이너를 하나 더 추가하여 총 2개의 tomcat 을 하나의 서버 인스턴스에 두고 사용할 수 있습니다. Java 기반 tomcat 을 Python 기반 django 로 교체할 수 도 있습니다. 프론트엔드를 제공하는 nginx 서버는 그대로 있으면서 API 서버만 교체된것이죠. </p>
<p>각 Application 을 레고 블럭처럼 관리하는건 배포에도 큰 이점이 있습니다. 단지 하나의 컨테이너 버전만 업데이트하고싶다면 해당 컨테이너의 이미지만 다시 받아서 재배포를 진행하면 됩니다. 각 컨테이너마다 버전 관리를 따로 할 수 있는것이죠.</p>
<blockquote>
<p>레고 블럭처럼 Application 들을 관리할 수 있다는 장점은 VM 도 갖고있지만, 그보다 더 Container 를 선호하는 이유는 <strong>가상화의 레벨이 상위 레벨인 만큼 가볍고(Container = lightweight VM), 위에 설명했듯이 버전 및 배포관리가 이미지로 관리되므로 (1) 이미지 설정과 (2) 배포가 구분되어있어 과정의 자동화가 쉽기 때문입니다. 성능 측면에서도 Container 간 IO 및 네트워크 처리에 있어서 빠르기도 합니다.</strong><a target="_blank" rel="noopener" href="https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd">^1</a> 가상화의 레벨이 로우 레벨인 VM 은 보안 측면에서의 캡슐화가 Container 보다 더 뛰어나다고 하지만, 현재 기술에서는 둘간 얼마나 큰 차이가 있을지 궁금하군요.</p>
</blockquote>
<p>이처럼 Docker 로는 <strong>Application 이 구동될 환경</strong>과 <strong>구동할 이미지</strong>를 설정합니다. <strong>Application 각각의 자체 설정</strong>은 docker 와 별개로 프로젝트 내부에 설정해놓으면 됩니다. 책임 분리인 셈입니다.</p>
<h1 id="Docker-용어-구성요소"><a href="#Docker-용어-구성요소" class="headerlink" title="Docker 용어(구성요소)"></a>Docker 용어(구성요소)</h1><ul>
<li><strong>Registry</strong> = Images storage<ul>
<li>Image 들을 저장헤놓는 중앙 저장소</li>
<li>일반적으로 배포 파이프라인을 구성하면 최신 소스를 통해 Docker Engine 으로 생성한 tomcat/nginx 이미지를 Registry 에 올린뒤, 해당 이미지로 최종 서버 배포를 진행합니다.</li>
<li>기본 Docker Hub 서버 혹은 회사/개인용 Docker Hub 서버를 만들어서 사용하거나</li>
<li>Amazon AWS 에서 제공하는 ECR(AWS EC2 Continaer Registry)를 사용할 수도 있습니다.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Image</strong><ul>
<li>전에 설명했듯 Container 동작을 위한 파일시스템과 구동에 필요한 설정들이 모여있는 <strong>정적 설정</strong>입니다.</li>
<li>Image 는 RO(Read-Only) 파일시스템의 집합<a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/#images-and-layers">^2</a>입니다. 좀 더 상세한 파일시스템 구조는 다음을 참조<a target="_blank" rel="noopener" href="https://rampart81.github.io/post/docker_image/">^3</a>하세요.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Container</strong><ul>
<li>위 Image 기반으로 실제 구동(Runtime)된 <strong>동적 인스턴스</strong></li>
</ul>
</li>
</ul>
<ul>
<li><strong>Application/Service</strong> = Containers on <strong>One host</strong><ul>
<li>이를 위해 <strong>Docker Compose</strong> 를 사용하여 <strong>하나의 호스트 머신에서 Containers 를 관리</strong>할 수 있습니다.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Orchestration</strong> = Containers on <strong>Multiple hosts</strong>(Systems, MSA)<ul>
<li>이를 위해 <strong>Docker Swarm</strong> 를 사용하여 <strong>다수의 호스트 머신에서 Containers 를 관리</strong>할 수 있습니다.</li>
</ul>
</li>
</ul>
<h1 id="Docker-Engine"><a href="#Docker-Engine" class="headerlink" title="Docker Engine"></a>Docker Engine</h1><p><strong>(1) Image 생성</strong> 및 <strong>(2) Container 구동</strong> 모두를 담당하는 엔진<a target="_blank" rel="noopener" href="https://www.quora.com/What-is-the-difference-between-the-Docker-Engine-and-Docker-Daemon">^4</a>이며 구성은 아래와 같습니다.</p>
<ol>
<li>컨테이너 및 이미지 생성을 위한 유저의 입력을 받는 <strong>Docker CLI</strong></li>
<li>컨테이너 구동을 위한 <strong>Docker Daemon</strong></li>
</ol>
<h2 id="Image-생성"><a href="#Image-생성" class="headerlink" title="Image 생성"></a>Image 생성</h2><p>Container 는 Image 기반으로 구동되기때문에 원하는 Container 구동에 앞서 원하는 Image 를 먼저 만들어야합니다. 이미지 생성에서 최종 컨테이너 구동까지는 세 절차로 이뤄집니다.</p>
<ol>
<li><strong>Dockerfile</strong> - Dockerfile 작성</li>
</ol>
<p>Dockerfile 로 원하는 Image 생성에 대한 설정(생성 규칙)을 여러 명령어로 작성합니다. 본 설정을 기반으로 이미지를 생성하고 생성된 이미지를 갖고 추후 컨테이너로 구동하게됩니다. 아래는 간단한 명령어 모음입니다.</p>
<blockquote>
<p><strong>FROM</strong>: 기본 베이스 이미지를 정의합니다. 가져올 해당 이미지 URL 을 적으면 됩니다.<br><strong>ENV</strong>: 이미지 내 환경변수를 설정합니다. 리눅스 터미널에서 <code>SET_VALUE=3</code> &amp; <code>echo $SET_VALUE</code> 를 생각하면됩니다.</p>
<p><strong>RUN</strong>: 실행할 Shell 명령어를 명시하면 <strong>이미지 빌드 시점</strong>에서 해당 명령어를 수행합니다.<br><strong>CMD</strong>: 실행할 Shell 명령어를 명시하면 <strong>이미지 빌드 완료 뒤 컨테이너가 정상 실행되었을때</strong> 해당 명령어를 수행합니다.</p>
<p><strong>EXPOSE</strong>: 외부에 열고싶은 Port 를 설정합니다. <strong>Container 포트</strong>와 <strong>실제 Host 에서 노출할 포트</strong>를 연결합니다.<br><strong>WORKDIF</strong>, <strong>ENTRYPOINT</strong>: RUN/CMD 로 명시한 Shell 을 실행할 디렉토리 위치를 지정합니다.<br><strong>ADD</strong>, <strong>COPY</strong>: 호스트의 디렉토리나 파일을 <strong>이미지에 커밋</strong>합니다.<br><strong>VOLUME</strong>: 호스트의 디렉토리나 파일을 이미지에 커밋하지 않고 <strong>컨테이너 디렉토리에 연결</strong>합니다.</p>
<p>… 더 많은 명령어 및 상세 설명은 공식 Docker 문서를 참조하세요.</p>
</blockquote>
<ol start="2">
<li><strong>Build</strong> (docker build) - 이미지 생성</li>
</ol>
<p><code>docker build</code> 명령어를 실행하면 가장 먼저, 작성되어있는 Dockerfile 를 Docker Daemon 에게 전달합니다. 그 후 Dockerfile 스크립트 내 매 명령어마다 실행하기 위한 컨테이너를 구동하고, 명령어가 성공적으로 수행된다면 해당 스냡샷으로 이미지를 생성합니다. 아래에서 예시로 살펴볼 <code>docker build</code> 수행 로그를 보면 Docker 는 <strong>Dockerfile 내 각 명령어가 실행되는 컨테이너의 ID</strong>와 <strong>실행이 끝난다면 실행완료된 컨테이너의 스냅샷으로 생성한 이미지 ID</strong> 이 둘을 반환하는걸 알 수 있습니다.</p>
<p>만약에 명령어 수행중에 실패하게 된다면 <strong>해당 명령어가 실행되는 컨테이너 ID</strong>에 쉘을 통해 접근하여 로그를 확인할 수 있습니다. 이처럼 중간에 반환되는 컨테이너 ID 를 통해 <code>docker build</code> 디버깅이 가능합니다. 그렇다면 Dockerfile 스크립트의 마지막 라인이 실행 완료된 컨테이너의 스냅샷이 최종적으로 우리가 생성할 이미지가 되는것입니다.</p>
<ul>
<li><strong>2.1. 빌드의 시작은 Dockerfile 를 Docker Daemon 에 전달하면서 시작</strong>됩니다.</li>
</ul>
<p>Docker Daemon 은 Dockerfile 에서 FROM 명령어에 명시된 새로 생성할 이미지의 기반이 될 베이스 이미지를 가져옵니다.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker build .</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 10240 bytes</span><br><span class="line"></span><br><span class="line">Step 1/3 : FROM base-image:1.7.2</span><br><span class="line">Pulling repository base-image:1.7.2</span><br><span class="line"> ---&gt; e9aa60c60128/1.000 MB (100%) endpoint: https://my-own.docker-registry.com/v1/</span><br></pre></td></tr></table></figure>
<p>개인 Docker Registry 인 <a target="_blank" rel="noopener" href="https://my-own.docker-registry.com/v1">https://my-own.docker-registry.com/v1</a> 에서 base-image:1.7.2 이미지를 가져왔습니다. 마지막 라인에 <code>e9aa60c60128</code>는 다운받은 베이스 이미지에 Docker 가 할당한 ID 입니다. 다음으로 수행될 명령어는 이 이미지 기반으로 중간 이미지를 만듭니다.</p>
<ul>
<li><strong>2.2. 그 다음 명령어는 이전에 생성된 중간 이미지를 다시 컨테이너로 구동하여, 명령어들을 수행한 뒤 스냅샷을 이미지로 반환</strong>합니다.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Step 2/3 : WORKDIR /instance</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 9c9e81692ae9</span><br><span class="line">Removing intermediate container 9c9e81692ae9</span><br><span class="line"> ---&gt; b35f4035db3f</span><br></pre></td></tr></table></figure>
<p>바로 이전에 수행한 FROM 명령어의 결과로 <code>e9aa60c60128</code> 중간 이미지가 생성되었습니다. 본 이미지로 새 컨테이너 <code>9c9e81692ae9</code> 를 구동하였고, 그 내부에서 <code>WORKDIR /instance</code> 명령어를 수행한뒤, 수행 완료된 컨테이너를 내리고 그 스냅샷을 <code>b35f4035db3f</code> 이미지로 반환한것을 볼 수 있습니다.</p>
<ul>
<li><strong>2.3.</strong> 2.2.와 동일합니다. 단, Dockerfile 내 모든 Step 을 마쳤으므로 <strong>마지막으로 생성한 스냅샷 이미지가 우리가 최종적으로 얻는 이미지</strong>가 됩니다.</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Step 3/3 : CMD <span class="built_in">echo</span> Hello world</span><br><span class="line"> ---&gt; Running <span class="keyword">in</span> 02071fceb21b</span><br><span class="line">Removing intermediate container 02071fceb21b</span><br><span class="line"> ---&gt; f52f38b7823e</span><br><span class="line"></span><br><span class="line">Successfully built f52f38b7823e</span><br></pre></td></tr></table></figure>
<p>우리가 얻는 최종 이미지명(ID)을 <code>f52f38b7823e</code>가 아닌 원하는 이름을 붙여주고 싶다면 tag 옵션을 통해 이름을 붙여줄 수 있습니다. 예를 들면 <strong>base-image:1.7.2</strong> 로 새 이미지를 만들었으니 <strong>custom-image:1.7.2</strong> 로 이름지어볼 수 있습니다.</p>
<ul>
<li><strong>2.4.</strong> <strong>Push</strong> (docker push) - 이렇게 만든 이미지를 Docker Registry 에 저장합니다.</li>
</ul>
<h2 id="Container-구동"><a href="#Container-구동" class="headerlink" title="Container 구동"></a>Container 구동</h2><p>생성된 최종 Image 로 Docker Daemon 위에서 Container 구동합니다.</p>
<ul>
<li><strong>1.</strong> <strong>Pull</strong> (docker pull) - 컨테이너를 구동하기 위해 저정된 이미지를 가져옵니다.</li>
<li><strong>2.</strong> <strong>Execute</strong> (docker run) - 가져온 이미지로 컨테이너를 구동합니다.</li>
</ul>
<h1 id="Docker-이미지-설정-예시"><a href="#Docker-이미지-설정-예시" class="headerlink" title="Docker 이미지 설정 예시"></a>Docker 이미지 설정 예시</h1><p>상품 정보를 저장/조회하는 서비스를 제공하기 위해 <strong>프론트엔드 서버</strong>는 <strong>nginx</strong>(react.js) 로 <strong>백엔드 서버</strong>는 <strong>tomcat</strong>(java) 으로 서비스를 제공하려고합니다. 두 Application 들을 각각 Container 로 총 두 개의 Container 를 하나의 AWS EC2 서버 인스턴스에서 구동하려합니다.</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>먼저 nginx image 설정을 보겠습니다. nginx 구동은 쉘 스크립트를 실행하게되는데 직접 만든 replace-hosts-and-run.sh 쉘을 이미지에 주입해서 알맞은 환경변수와 함께 수행하여 최종적으로 nginx 서버를 띄우는것을 목표로 하겠습니다.</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 기본 베이스 이미지를 가져옵니다. 프론트엔드 서버용 nginx 기본 이미지를 받습니다.</span></span><br><span class="line"><span class="keyword">FROM</span> http://docker-hub.aaronryu.com/nginx:<span class="number">1.8</span>.<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. nginx 웹 서버에서 다국어 지원을 위한 gettext 를 설치합니다.</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apk --no-cache add gettext</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 현재 프로젝트 디렉토리 중 files/, build/, 쉘 스크립트를 이미지 내 지정한 디렉토리에 추가/붙여넣습니다.</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> files/ /instance/program/nginx/conf</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> build/ /instance/service/webroot/ui</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> replace-hosts-and-run.sh /instance/program/nginx/replace-hosts-and-run.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 위 쉘 스크립트(replace-hosts-and-run.sh)에서 사용할 호스트 명 환경변수를 설정합니다.</span></span><br><span class="line"><span class="keyword">ENV</span> NGINX_HOST aaronryu.frontend.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 로깅 등을 위해 nginx 컨테이너 내 아래 디렉토리를 호스트의 디렉토리에 연결합니다.</span></span><br><span class="line"><span class="comment"># (Container 가 아래 디렉토리에 하는 작업은 실제 호스트의 디렉토리에 반영됩니다.)</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;/instance/logs/nginx&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. &#x27;이미지 완료 뒤&#x27;에 아까 복사해둔 아래 쉘 스크립트를 위 환경변수와 함께 실행(CMD)합니다.</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /instance/program/nginx/replace-hosts-and-run.sh</span></span><br></pre></td></tr></table></figure>
<h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><p>nginx 서버의 SPA 정적 페이지에서 조회 및 저장을 위해서는 그에 맞는 API 가 필요합니다. 이 API 들을 제공하기위한 tomcat 서버를 구동하겠습니다. Java 서버이기에 JVM 에 대한 설정을 추가하고, 외부에서 본 서버의 상태를 조회하기 위해 12345 포트를 열어두겠습니다.</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. 기본 베이스 이미지를 가져옵니다. 백엔드 서버용 tomcat 기본 이미지를 받습니다.</span></span><br><span class="line"><span class="keyword">FROM</span> http://docker-hub.aaronryu.com/tomcat:<span class="number">8.0</span>.<span class="number">0</span>-jdk8</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. tomcat 의 구현은 spring boot 로 되어있습니다. 구동 시 production 프로파일 옵션을 주겠습니다.</span></span><br><span class="line"><span class="keyword">ENV</span> SPRING_PROFILE production</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. tomcat 은 Java 기반 서버이기에 JVM 메모리 옵션을 추가합니다.</span></span><br><span class="line"><span class="keyword">ENV</span> JVM_MEMORY -Xms2g -Xmx2g -XX:PermSize=<span class="number">512</span>m -XX:MAxPermSize=<span class="number">512</span>m</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 현재 프로젝트 디렉토리내 저장되어있는 setenv.sh 을 이미지 내 tomcat 실행 쉘 파일에 추가/붙여넣습니다.</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> setenv.sh <span class="variable">$&#123;CATALINA_HOME&#125;</span>/bin/setenv.sh</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 현재 프로젝트 빌드가 완료된 뒤 생성된 war 파일을 모두 tomcat 실행 webapps 에 추가/붙여넣습니다.</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> build/libs/*.war <span class="string">&quot;<span class="variable">$&#123;CATALINA_HOME&#125;</span>&quot;</span> /webapps/ROOT.war</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 설정한 tomcat 서버 포트 8080 을 호스트의 12345 포트에 연결하여 외부에 노출합니다.</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span> <span class="number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 로깅 등을 위해 tomcat 컨테이너 내 아래 디렉토리들을 호스트의 디렉토리에 연결합니다.</span></span><br><span class="line"><span class="comment"># (Container 가 아래 디렉토리에 하는 작업은 실제 호스트의 디렉토리에 반영됩니다.)</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;/instance/logs/tomcat&quot;</span>, <span class="string">&quot;/instance/logs/tomcat/catalina_log&quot;</span>, <span class="string">&quot;/instance/logs/tomcat/gc&quot;</span>]</span></span><br></pre></td></tr></table></figure>
<p>위 예시로 살펴본 각각의 Dockerfile 은 각각 nginx 와 tomcat 프로젝트 내에 위치하게 됩니다. 이 두 컨테이너를 하나의 인스턴스에 동시에 띄우기 위해서는 Docker Compose 설정으로(예, .yml) 설정으로 각 컨테이너의 이미지를 묶어서 명시하면 됩니다.</p>
<hr>
<ol>
<li><a target="_blank" rel="noopener" href="https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd">https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/#images-and-layers">https://docs.docker.com/storage/storagedriver/#images-and-layers</a></li>
<li><a target="_blank" rel="noopener" href="https://rampart81.github.io/post/docker_image/">https://rampart81.github.io/post/docker_image/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.quora.com/What-is-the-difference-between-the-Docker-Engine-and-Docker-Daemon">https://www.quora.com/What-is-the-difference-between-the-Docker-Engine-and-Docker-Daemon</a></li>
<li><a target="_blank" rel="noopener" href="https://www.joyfulbikeshedding.com/blog/2019-08-27-debugging-docker-builds.html">https://www.joyfulbikeshedding.com/blog/2019-08-27-debugging-docker-builds.html</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2019-12-15</div></span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/Develop/">Develop</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/15/one-page-for-regular-expression/">한 장으로 보는 정규표현식</a></h1><div class="content"><h1 id="중요성"><a href="#중요성" class="headerlink" title="중요성"></a>중요성</h1><p>개인적으로 좋아했던 구글 Tech Lead 유튜버가 개발자라면 당연히 알아야할 몇가지 스킬을 업로드<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=3MtrUf81k6c">^1</a>한적이 있다.</p>
<ol>
<li>Regular expressions</li>
<li>SQL</li>
<li>Debugging Skills (problem solving).</li>
<li>Tooling language</li>
<li>Anti-Social skill </li>
</ol>
<p>이 중 오늘의 주제는 가장 첫번째에 언급된 <strong>정규표현식</strong>이다. 중간에 5번이라는 스파이가 있는듯 한데 개발자는 사실상 코딩보단 말을 많이하는 직업이라 생각해서 그리 좋은 전략은 아닌듯하다. <strong>정규표현식</strong>은 학사때도 나중에 공부해야지 하고 메모는 많이 해놓았는데 정작 제대로 외우진 않고 매번 필요할때마다 찾아 쓴듯하다. 최근에 정리하였는데 나름 문법처럼 분류해서 외우면 쉽다. 사실 Regex 는 Tech Lead 말대로 개발하는데 너무 널리 사용된다. 텍스트 검색, 정확히는 패턴 매칭에 사용되는데 검색이라면 아래같이 수많은 유즈케이스들이 있다.</p>
<ul>
<li>grep 을 통한 로그/텍스트 분석</li>
<li>개발하고 있는 코드/디렉토리 검색</li>
<li>commit 이전 코드 체킹</li>
<li>웹 크롤링</li>
<li>URL 파싱</li>
<li>값/포맷 validation</li>
</ul>
<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>Regex 는 처음보았을때나 공부하기 전까지는 암호내지 외계어처럼 보이긴 한다. 우리가 흔히 접하는 언어는 semantic 이 word 혹은 그 조합으로 표현되지만, semantic 들이 각각 하나의 charactor 에 매핑되어있는건 암호체계와 동일하기 때문이다. 이것도 syntax 로 분류하면 아래와 같이 나뉘어지는데, 정규표현식을 익히는데 많은 도움이 된다.</p>
<center><img src="/2019/12/15/one-page-for-regular-expression/one-page-regex.png" class=""></center>

<p>기본적으로 특정 단어를 검색하기 위해 정규표현식을 사용하는데, 단순히 찾고싶은 <strong>1. 특정 단어</strong>를 명시하는 방법도 있지만 <strong>2. 글자나 숫자 조합</strong>으로써 단어를 명시할수도 있다. 정규표현식은 이에 두 가지 방법을 제공한다.</p>
<h1 id="기본"><a href="#기본" class="headerlink" title="기본"></a>기본</h1><h2 id="단어"><a href="#단어" class="headerlink" title="단어"></a>단어</h2><p>간단하게 검색하고 싶은 <strong>특정 단어</strong>만 명시하면 된다.<br>만약 여러 단어를 한번에 검색하고 싶다면 <strong>()</strong> 를 사용하여 <strong>|</strong> 를 통해 다수의 단어를 넣으면 된다.</p>
<h2 id="글자-타입"><a href="#글자-타입" class="headerlink" title="글자 - 타입"></a>글자 - 타입</h2><p><strong>특정 글자</strong>를 명시하고 싶을땐 <strong>단어</strong>와 같은 방식으로 사용하면 되는데 <strong>[]**를 통해 여러 글자를 찾을수도 있고, **[]</strong> 내부에서 확장 표현을 통해 A 부터 Z 까지(<strong>A-Z</strong>) 규칙을 추가하거나 특정 글자를 제외할 수도 있다.</p>
<p>숫자 글자를 검색하고 싶다면 위에서 배운대로 <strong>[0-9]</strong> 도 좋지만 <strong>‘숫자’ 글자 타입</strong>을 명시하여 검색할수도 있다. <strong>글자의 타입</strong>을 명시하기 위한것이 역슬래시(\)며 예를 들면 <strong>‘숫자’ 글자 타입</strong>은 <strong>\d</strong> 로 표현할 수 있고 <strong>‘숫자가 아닌’ 글자 타입</strong>은 <strong>\D</strong> 와 같이 대문자로 표기할 수 있다.</p>
<hr>
<h1 id="확장"><a href="#확장" class="headerlink" title="확장"></a>확장</h1><h2 id="앞-뒤"><a href="#앞-뒤" class="headerlink" title="앞/뒤"></a>앞/뒤</h2><p>특정 단어 혹은 글자를 찾더라도 글의 <strong>가장 앞쪽에</strong> 혹은 <strong>가장 뒷쪽에</strong> 존재하는 것을 찾고 싶을때 사용한다.</p>
<h2 id="횟수"><a href="#횟수" class="headerlink" title="횟수"></a>횟수</h2><p>특정 단어 혹은 글자가 <strong>몇번 반복된 것</strong>을 검색하고 싶은지 명시할 수 있다.</p>
<blockquote>
<p>(abc){1} = abc<br>(abc){1,3} = abc, abcabc, abcabcabc<br>(abc)? = (공백), abc<br>(abc)+ = abc, abcabc …</p>
</blockquote>
<h2 id="캡쳐"><a href="#캡쳐" class="headerlink" title="캡쳐"></a>캡쳐</h2><p>앞부분에서 설명하였듯 패턴으로 검색할 단어를 집합으로 묶을때 사용하거나 <strong>검색한 결과물</strong>들을 활용하려고 할때 결과값을 저장하는 역할을 한다.</p>
<hr>
<p>정규표현식은 한번 배워두면 어떤 개발 언어에서든 모든곳에서 범용적으로 사용가능하며, 개발에서 활용할 수 있는 경우의 수가 매우 많아 유용하다. 이렇게 정리함으로써 이젠 매번 검색할일 없이 잘 사용할 수 있을듯하다.</p>
</div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li><li><a class="pagination-link" href="/page/3/">3</a></li></ul></nav></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Deployment/"><span class="level-start"><span class="level-item">Deployment</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Deployment/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Design-Pattern/"><span class="level-start"><span class="level-item">Design Pattern</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Design-Pattern/Adapter-Decorator/"><span class="level-start"><span class="level-item">Adapter, Decorator</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Factory/"><span class="level-start"><span class="level-item">Factory</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Observer/"><span class="level-start"><span class="level-item">Observer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Singleton/"><span class="level-start"><span class="level-item">Singleton</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Framework/"><span class="level-start"><span class="level-item">Framework</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Framework/Spring/"><span class="level-start"><span class="level-item">Spring</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Language/"><span class="level-start"><span class="level-item">Language</span></span><span class="level-end"><span class="level-item tag">4</span></span></a><ul><li><a class="level is-mobile" href="/categories/Language/Functional-Programming/"><span class="level-start"><span class="level-item">Functional Programming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Swift-4-iOS/"><span class="level-start"><span class="level-item">Swift 4+ / iOS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Programming/Develop/"><span class="level-start"><span class="level-item">Develop</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Licenses/"><span class="level-start"><span class="level-item">Licenses</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Troubleshooting/"><span class="level-start"><span class="level-item">Troubleshooting</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Troubleshooting/Java-8/"><span class="level-start"><span class="level-item">Java 8</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Workplace/"><span class="level-start"><span class="level-item">Workplace</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Aaron Ryu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Aaron Ryu</p><p class="is-size-6 is-block">Software Engineer</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">22</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">20</p></a></div></div></nav><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/aaronryu"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitlab" href="https://gitlab.com/aaronryu"><i class="fab fa-gitlab"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Crucian Carp</a><p class="is-size-7"><span>&copy; 2021 Aaron Ryu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>