<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Crucian Carp</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crucian Carp"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crucian Carp"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Cool heads but warm hearts"><meta property="og:type" content="blog"><meta property="og:title" content="Crucian Carp"><meta property="og:url" content="https://aaronryu.github.io/"><meta property="og:site_name" content="Crucian Carp"><meta property="og:description" content="Cool heads but warm hearts"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://aaronryu.github.io/img/og_image.png"><meta property="article:author" content="Aaron Ryu"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://aaronryu.github.io"},"headline":"Crucian Carp","image":["https://aaronryu.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Aaron Ryu"},"description":"Cool heads but warm hearts"}</script><link rel="alternate" href="/atom.xml" title="Crucian Carp" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/solarized-dark.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-134840627-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-134840627-1');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Crucian Carp</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item is-active" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2021-02-02</div></span><span class="level-item"><a class="link-muted" href="/categories/Workplace/">Workplace</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/">Hexo, Icarus(Theme) 새 버전으로 마이그레이션 및 커스터마이징</a></h1><div class="content"><h1 id="21년-첫-블로그-글-발행시-오류"><a href="#21년-첫-블로그-글-발행시-오류" class="headerlink" title="21년 첫 블로그 글 발행시 오류"></a>21년 첫 블로그 글 발행시 오류</h1><p>업무를 하면서 정말 많은 것들을 경험하고, 배우지만 정작 시간을 내서 정리하여 어딘가에 작성해놓으지 않으면 기억이나지 않더군요. 사내 위키를 잘 활용했었는데, 아무래도 더 많은 분들과 정보 및 의견을 공유하고 싶어서 블로그에 다시 글을 올리려했습니다. 얼마전에 겪었던 이슈에 관련된 글을 hexo 로 작성하여 <code>hexo g -d</code> 를 통해 발행하려하니 갑자기 오류가 발생했습니다.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer.</span><br><span class="line">Received an instance of Object at copyFile</span><br></pre></td></tr></table></figure>
<p>구글링을 해보니 <strong>node 버전을 Downgrade</strong> 하여야하며, 현재 <strong>hexo 5.0.0 버전 이후로 픽스되었다</strong>는 스레드<a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues/4263">^1</a>를 찾았습니다. 생각해보니 작년말에 개발 공부를 위해 라이브러리나 프레임워크 버전들을 일괄적으로 다 올렸었습니다. 그중에 node.js 가 15 버전으로 업데이트 되어있었습니다. node.js 최신 버전을 아무래도 글로벌로 업데이트하였어서 hexo 에서 npm 동작시 충돌이 일어나는것같습니다.</p>
<h1 id="Hexo-최신-버전-마이그레이션"><a href="#Hexo-최신-버전-마이그레이션" class="headerlink" title="Hexo 최신 버전 마이그레이션"></a>Hexo 최신 버전 마이그레이션</h1><p>사용중이던 버전은 <code>Hexo 3.8.0 / Icarus 2.3.0</code> 인데 확인해본 최신 버전은 <code>Hexo 5.3.0 / Icarus 4.1.1</code> 이었습니다. Hexo 먼저 버전업을 위해서 <strong>package.json</strong> 에 기존 패키지들을 모두 지우고 hexo 버전을 <code>5.3.0</code> 버전으로 바꾸었습니다. <code>npm install</code> 수행 후 깨지는 패키지들을 일일히 넣어주기 귀찮아서, 새 디렉토리에서 <code>hexo init</code> 하여 자동 생성된 <strong>package.json</strong> 을 참조했습니다.</p>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/version-change-log.png" class=""></center>

<h1 id="최신-Hexo-와-구-Icarus-충돌"><a href="#최신-Hexo-와-구-Icarus-충돌" class="headerlink" title="최신 Hexo 와 구 Icarus 충돌"></a>최신 Hexo 와 구 Icarus 충돌</h1><p>hexo 버전 업데이트 후 <code>hexo server</code> 로 로컬에 페이지를 띄워보니 <strong>icarus 테마 파일에서 계속해서 특정 변수를 찾을 수 없음 등의 오류</strong>가 발생하였습니다. 구글링하니 이 또한 버전문제로 파악되어 <strong>기존의 icarus 테마의 커스터마이징 설정 <code>_config.yml</code> 만을 백업한 채 모두 지우고</strong> icarus 를 최신버전으로 (1) npm install 이 아닌 <strong>(2) git submodule</strong> 을 통해 (커스터마이징을 위해) 설치하였습니다. 다시 실행하니 <strong>jsx 코드만 덩그러니 노출되는 문제</strong>가 발생하였는데 jsx 라서 <strong>react.js</strong> 인줄알았더니 <strong>inferno.js</strong> 로 개발되어있어서 해당 라이브러리를 설치하여 해결하었습니다.</p>
<h1 id="Icarus-JSX-커스터마이징"><a href="#Icarus-JSX-커스터마이징" class="headerlink" title="Icarus JSX 커스터마이징"></a>Icarus JSX 커스터마이징</h1><p>어떤 테마든 수정을 해야하는 깐깐한 성격탓에 예전 icarus 테마는 ejs 코드를 분석해서 커스터마이징을 따로 하였었습니다. <strong>예전엔 ejs-based 였던 icarus 가 이젠 jsx-based 로 되어서, 이전 커스터마이징 코드를 그대로 사용할 순 없고, 또 다시 분석해서 수정해야했습니다.</strong> 프론트 개발을 쭉 react.js 로 해왔었고 icarus 개발 프레임워크인 inferno.js 도 react-like 를 표방하는만큼 디버깅만 할 줄 알면 크게 어렵진 않을것같았고, 실제로도 그랬습니다. 다만, icarus 프로젝트가 jsx 로 변환되면서 과거에 난잡했던 ejs 구조에서 컴포넌트 단위로 모듈화가 잘되어졌기 때문에 <strong>페이지마다 렌더링을 다르게해야하는 부분은 공통 컴포넌트에 예외 조건을 넣는 방식</strong>으로 처리해야했습니다. 아래 커스터마이징한 코드들을 보시면 이해가 되실겁니다.</p>
<h2 id="네비게이션바-로고"><a href="#네비게이션바-로고" class="headerlink" title="네비게이션바 로고"></a>네비게이션바 로고</h2><p>제일 상단의 네비게이션바에 기본적으로는 로고 이미지를 올리도록 설정되어있지만, 해당 블로그를 표현할 수 있는 단어로 치환 및 폰트 사이즈를 설정하였습니다.</p>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/named-logo-navbar.png" class=""></center>

<figure class="highlight yaml"><figcaption><span>_config.icarus.yml (로고 명칭)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Path or URL to the website&#x27;s logo</span></span><br><span class="line"><span class="attr">logo:</span></span><br><span class="line">    <span class="attr">text:</span> <span class="string">Crucian</span> <span class="string">Carp</span></span><br></pre></td></tr></table></figure>
<figure class="highlight yaml"><figcaption><span>include/style/navbar.styl (폰트 사이즈 추가)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.navbar-logo</span></span><br><span class="line">    <span class="string">img</span></span><br><span class="line">        <span class="attr">max-height:</span> <span class="string">$logo-height</span></span><br><span class="line">    <span class="attr">font-size:</span> <span class="number">1.</span><span class="string">4rem</span></span><br></pre></td></tr></table></figure>
<h2 id="좌측-위젯-프로필-재설정"><a href="#좌측-위젯-프로필-재설정" class="headerlink" title="좌측 위젯 - 프로필 재설정"></a>좌측 위젯 - 프로필 재설정</h2><p>본 블로그에서는 웹 검색에 이점을 버리더라도 글의 구성을 제일 심플하게 하고싶었기 때문에 Tag 를 모두 사용하지 않습니다. 좌측 위젯에 프로필에서 <strong>Post 개수</strong>와 <strong>Category 개수</strong>만 보여주도록 <strong>Tag 개수는 표기하지 않도록 코드를 삭제</strong>하였습니다.</p>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/tag-removed-profile.png" class=""></center>

<figure class="highlight jsx"><figcaption><span>layout/widget/profile.jsx (아래 코드 모두 삭제)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;level-item has-text-centered is-marginless&quot;</span>&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;heading&quot;</span>&gt;&#123;counter.tag.title&#125;&lt;/p&gt;</span><br><span class="line">        &lt;a href=&#123;counter.tag.url&#125;&gt;</span><br><span class="line">            &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;title&quot;</span>&gt;&#123;counter.tag.count&#125;&lt;/p&gt;</span><br><span class="line">        &lt;/a&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>layout/widget/profile.jsx (아래 코드 모두 삭제)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tag: &#123;</span><br><span class="line">    count: tagCount,</span><br><span class="line">    title: _p(<span class="string">&#x27;common.tag&#x27;</span>, tagCount),</span><br><span class="line">    url: url_for(<span class="string">&#x27;/tags&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="포스트-상단-시간포맷-변경"><a href="#포스트-상단-시간포맷-변경" class="headerlink" title="포스트 상단 시간포맷 변경"></a>포스트 상단 시간포맷 변경</h2><p>icarus 테마는 기본적으로 포스트 상단에 <strong>글 최초 작성 이후 얼마나 지났는지</strong>, <strong>업데이트 후 얼마나 지났는지</strong> 표기해주는데, 개인적으로는 과거 네이버같은 WYSIWYG 블로그에서 표기해주는 포스트 <strong>최초 작성일을 날짜 형태</strong>로 보는것을 선호해서 이 또한 바꿔주었습니다.</p>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/erased-elapsed-time.png" class=""></center>

<figure class="highlight jsx"><figcaption><span>layout/common/article.jsx (<time> 을 <div> 로 변경 및 Update Date 삭제)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;level-left&quot;</span>&gt;</span><br><span class="line">    &#123;<span class="comment">/* Creation Date */</span>&#125;</span><br><span class="line">    &#123;page.date &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;level-item&quot;</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;&#123;</span></span></span></span><br><span class="line"><span class="xml">        __html: _p(`<span class="tag">&lt;<span class="name">div</span>&gt;</span>$&#123;date(page.date)&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span>`)</span></span><br><span class="line"><span class="xml">    &#125;&#125;&gt;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span>&#125;</span><br><span class="line">    &#123;<span class="comment">/* author */</span>&#125;</span><br><span class="line">    &#123;page.author ? <span class="xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;level-item&quot;</span>&gt;</span> &#123;page.author&#125; <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span> : <span class="literal">null</span>&#125;</span><br></pre></td></tr></table></figure>
<h2 id="폰트-변경"><a href="#폰트-변경" class="headerlink" title="폰트 변경"></a>폰트 변경</h2><p>폰트는 hexo 블로그 처음 시작할때 글들을 모두 한글로 작성할것이라 자간 간격이 아주 조금은 벌어져있는것이 가독성이 좋다고 판단하여 hexo 사용 처음부터 사용해왔던 나눔고딕 폰트를 계속 사용하기로 했습니다.</p>
<figure class="highlight jsx"><figcaption><span>include/style/base.styl ('Nanum Gothic' 폰트 추가 및 기존 미사용 폰트 삭제)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$family-sans-serif ?= <span class="string">&#x27;Ubuntu&#x27;</span>, <span class="string">&#x27;Nanum Gothic&#x27;</span>, sans-serif</span><br><span class="line">$family-code ?= <span class="string">&#x27;Source Code Pro&#x27;</span>, monospace, <span class="string">&#x27;Microsoft YaHei&#x27;</span></span><br></pre></td></tr></table></figure>
<h2 id="위젯-amp-포스트-너비-재설정"><a href="#위젯-amp-포스트-너비-재설정" class="headerlink" title="위젯 &amp; 포스트 너비 재설정"></a>위젯 &amp; 포스트 너비 재설정</h2><p><strong>icarus 에서 제공하는 위젯은 (1) 우측, (2) 좌측</strong>이 있는데 이 둘을 모두 사용하면 중간에 포스트 너비가 짧아져 가독성을 떨어트릴수있다고 판단했습니다. <strong>좌측 위젯만 사용</strong>했음에도 위젯 너비가 포스트 너비에 비해 길다고 생각하여 조율해주었습니다.</p>
<ul>
<li><strong>4(좌측 위젯) + 8(글) = 12</strong></li>
</ul>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/previous-width.png" class=""></center>

<ul>
<li><strong>3(좌측 위젯) + 9(글) = 12</strong></li>
</ul>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/newest-width.png" class=""></center>

<p>icarus 의 너비 분배는 <strong>bulma css 12 셀 규칙</strong>을 사용합니다. 기존엔 아래와 같았습니다.</p>
<ul>
<li>4(좌측 위젯) + 8(글) = <strong>12</strong></li>
<li>8(글) + 4(우측 위젯) = <strong>12</strong></li>
<li>3(좌측 위젯) + 6(글) + 3(우측 위젯) = <strong>12</strong></li>
</ul>
<p>여기서 본 블로그는 위젯을 포스트의 가독성을 위해 좌측 하나만 사용할것이기 때문에</p>
<ul>
<li>3(좌측 위젯) + 9(글) = <strong>12</strong></li>
<li>9(글) + 3(우측 위젯) = <strong>12</strong></li>
</ul>
<p>포스트의 너비는 <strong>8</strong>에서 <strong>9</strong>으로 위젯은 <strong>4</strong>에서 <strong>3</strong>으로 재정의하였습니다.</p>
<figure class="highlight jsx"><figcaption><span>layout/common/widgets.jsx (위젯 하나의 너비 4 -> 3)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColumnSizeClass</span>(<span class="params">columnCount</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (columnCount) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;is-3-tablet is-3-desktop is-3-widescreen&#x27;</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&#x27;is-3-tablet is-3-desktop is-2-widescreen&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>layout/layout.js (포스트 너비 8 -> 9)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;columns&quot;</span>&gt;</span><br><span class="line">    &lt;div <span class="class"><span class="keyword">class</span></span>=&#123;classname(&#123;</span><br><span class="line">        column: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;order-2&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;column-main&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">&#x27;is-12&#x27;</span>: columnCount === <span class="number">1</span>,</span><br><span class="line">        <span class="string">&#x27;is-9-tablet is-9-desktop is-9-widescreen&#x27;</span>: columnCount === <span class="number">2</span>,</span><br><span class="line">        <span class="string">&#x27;is-9-tablet is-9-desktop is-8-widescreen&#x27;</span>: columnCount === <span class="number">3</span></span><br><span class="line">    &#125;)&#125; dangerouslySetInnerHTML=&#123;&#123; <span class="attr">__html</span>: body &#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">    &lt;Widgets site=&#123;site&#125; config=&#123;config&#125; helper=&#123;helper&#125; page=&#123;page&#125; position=&#123;<span class="string">&#x27;left&#x27;</span>&#125; /&gt;</span><br><span class="line">    &lt;Widgets site=&#123;site&#125; config=&#123;config&#125; helper=&#123;helper&#125; page=&#123;page&#125; position=&#123;<span class="string">&#x27;right&#x27;</span>&#125; /&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<h2 id="About-내-위젯-플러그인-제거"><a href="#About-내-위젯-플러그인-제거" class="headerlink" title="About 내 위젯, 플러그인 제거"></a>About 내 위젯, 플러그인 제거</h2><p>상단 네비게이션바에서 About 을 클릭하시면 저에 대한 개략적인 정보를 아실수있습니다. 또한 개인 Resume 페이지를 따로 만들어서 굳이 Google docs 나 Linkedin 으로 접속하지 않아도 저의 이력을 한눈에 볼 수 있도록 Resume 페이지도 따로 마련해두었습니다.</p>
<p>구 icarus 의 ejs 시절에는 About, Resume 페이지 모두 각각 따로 ejs 페이지가 있었기때문에 해당 페이지만 수정하면 되었었지만, <strong>새 icarus 의 jsx 에서는 포스트에 대한 컴포넌트가 about, resume 등 모든 페이지의 기본 컴포넌트로 사용</strong>되고있었습니다. 정적 리스트를 만들어서 특정 페이지에 대해서만 위젯과 플러그인을 표시하지 않도록 필터링 하는 로직을 넣었습니다.</p>
<ul>
<li>위젯도 위젯이지만 buy me a coffee 가 킬링포인트입니다.</li>
</ul>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/previous-about-page.png" class=""></center>

<ul>
<li>About 페이지는 저를 표현하는것만으로 충분합니다.</li>
</ul>
<center><img src="/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/newest-about-page.png" class=""></center>

<figure class="highlight jsx"><figcaption><span>layout/layout.jsx (About, Resume 여부 조건)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isAboutPage = [ <span class="string">&quot;about/index.html&quot;</span>, <span class="string">&quot;resume/index.html&quot;</span> ].includes(page.path);</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>layout/layout.jsx (좌측, 우측 위젯에 About, Resume 여부 조건 추가)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Head site=&#123;site&#125; config=&#123;config&#125; helper=&#123;helper&#125; page=&#123;page&#125; /&gt;</span><br><span class="line">&lt;body <span class="class"><span class="keyword">class</span></span>=&#123;<span class="string">`is-<span class="subst">$&#123;columnCount&#125;</span>-column`</span>&#125;&gt;</span><br><span class="line">    &lt;Navbar config=&#123;config&#125; helper=&#123;helper&#125; page=&#123;page&#125; /&gt;</span><br><span class="line">    &lt;section <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;section&quot;</span>&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;container&quot;</span>&gt;</span><br><span class="line">            &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">&quot;columns&quot;</span>&gt;</span><br><span class="line">                &lt;div <span class="class"><span class="keyword">class</span></span>=&#123;classname(&#123;</span><br><span class="line">                    column: <span class="literal">true</span>,</span><br><span class="line">                    <span class="string">&#x27;order-2&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="string">&#x27;column-main&#x27;</span>: <span class="literal">true</span>,</span><br><span class="line">                    <span class="string">&#x27;is-12&#x27;</span>: columnCount === <span class="number">1</span>,</span><br><span class="line">                    <span class="string">&#x27;is-9-tablet is-9-desktop is-9-widescreen&#x27;</span>: columnCount === <span class="number">2</span>,</span><br><span class="line">                    <span class="string">&#x27;is-9-tablet is-9-desktop is-8-widescreen&#x27;</span>: columnCount === <span class="number">3</span></span><br><span class="line">                &#125;)&#125; dangerouslySetInnerHTML=&#123;&#123; <span class="attr">__html</span>: body &#125;&#125;&gt;&lt;/div&gt;</span><br><span class="line">                &#123;!isAboutPage &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Widgets</span> <span class="attr">site</span>=<span class="string">&#123;site&#125;</span> <span class="attr">config</span>=<span class="string">&#123;config&#125;</span> <span class="attr">helper</span>=<span class="string">&#123;helper&#125;</span> <span class="attr">page</span>=<span class="string">&#123;page&#125;</span> <span class="attr">position</span>=<span class="string">&#123;</span>&#x27;<span class="attr">left</span>&#x27;&#125; /&gt;</span></span>&#125;</span><br><span class="line">                &#123;!isAboutPage &amp;&amp; <span class="xml"><span class="tag">&lt;<span class="name">Widgets</span> <span class="attr">site</span>=<span class="string">&#123;site&#125;</span> <span class="attr">config</span>=<span class="string">&#123;config&#125;</span> <span class="attr">helper</span>=<span class="string">&#123;helper&#125;</span> <span class="attr">page</span>=<span class="string">&#123;page&#125;</span> <span class="attr">position</span>=<span class="string">&#123;</span>&#x27;<span class="attr">right</span>&#x27;&#125; /&gt;</span></span>&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>layout/common/article.jsx</strong> - 포스트 하단 모든 플러그인에 About, Resume 여부 조건 추가</li>
</ul>
<figure class="highlight jsx"><figcaption><span>layout/common/article.jsx (About, Resume 여부 조건)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isAboutPage = [ <span class="string">&quot;about/index.html&quot;</span>, <span class="string">&quot;resume/index.html&quot;</span> ].includes(page.path);</span><br></pre></td></tr></table></figure>
<figure class="highlight jsx"><figcaption><span>layout/common/article.jsx (포스트 하단 모든 플러그인에 About, Resume 여부 조건 추가)</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="comment">/* Licensing block */</span>&#125;</span><br><span class="line">&#123;!isAboutPage &amp;&amp; !index &amp;&amp; article &amp;&amp; article.licenses &amp;&amp; <span class="built_in">Object</span>.keys(article.licenses)</span><br><span class="line">    ? <span class="xml"><span class="tag">&lt;<span class="name">ArticleLicensing.Cacheable</span> <span class="attr">page</span>=<span class="string">&#123;page&#125;</span> <span class="attr">config</span>=<span class="string">&#123;config&#125;</span> <span class="attr">helper</span>=<span class="string">&#123;helper&#125;</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* Tags */</span>&#125;</span><br><span class="line">&#123;!isAboutPage &amp;&amp; !index &amp;&amp; page.tags &amp;&amp; page.tags.length ? <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;article-tags is-size-7 mb-4&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;mr-2&quot;</span>&gt;</span>#<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">    &#123;page.tags.map(tag =&gt; &#123;</span></span><br><span class="line"><span class="xml">        return <span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;link-muted mr-2&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;tag&quot;</span> <span class="attr">href</span>=<span class="string">&#123;url_for(tag.path)&#125;</span>&gt;</span>&#123;tag.name&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span>;</span></span><br><span class="line"><span class="xml">    &#125;)&#125;</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* &quot;Read more&quot; button */</span>&#125;</span><br><span class="line">&#123;!isAboutPage &amp;&amp; index &amp;&amp; page.excerpt ? <span class="xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">class</span>=<span class="string">&quot;article-more button is-small is-size-7&quot;</span> <span class="attr">href</span>=<span class="string">&#123;</span>`$&#123;<span class="attr">url_for</span>(<span class="attr">page.link</span> || <span class="attr">page.path</span>)&#125;#<span class="attr">more</span>`&#125;&gt;</span>&#123;__(&#x27;article.more&#x27;)&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* Share button */</span>&#125;</span><br><span class="line">&#123;!isAboutPage &amp;&amp; !index ? <span class="xml"><span class="tag">&lt;<span class="name">Share</span> <span class="attr">config</span>=<span class="string">&#123;config&#125;</span> <span class="attr">page</span>=<span class="string">&#123;page&#125;</span> <span class="attr">helper</span>=<span class="string">&#123;helper&#125;</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* Donate button */</span>&#125;</span><br><span class="line">&#123;!isAboutPage &amp;&amp; !index ? <span class="xml"><span class="tag">&lt;<span class="name">Donates</span> <span class="attr">config</span>=<span class="string">&#123;config&#125;</span> <span class="attr">helper</span>=<span class="string">&#123;helper&#125;</span> /&gt;</span></span> : <span class="literal">null</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="comment">/* Post navigation */</span>&#125;</span><br><span class="line">&#123;!isAboutPage &amp;&amp; !index &amp;&amp; (page.prev || page.next) ? <span class="xml"><span class="tag">&lt;<span class="name">nav</span> <span class="attr">class</span>=<span class="string">&quot;post-navigation mt-4 level is-mobile&quot;</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml">&#123;/* Comment */&#125;</span></span><br><span class="line"><span class="xml">&#123;!isAboutPage &amp;&amp; !index ? <span class="tag">&lt;<span class="name">Comment</span> <span class="attr">config</span>=<span class="string">&#123;config&#125;</span> <span class="attr">page</span>=<span class="string">&#123;page&#125;</span> <span class="attr">helper</span>=<span class="string">&#123;helper&#125;</span> /&gt;</span> : null&#125;</span></span><br></pre></td></tr></table></figure>
<p>지금 보고 계신 이 블로그와 본 포스트는 위 요소들을 모두 커스터마이징한 Icarus 테마로 구성된것입니다. 몇년전에 hexo 나 icarus 를 적용하셨었고, 마이그레이션을 앞두고 계시거나 커스텀하게 수정하는걸 원하시는 분께 본 글이 도움이 되셨으면 좋겠습니다. 이후로 CSS, JSX 에 자잘한 수정이 있을순 있으나 따로 다 업데이트하진 않으려합니다.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2021-01-31</div></span><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Java-8/">Java 8</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2021/01/31/problems-when-using-parallel-stream-with-hash-map/">[Troubleshooting] ParallelStream 과 HashMap 함께 사용시 이슈</a></h1><div class="content"><h1 id="Monolithic-Architecture-gt-MSA-전환으로-인한-성능-저하"><a href="#Monolithic-Architecture-gt-MSA-전환으로-인한-성능-저하" class="headerlink" title="Monolithic Architecture -&gt; MSA 전환으로 인한 성능 저하"></a>Monolithic Architecture -&gt; MSA 전환으로 인한 성능 저하</h1><p>최근 Monolithic Architecture 구조의 레가시 시스템을 MSA 구조로 바꾸는 리플랫폼을 진행하였었습니다. 기존 레가시 시스템은 여러 서브도메인에 해당하는 테이블들이 단일 쿼리에 수많은 Join 으로 연결되어있어서 성능이 매우 좋았지만, 유지보수성에 있어서는 최악의 구조를 갖고있었습니다. 예약, 결제, 정산, 상품 등 각 서브도메인들을 서비스들로 나누어서 API 호출을 통해 요청을 처리하도록 만들고보니 유지보수성은 올라갔지만 SQL Join 을 사용하던 것을 API 로 바꾸다보니 네트워크 시간에 의해 성능이 저하되어 이 해결이 또 다른 리플랫폼의 챌린지 포인트였습니다.</p>
<h1 id="Java-8-Stream-gt-ParallelStream-을-통한-성능-개선"><a href="#Java-8-Stream-gt-ParallelStream-을-통한-성능-개선" class="headerlink" title="Java 8 Stream -&gt; ParallelStream 을 통한 성능 개선"></a>Java 8 Stream -&gt; ParallelStream 을 통한 성능 개선</h1><p>SQL Join 을 API 호출 및 Java 8 로직으로 변환하면서 stream 을 곳곳에서 자주 사용하였었는데, 단순하게 이걸 parallelStream 으로 바꾸었더니 몇초 걸렸던 느린 성능이 1초 이내 ms 단위로 처리되었기 때문에 남용하기 시작하였습니다. 그리고 그 무게는 이후 굉장히 무거운 몇몇의 이슈로 다가오게됩니다.</p>
<h1 id="No-Silver-Bullet-Java-8-ParallelStream"><a href="#No-Silver-Bullet-Java-8-ParallelStream" class="headerlink" title="No Silver Bullet - Java 8 ParallelStream"></a>No Silver Bullet - Java 8 ParallelStream</h1><h2 id="Java-8-ParallelStream"><a href="#Java-8-ParallelStream" class="headerlink" title="Java 8 ParallelStream"></a>Java 8 ParallelStream</h2><p>ParallelStream 는 Java 8 에서 도입된 <strong>멀티스레드 프로그래밍</strong>을 매우 쉽게 사용할수 있게 해주는 도구입니다. 학부때도 <strong>멀티스레드</strong>가 제일 복잡하고 힘들었었는데, 이걸 단 하나의 코드로 쉽게 사용하게 해준다니 스레드 관리의 복잡함에 혀를 내둘렀던 저에겐 굉장히 매력적으로 다가왔습니다. 또한 타 웹페이지에서 고전적 for-each, stream, parallelStream 성능 비교를 보면 당연하겠지만 말도 안되게 빠른 성능을 제공해주는걸 알 수 있습니다.</p>
<p><strong>기존 ExecutorService</strong></p>
<ul>
<li>스레드 풀 내 스레드 개수를 정의하고<br>(ExecutorService executor = Executors.newFixedThreadPool(5))</li>
<li>분할하기 원하는 작업을 위 executor 에 하나씩 지정(execute())하면 적합한 스레드를 자동으로 할당하여 수행해줍니다.</li>
<li>그리고 사용한 스레드 풀은 닫습니다 (shutdown())</li>
</ul>
<p><strong>신규 ForkJoinPool</strong></p>
<ul>
<li>JVM 내 공유되는 ForkJoinPool 스레드 풀 내 스레드 개수를 <strong>“프로세서 개수 - 1”</strong> 로 정의합니다.<br>(예, 4 코어 = 3 스레드, 병렬성 향상을 위해 직접 스레드 개수 설정도 가능합니다.)<br>(예, -Djava.util.concurrent.ForkJoinPool.common.parallelism = 6)</li>
<li>ForkJoinPool 는 <strong>Queue 가 추가된</strong> 기존 ExecutorService 의 구현체로 </li>
<li>스레드 각각을 (1) Fork 를 통해 Task 를 분담하고 (2) Join 을 통해 결과를 합치는 과정을 반복해서 동시성을 제공합니다.</li>
<li><strong>ParallelStream 은 이 신규 ForkJoinPool 를 통해 동작됩니다.</strong></li>
</ul>
<p><strong>ParallelStream</strong> 동작의 개요를 알았으니, 이걸 사용하면서 맞닥트린 이슈와 그 원인을 살펴보도록 하겠습니다.</p>
<h2 id="HashMap-의-put-get-은-not-thread-safe"><a href="#HashMap-의-put-get-은-not-thread-safe" class="headerlink" title="HashMap 의 put/get 은 not-thread-safe"></a>HashMap 의 put/get 은 not-thread-safe</h2><p>ParallelStream 을 통해 서비스 성능 개선을 이루고 많은 시간이 지나서 갑자기 서버 인스턴스 CPU 가 75% 를 넘어서서 오랜시간동안 계속 내려오지 않는 온콜이 발생하였었습니다. 점유율이 오랜시간동안 75% 에서 내려오지 않자 <strong>무한 루프에 진입한것으로 보여 쓰레드 덤프를 분석해보니 parallelStream 에서 할당된 스레드에서 block 인채 멈춰있는걸 발견하였습니다.</strong></p>
<p>문제의 로직은 ParallelStream 을 통해 not-thread-safe 인 HashMap 에 동시적으로 put 처리한 부분이었습니다.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Boolean&gt; result = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">sampleList.parallelStream().forEach(each -&gt;</span><br><span class="line">  result.put(each.getId(), isSample)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>간단하게 생각하면 List 가 아닌 Map 이기때문에 주입되는 순서도 상관없고, 값이 잘 들어가기만 하면 본 코드는 문제없어 보입니다. <strong>하지만 이는 HashMap 의 구조와 Rehashing 을 전혀 고려하지 않은 생각입니다.</strong> HashMap 은 새로운 키, 값을 주입(put)시 아래의 과정을 거쳐 이뤄집니다.</p>
<ul>
<li>(1) 새로 추가하는 키에 대한 Hash 를 생성하고</li>
<li>(2) Hash 테이블 내 해당 Hash 인덱스에 포인터를 통해 해당 키를 적재하게 됩니다.</li>
<li>(3) 만약 Hash 인덱스에 키들이 일정 개수를 넘으면 Rehashing 을 통해<br>Hash 인덱스를 나누어 키들을 분리 적재하게 됩니다.</li>
</ul>
<h2 id="Race-Condition"><a href="#Race-Condition" class="headerlink" title="Race Condition"></a>Race Condition</h2><p>위 과정 중에 (2)번과 (3)번은 키들 간에 포인터 변경 부분이 thread-safe 하지않아서, 다수의 스레드가 한번에 포인터를 변경하려 하면 문제가 발생할 수 있습니다. 만약 스레드 1과 스레드 2가 각자 다른 키를 같은 Hash 인덱스에 추가하고 두 스레드에서 동시에 rehashing 이 일어난다면, <strong>두 스레드가 키들에 대한 포인터들을 재설정하는 과정에서 서로 꼬여 포인트간 사이클이 발생하게 됩니다.</strong> HashMap 특성상 키를 넣거나(put) 조회할때(get) 특정 Hash 에 적재된 키들을 for 문을 통해서 순회하기 때문에 위 사이클은 무한루프에 빠져버립니다. 발생한 온콜의 CPU 상위 점유의 원인인 셈입니다. 키들에 대한 포인터들을 다수의 스레드가 변경하면서 사이클을 만들기도하지만 <strong>포인터가 유실되어 키를 10000 번 put 주입하였는데 실제 HashMap 에 저장된 키는 10000 개가 아닌 황당한 경우도 발생합니다.</strong></p>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h1><p><strong>Java ParallelStream 을 활용</strong>하여 <strong>외부 HashMap 애 put 을 수행</strong>하게 되면, ForkJoinPool 를 통해 다수의 스레드들이 각자 put 을 수행하게 됩니다. 이때 HashMap 의 put 은 <strong>(1) hash 값 계산</strong>과 <strong>(2) 값들간의 포인터 변경</strong>을 통해 수행되는데, <strong>(2) 포인터 변경부분이 thread-safe 하지 않기 때문에 각 스레드간 포인터 조작시 Race Condition 이 발생할 수 있습니다.</strong> </p>
<ul>
<li><strong>키들 간 포인터가 서로를 가리켜서</strong> get, put 수행시에 무한루프에 걸리는 경우</li>
<li><strong>키들 간 포인터가 유실되면서</strong> 실제 10000 번 put 수행하더라도, 실제 HashMap 사이즈가 10000 이 안되는 경우</li>
</ul>
<p>온콜 해결을 위해서 서비스 전체 로직에서 ParallelStream 이 사용되는 부분을 모두 걷어내었었습니다. 해결을 위해 ConcurrentHashMap 을 사용해도되지만 해당 로직에서 일반적으로 ParallelStream 의 루프 횟수가 10000 건을 넘어서는 유즈케이스도 있었기 때문에 스레드를 잘 활용한다고 하여도 CPU 와 메모리에 무리를 줄 수 있었기 때문에 로직을 효율적으로 변경하는것으로 해결하였습니다.</p>
<hr>
<p>참조</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.naver.com/tmondev/220945933678">https://blog.naver.com/tmondev/220945933678</a></li>
<li><a target="_blank" rel="noopener" href="http://www.h-online.com/developer/features/The-fork-join-framework-in-Java-7-1762357.html">http://www.h-online.com/developer/features/The-fork-join-framework-in-Java-7-1762357.html</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@itugs/custom-forkjoinpool-in-java-8-parallel-stream-9090882472db">https://medium.com/@itugs/custom-forkjoinpool-in-java-8-parallel-stream-9090882472db</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2020-08-27</div></span><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Javascript/">Javascript</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/27/how-does-a-javascript-engine-work/">Javascript 엔진 개요 및 실행 과정으로 살펴보는 Hoisting 과 Closure</a></h1><div class="content"><html><head></head><body><h1 id="자바스크립트"><a href="#자바스크립트" class="headerlink" title="자바스크립트"></a>자바스크립트</h1><p>자바스크립트는 웹 페이지의 세 요소중 하나입니다.</p>
<ul>
<li><strong>HTML</strong>: 웹 페이지(문서) 포맷을 정의하는 마크업 언어</li>
<li><strong>CSS</strong>: 웹 페이지(문서)의 디자인 요소에 대한 언어</li>
<li><strong>Javascript</strong>: 웹 페이지(문서)와 사용자 사이의 interaction 이벤트에 대한 모든 처리</li>
</ul>
<p>자바스크립트는 일반 프로그래밍 언어와 동일하게 함수 선언 및 호출를 통해 바로 동기적(Synchronous)으로 실행할수도 있고, 콜백을 통해 특정 이벤트 시점에 비동기적(Synchronous)으로 수행하게 만들수도 있습니다. 실행을 위해서는 개발자가 작성한 자바스크립트 언어를 실행 가능한 언어로 변형하여 실행, 실행 순서 및 메모리를 관리하는 엔진이 필요합니다.</p>
<blockquote>
<p><strong>하나의 브라우저</strong>는 <strong>HTML/CSS 엔진</strong>과 <strong>자바스크립트 엔진</strong>으로 구성되어있습니다.</p>
</blockquote>
<p>흔히 알고 있는 Chrome, Internet Exploerer, Safari 등 다양한 웹 브라우저마다 각자 자신들만의 <strong>HTML/CSS/Javascript 엔진</strong>를 갖고 있습니다. <strong>자바스크립트 엔진</strong> 중 유명한것이라면 Chrome 브라우저와 node.js 에서 사용되고있는 V8 가 있습니다. 앞으로 설명할 <strong>자바스크립트 엔진 및 런타임</strong><a target="_blank" rel="noopener" href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf">^9</a>은 이 V8 기준으로 설명할것입니다. 잠깐 앞으로 계속 언급될 <strong>자바스크립트 엔진</strong>과 <strong>자바스크립트 런타임</strong> 용어를 확실히 짚고 넘어가겠습니다. 더 상세한 설명은 소제목 <strong>자바스크립트 엔진 및 런타임</strong> 에서 하겠습니다.</p>
<blockquote>
<p><strong>자바스크립트 런타임</strong>은 자바스크립트 동작을 위해 필요로 하는 <strong>자바스크립트 엔진</strong>을 포함한 API 및 기능의 집합입니다.<br><strong>자바스크립트 엔진</strong>은 좁은 의미로 자바스크립트 인터프리팅 역할을 전담하는것으로 Java 의 JVM 으로 이해하면 됩니다.</p>
</blockquote>
<p>예를 들면 <strong>V8 자바스크립트 엔진</strong>기반의 <strong>자바스크립트 런타임</strong>으로 우리가 사용하는 Chrome 이 동작되는것입니다.</p>
<h1 id="자바스크립트-인터프리트-언어"><a href="#자바스크립트-인터프리트-언어" class="headerlink" title="자바스크립트 = 인터프리트 언어"></a>자바스크립트 = 인터프리트 언어</h1><blockquote>
<p><strong>자바스크립트</strong>는 스크립트 언어이자 엔진을 통해 처리되는 <strong>인터프리트 언어</strong>입니다. 다만, <strong>컴파일 과정</strong>을 갖고 있습니다.</p>
</blockquote>
<p><strong>자바스크립트 엔진</strong>은 일반적인 쉘 스크립트가 한 라인씩 바로 실행되는 <strong>인터프리트 언어</strong>와는 조금 다른 실행 구조를 갖고있습니다. 먼저, 실행할 전체 함수를 실행 직전에 간단히 변수 및 함수 선언들만 스캔하는 <strong>(A) JIT 컴파일 과정</strong>을 거쳐, 그 후 <strong>(B) 수행 과정</strong>의 사이클로 실행<a target="_blank" rel="noopener" href="https://dev.to/genta/is-javascript-a-compiled-language-20mf">^5</a>됩니다. 여기서 <strong>(1) JIT 컴파일 과정</strong>은 실제 우리들이 흔히 알고있는 C++, Java 와 같은 컴파일 언어에서 중간코드를 만드는 <strong>AOT(Ahead-of-Time) 컴파일 과정</strong>과는 다릅니다.<a target="_blank" rel="noopener" href="https://dev.to/deanchalk/comment/8h32">^7</a> 자바스크립트를 인터프리트 언어라고 알고있었는데 좀 놀랍죠. 이렇게 자바스크립트 엔진에 단순히 컴파일 과정이 있다는 사실만으로 자바스크립트를 <strong>컴파일 언어</strong>로 언급하기도 합니다만 엄연히 기존 컴파일 언어의 정의와 다르고<a target="_blank" rel="noopener" href="https://gist.github.com/kad3nce/9230211#compiler-theory">^8</a>, 자바스크립트 엔진은 함수 실행 시점에 컴파일을 진행하므로 <strong>인터프리트 언어</strong>입니다.<a target="_blank" rel="noopener" href="https://dev.to/deanchalk/comment/8h32">^7</a></p>
<blockquote>
<p>자바스크립트 엔진은 <strong>(A) JIT 컴파일 과정</strong>과 <strong>(B) 수행 과정</strong> 이렇게 두 개로 나뉩니다.<br>결론적으로 <strong>자바스크립트는 컴파일 과정을 가진 인터프리트 언어</strong>로 요약할 수 있지 않을까합니다.</p>
</blockquote>
<h1 id="자바스크립트-엔진-및-런타임"><a href="#자바스크립트-엔진-및-런타임" class="headerlink" title="자바스크립트 엔진 및 런타임"></a>자바스크립트 엔진 및 런타임</h1><p><strong>자바스크립트 런타임</strong>은 크게 2 개의 구성요소로 나눠질 수 있고, 개별적으로는 5 개로 나누어 볼 수 있습니다.</p>
<ol>
<li><strong>자바스크립트 엔진</strong> = <strong>(1) Heap</strong>, <strong>(2) Stack</strong>(Call stack)</li>
<li><strong>(3) Web APIs</strong>, <strong>(4) Callback queue</strong>, <strong>(5) Event loop</strong></li>
</ol>
<p><strong>자바스크립트 엔진</strong>은 <strong>(1) Heap</strong> 그리고 <strong>(2) Stack</strong> 만을 의미하며 <strong>싱글 스레드</strong>로 모든 코드를 수행합니다.. 자바스크립트의 비동기를 학습할때 배우는 <strong>(3) Web APIs</strong>, <strong>(4) Callback queue</strong>, <strong>(5) Event loop</strong>들은 정확히는 <strong>자바스크립트 엔진</strong>의 구성요소가 아닙니다. <strong>자바스크립트 엔진</strong>이 <strong>싱글 스레드</strong>로 모든 코드를 수행한다면 동기적 실행밖에 안될텐데 어떻게 비동기를 지원한다는 것일까요? 비동기 지원을 위해 바로 자바스크립트 런타임에서 <strong>(3), (4), (5)</strong> 세 요소를 추가한것입니다.</p>
<p><strong>자바스크립트 엔진</strong>의 <strong>(2) Stack</strong> 은 일반 프로그램 언어들의 Stack 과는 다른데요. 타 프로그램 언어들은 함수 실행에 따라 Call stack 에 각 로컬 함수들의 변수 등의 Context 정보들을 다 같이 쌓습니다. 로컬 함수에만 국한된 정보들을 갖는다는 이유로 Context 를 Scope 라고도 부릅니다. 반면, <strong>자바스크립트 엔진</strong>도 Call stack 에 함수 호출 순서를 적재합니다만, 변수 및 함수 선언과 할당 정보는 Heap 에 따로 저장히여 Call Stack 에는 본 Heap 에 대한 포인터만 갖고 있습니다. 구체적으로 정리하면 아래와 같습니다.</p>
<ol>
<li><strong>자바스크립트 엔진</strong></li>
</ol>
<ul>
<li><strong>(1) Heap</strong>: 각 함수 별 <strong>선언 및 할당되는 모든 변수 및 함수를 적재</strong>하는 메모리 영역</li>
<li><strong>(2) Stack</strong>(Call Stack): 함수 실행 순서에 맞게 위 Heap 에 대한 포인터 <strong>적재 및 실행</strong></li>
</ul>
<ol start="2">
<li><strong>비동기 지원</strong></li>
</ol>
<ul>
<li><strong>(3) Web APIs</strong>: 기본 자바스크립트에 없는 DOM, ajax, setTimeout 등의 <strong>라이브러리 함수들</strong><a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/%EC%B0%B8%EC%A1%B0/API">^10</a>. 브라우저나 OS 등에서 C++ 처럼 다양한 언어로 구현되어 제공</li>
<li><strong>(4) Callback Queue</strong>: 위 Web APIs 에서 발생한 콜백 함수들이 차곡차곡 여기에 <strong>적재</strong></li>
<li><strong>(5) Event Loop</strong>: 위 Callback Queue에 적재된 함수를 Stack 로 하나씩 옮겨서 <strong>실행되도록 하는 스레드</strong></li>
</ul>
<h1 id="자바스크립트-엔진-실행-과정"><a href="#자바스크립트-엔진-실행-과정" class="headerlink" title="자바스크립트 엔진 실행 과정"></a>자바스크립트 엔진 실행 과정</h1><blockquote>
<p>자바스크립트 엔진은 <strong>(A) JIT 컴파일 과정</strong>과 <strong>(B) 수행 과정</strong> 이렇게 두 개로 나뉩니다.</p>
</blockquote>
<h2 id="A-Compilation-Phase"><a href="#A-Compilation-Phase" class="headerlink" title="(A) Compilation Phase"></a>(A) Compilation Phase</h2><p>매 함수 실행 시 (자바스크립트 첫 실행 함수는 main() 입니다.) ASTs 생성 및 바이트코드로 변경하고 JIT 컴파일 기법(바이트코드 캐싱을 통해 불필요한 컴파일 시간을 줄이는것)을 위해 프로파일러로 함수 호출 횟수를 저장/추적합니다. 우리가 기억하면 될 것은 본 과정에서 <strong>변수의 ‘선언’</strong>(선언과 할당 중) 그리고 <strong>함수의 ‘선언’**을 **Heap 에 적재</strong>한다는것입니다.</p>
<blockquote>
<p>자바스크립트 <strong>변수의 ‘선언’**은 **var a</strong> 입니다. (<strong>a = 5</strong> 는 ‘할당(Assignment)’입니다.)</p>
</blockquote>
<blockquote>
<p>자바스크립트 <strong>함수의 ‘선언’**은 **function a()</strong> 입니다.</p>
</blockquote>
<blockquote>
<p><strong>Compilation Phase</strong>에선 <strong>변수 및 함수</strong>의 <strong>‘선언(Declaration)’**만 추출하여 **Heap 에 적재</strong>합니다.<br>변수와 함수의 선언을 자바스크립트 실행 이전에 컴파일로 저장하여 실제 실행 시 변수와 함수 선언 여부를 검색합니다.</p>
</blockquote>
<p>예를 들어 아래 자바스크립트 파일을 처음 실행하게 되면 파일 전체에 컴파일 과정을 수행하게됩니다.</p>
<figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;</span><br><span class="line">b = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">z</span>) </span>{</span><br><span class="line">  b = <span class="hljs-number">3</span>;</span><br><span class="line">  c = <span class="hljs-number">4</span>;</span><br><span class="line">  <span class="hljs-keyword">var</span> d = <span class="hljs-number">6</span>;</span><br><span class="line">  e = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">    <span class="hljs-keyword">var</span> e = <span class="hljs-number">0</span>;</span><br><span class="line">    d = <span class="hljs-number">3</span>*d;</span><br><span class="line">    <span class="hljs-keyword">return</span> d;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> g();</span><br><span class="line">  <span class="hljs-keyword">var</span> e;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">f(<span class="hljs-number">1</span>);</span><br></pre></td></tr></tbody></table></figure>
<ol>
<li>자바스크립트 첫 실행을 위한 main() 함수의 <strong>Global Scope (window)</strong> 영역을 Heap 에 생성합니다.<figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- </span><br><span class="line">- </span><br></pre></td></tr></tbody></table></figure></li>
<li>변수 선언 <strong>var a</strong>을 찾아서 <strong>Global Scope (window)</strong> 영역에 <strong>a</strong> 를 적재합니다.</li>
<li>변수 할당 <strong>b = 1</strong>은 할당이므로 본 영역에 <strong>b</strong> 를 적재하지 않습니다.<figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a =</span><br><span class="line">- </span><br></pre></td></tr></tbody></table></figure></li>
<li>함수 선언 <strong>function f(z)**을 찾아서 **Global Scope (window)</strong> 영역에 <strong>f</strong> 를 적재합니다.</li>
<li>함수 적재시엔 f 함수의 바이트코드(blob)에 대한 포인터값을 함께 적재합니다.<figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a =</span><br><span class="line">- f = a pointer <span class="hljs-keyword">for</span> f functions bytecode</span><br></pre></td></tr></tbody></table></figure>
자바스크립트 코드를 첫번째 라인에서 20번째 라인까지 컴파일 과정을 마치면 Heap 구성은 마지막과 같습니다.</li>
</ol>
<h2 id="B-Execution-Phase"><a href="#B-Execution-Phase" class="headerlink" title="(B) Execution Phase"></a>(B) Execution Phase</h2><p><strong>변수</strong>의 <strong>‘할당(Assignment)’**과 실제 **함수</strong>를 <strong>호출 및 실행</strong>합니다.</p>
<blockquote>
<p>자바스크립트 <strong>변수의 ‘할당’**은 **a = 1</strong> 입니다.<br><strong>a = 1</strong> 할당 시 이전 컴파일 과정에서 선언된 변수 <strong>a</strong> 가 있는지 확인합니다.<br>만약 존재하지 않는다면 <strong>a</strong> 변수 <strong>‘선언’과 동시에 ‘할당’하여 적재</strong>합니다.</p>
</blockquote>
<blockquote>
<p>자바스크립트 <strong>함수의 ‘호출 및 실행’**은 **a()</strong> 입니다.<br><strong>a()</strong> 실행 시 첫번째로, 이전 컴파일 과정에서 선언된 함수 <strong>a()</strong> 가 있는지 확인합니다.<br><strong>a()</strong> 실행 시 두번째로, Heap 에는 새 함수를 위한 <strong>Local Execution Scope 영역을 생성</strong>하고, Call Stack 에는 생성된 Heap 에 대한 포인터를 갖는 함수 <strong>a()</strong> 정보를 적재합니다.<br><strong>a()</strong> 실행 시 마지막으로, 컴파일을 수행하여 <strong>본 함수 내 변수 및 함수</strong>를 <strong>위 Local Execution Scope 영역에 적재</strong>합니다.</p>
</blockquote>
<blockquote>
<p><strong>Execution Phase</strong>에선 <strong>변수</strong>의 <strong>‘할당(Assignment)’**값들을 **Heap 에 적재</strong>하고 <strong>함수</strong>는 <strong>호출 및 실행</strong>합니다.</p>
</blockquote>
<p>매 함수 호출때마다 스택에 함수 내 변수 및 함수를 같이 적재하는 스택 베이스 언어과 달리 자바스크립트는 스택에는 함수 호출 순서와 실제 변수 및 함수 정보들은 Heap 에 대한 포인터를 갖습니다. Heap 에 함수 <strong>a()</strong> 를 위한 <strong>Local Execution Scope</strong> 는 a() 함수가 호출되기 이전에 Heap 에 존재했던 **Global Scope (window)**에 대한 포인터를 갖고있어서, 엔진 내에서 아래와 같은 처리가 가능합니다.</p>
<ul>
<li>a() 함수 내에서 <strong>a = 1</strong> 변수 할당 시 먼저 <strong>Local Execution Scope</strong> 에 a 변수의 선언을 찾고,<br>존재하지 않는다면 이전 <strong>Global Scope</strong> 로 돌아가 검색할 수 있습니다.</li>
<li>a() 함수 실행이 끝나게 되면 Call Stack 을 통해 현재 Heap 영역을 <strong>Global Scope</strong> 로 다시 되돌립니다.</li>
</ul>
<p>위에서 예시로 살펴본 자바스크립트 파일에 컴파일 과정을 마친 뒤 수행 과정은 아래와 같이 진행됩니다.</p>
<ol start="6">
<li>컴파일 이후 아래의 Heap 을 갖고 다시 자바스크립트 파일 코드의 맨 첫번째 라인에서 실행이 시작됩니다.<figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a =</span><br><span class="line">- f = a pointer <span class="hljs-keyword">for</span> f functions bytecode</span><br></pre></td></tr></tbody></table></figure></li>
<li>변수 할당 <strong>a = 2</strong>을 찾아서 <strong>Global Scope (window)</strong> 영역에 변수 <strong>a</strong> 존재 여부를 확인합니다.</li>
<li>변수 <strong>a</strong> 가 존재하므로 해당 <strong>a</strong> 에 <strong>2 를 할당</strong>합니다.<figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a = <span class="hljs-number">2</span></span><br><span class="line">- f = a pointer <span class="hljs-keyword">for</span> f functions bytecode</span><br></pre></td></tr></tbody></table></figure></li>
<li>변수 할당 <strong>b = 1</strong>을 찾아서 <strong>Global Scope (window)</strong> 영역에 변수 <strong>b</strong> 존재 여부를 확인합니다.</li>
<li>변수 <strong>b</strong> 가 선언되어있지 않아 <strong>b 선언</strong> 및 <strong>1 을 할당</strong>합니다.<figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a = <span class="hljs-number">2</span></span><br><span class="line">- f = a pointer <span class="hljs-keyword">for</span> f functions bytecode</span><br><span class="line">- b = <span class="hljs-number">1</span></span><br></pre></td></tr></tbody></table></figure></li>
<li>함수 호출 <strong>f(1)**을 찾아서 **Global Scope (window)**영역에서 **f()</strong> 선언 여부를 확인합니다.</li>
<li>함수 <strong>f() blob</strong> 컴파일 및 수행을 위해 Heap 에 <strong>새 Local Execution Scope</strong> 영역을 생성합니다.<figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a = <span class="hljs-number">2</span></span><br><span class="line">- f = a pointer <span class="hljs-keyword">for</span> f functions bytecode</span><br><span class="line">- b = <span class="hljs-number">1</span></span><br><span class="line"></span><br><span class="line"># Local Execution Scope for f()</span><br><span class="line">- (hidden) A pointer <span class="hljs-keyword">for</span> previous scope (= Global Scope (<span class="hljs-built_in">window</span>))</span><br><span class="line">- </span><br><span class="line">- </span><br></pre></td></tr></tbody></table></figure></li>
</ol>
<p><strong>f(1)</strong> 함수 실행 시 새로이 생성된 <strong>Local Execution Scope</strong>에 다시 <strong>Compilation Phase</strong> 과정을 통해 변수와 함수를 적재하게 되고 <strong>Execution Phase</strong> 과정을 수행하게 됩니다. 또 <strong>f(1)</strong> 함수 내부에 또 다른 함수가 있다면 이 과정을 계속해서 재귀적으로 반복합니다. </p>
<ol start="13">
<li>함수 f() 의 <strong>Compilation Phase</strong> 과정을 마치면 아래와 같이 됩니다.<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># Global Scope (window)</span></span><br><span class="line">- a = 2</span><br><span class="line">- f = a pointer <span class="hljs-keyword">for</span> f <span class="hljs-built_in">functions</span> bytecode</span><br><span class="line">- b = 1</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Local Execution Scope for function f()</span></span><br><span class="line">- (hidden) a pointer <span class="hljs-keyword">for</span> previous scope (= Global Scope (window))</span><br><span class="line">- z = </span><br><span class="line">- d = </span><br><span class="line">- e = </span><br></pre></td></tr></tbody></table></figure></li>
<li>함수 f() 의 <strong>Execution Phase</strong> 과정을 마치면 함수 <strong>f()</strong> 내 <strong>변수 할당</strong> 및 <strong>함수 g() 의 Scope 가 생성</strong>되게 됩니다.<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># Global Scope (window)</span></span><br><span class="line">- a = 2</span><br><span class="line">- f = a pointer <span class="hljs-keyword">for</span> f <span class="hljs-built_in">functions</span> bytecode</span><br><span class="line">- b = 3</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Local Execution Scope for function f()</span></span><br><span class="line">- (hidden) a pointer <span class="hljs-keyword">for</span> previous scope (= Global Scope (window))</span><br><span class="line">- z = 1</span><br><span class="line">- d = 6</span><br><span class="line">- e = 1</span><br><span class="line">- c = 4</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># Local Execution Scope for function g()</span></span><br><span class="line">- (hidden) a pointer <span class="hljs-keyword">for</span> previous scope (= Local Execution Scope <span class="hljs-keyword">for</span> <span class="hljs-keyword">function</span> f())</span><br><span class="line">- e =</span><br></pre></td></tr></tbody></table></figure>
<h1 id="자바스크립트-엔진-특성"><a href="#자바스크립트-엔진-특성" class="headerlink" title="자바스크립트 엔진 특성"></a>자바스크립트 엔진 특성</h1></li>
</ol>
<h2 id="Function-level-scope-var"><a href="#Function-level-scope-var" class="headerlink" title="Function-level scope: var"></a>Function-level scope: var</h2><p>자바스크립트 실행은 결국 <strong>함수에 따라 (A) 컴파일, (B) 수행이 재귀적으로 이뤄집니다.</strong> 처음 자바스크립트 실행 시 <strong>main() 함수에 대한 (A), (B)</strong> 처리를 시작으로 내부에 새로운 함수 호출이 일어나면 <strong>새 함수에 대한 (A), (B)</strong> 처리 그리고 또 내부 함수 호출이 있다면 <strong>그 함수에 대한 (A), (B)</strong> … 이런식으로 처리를 반복하게 됩니다.</p>
<blockquote>
<p><strong>특정 함수 내 변수 var 의 선언</strong>은 <strong>본 함수 (A) 컴파일</strong>에 정의되기 때문에 <strong>변수 var 의 scope</strong>는 <strong>function-level</strong>이 됩니다.</p>
</blockquote>
<p>if, for 문과 같은 block-level({}) 단위 변수를 위해 ES6 스펙에선 <strong>Block-level scope: const, let</strong>이 새로 소개되었습니다.</p>
<h2 id="Scope-Chain"><a href="#Scope-Chain" class="headerlink" title="Scope Chain"></a>Scope Chain</h2><p>자바스크립트 엔진 실행 과정에서 살펴보았듯 특정 함수에 대한 <strong>(B) 수행 단계</strong>에서 <strong>변수 할당 시</strong> 본 함수의 Heap 영역에 변수 선언이 되어있는지 먼저 검사하게 됩니다. 만약 <strong>본 함수 내 변수가 선언되어있지 않았다</strong>면 해당 함수의 Heap 에서는 변수 선언을 찾을 수 없게됩니다. 이때 <strong>해당 함수가 호출되기 이전의 함수</strong>로 <strong>(hidden) A pointer for previous scope</strong> 를 통해 올라가면서 해당 함수 Heap Scope 에 <strong>변수가 선언되었는지 확인</strong>합니다. 어떠한 함수에서도 <strong>변수 선언</strong>이 되어있지 않다면 가장 처음에 호출된 main() 함수까지 올라가면서 검색하게 됩니다. 함수 호출 스택에 따라 가장 처음의 main() 함수까지 <strong>각 함수 Heap Scope 에 변수 선언 존재여부를 연쇄적으로 Chaining 하며 찾기때문에 이를 Scope Chain 이라고 부릅니다.</strong></p>
<h2 id="Variable-Hoisting"><a href="#Variable-Hoisting" class="headerlink" title="Variable Hoisting"></a>Variable Hoisting</h2><p><strong>(A) 컴파일 단계</strong>에서 <strong>변수를 선언</strong>을 먼저하고, 그 다음 <strong>(B) 수행 단계</strong>에서 <strong>변수를 할당</strong>하기 때문에 같은 function-level 이라면 아래와 같이 변수 선언과 할당을 나누어서 하더라도 자바스크립트 엔진에서는 <strong>변수 선언이 먼저 된 것으로 처리</strong>됩니다.</p>
<figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-keyword">var</span> a;</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Global Scope (window)</span><br><span class="line">- a = <span class="hljs-number">10</span></span><br></pre></td></tr></tbody></table></figure>
<p>위 예시처럼 <strong>var a</strong> 선언이 <strong>같은 function-level 내에서 최상단에 ‘말려올라간것’처럼 수행</strong>되기도 하지만, 만약 <strong>함수 내 변수가 선언되어있지 않았다</strong>면 Scope Chain 을 통해 main() 함수까지 올라가면서 변수 선언을 찾습니다. 최종적으로 main() 함수 Heap Scope 에도 선언되어있지 않다면 main() 함수 영역에 변수를 선언해주게 됩니다. main() 에서 호출한 어떤 함수이든 Scope Chain 을 통해 방금 선언해준 변수를 바라볼테니 이는 <strong>전역 변수</strong>인것입니다. (<strong>main() 의 Heap Scope 영역 명칭은 Global Scope (window)**이기도 합니다.) 특정 함수내에 변수를 할당하였지만 본 변수는 어느 함수에도 존재하지 않는 변수이기에 **main() 함수까지 ‘말려올라가서’ 전역 변수를 선언한것이 됩니다.</strong> <strong>변수 선언이 ‘말려올라갔다’는 의미에서 이 모든 경우를 Variable Hoisting 이라고 표현</strong>합니다.</p>
<h2 id="Variable-Shadowing"><a href="#Variable-Shadowing" class="headerlink" title="Variable Shadowing"></a>Variable Shadowing</h2><p>특정 함수의 Heap Scope 에 변수 선언이 되어있다면 해당 변수에 대한 변수 할당은 현재 함수 Heap Scope 에 선언되어있는 변수에 대입됩니다. 만약에 해당 함수를 호출하는 이전 함수에 해당 변수와 똑같은 명칭의 변수가 선언되어있다고 할지라도 현재 함수 Heap Scope 에 이미 존재하기때문에 이전 함수의 Heap Scope 까지 Scope Chain 할 필요가 없습니다. <strong>이전 함수에 같은 명칭의 변수가 있다고하더라도 현재 함수는 그 존재를 알 수도 알 필요도 없기 때문에 이를 Variable Shadowing</strong> 이라 부릅니다.</p>
<h2 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h2><p>함수 직접 수행이 끝나면 Stack 에서 수행 완료된 함수의 정보를 없애면서 Heap 메모리 내 수행 완료된 함수의 Heap Scope 도 없애게 됩니다. 메모리 청소의 의미로 Garbage Collection 이라고 부릅니다. 전체 자바스크립트 파일 실행이 끝나게되면 가장 마지막으로 main() 함수의 Global Scope(Window) 도 사라지게 됩니다. Reference Count 를 통한 Garbage Collection 를 하는 스위프트 언어도 있지만 <strong>자바스크립트는 단순히 함수(포인터)의 Reachability 를 기반으로 Garbage Collection 를 수행</strong>합니다. 함수 직접 수행이 아닌 함수 수행을 변수에 할당한 경우엔 함수 수행이 끝났다고 하더라도 할당된 변수로 또 함수 수행이 가능하기 때문에 본 함수에 대한 Garbage Collection 를 안하는 경우가 존재하는데 바로 아래서 설명할 Closure 개념입니다.</p>
<h2 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h2><p><strong>자바스크립트 엔진 실행</strong> 설명시 다뤘던 예제에서 function f 를 바로 실행하지 않고 var myFunction 를 선언하여 그에 할당해보았습니다.</p>
<figure class="highlight javascript hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;</span><br><span class="line">b = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params">z</span>) </span>{</span><br><span class="line">  b = <span class="hljs-number">3</span>;</span><br><span class="line">  c = <span class="hljs-number">4</span>;</span><br><span class="line">  <span class="hljs-keyword">var</span> d = <span class="hljs-number">6</span>;</span><br><span class="line">  e = <span class="hljs-number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span>(<span class="hljs-params"></span>) </span>{</span><br><span class="line">    <span class="hljs-keyword">var</span> e = <span class="hljs-number">0</span>;</span><br><span class="line">    d = <span class="hljs-number">3</span>*d;</span><br><span class="line">    <span class="hljs-keyword">return</span> d;</span><br><span class="line">  }</span><br><span class="line"></span><br><span class="line">  <span class="hljs-keyword">return</span> g;</span><br><span class="line">  <span class="hljs-keyword">var</span> e;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="hljs-keyword">var</span> myFunction = f(<span class="hljs-number">1</span>); <span class="hljs-comment">// 새로 추가된 코드</span></span><br><span class="line">myFunction();</span><br></pre></td></tr></tbody></table></figure>
<p>함수 호출을 변수에 할당하게 되면 함수의 호출은 일회성으로 호출이 끝나면 사라지는것이 아니라 <strong>myFunction</strong> 이란 변수를 통해서 계속해서 반복 호출이 가능하기 때문에 f 함수 호출을 위해 생성된 f 함수의 Heap Scope 는 지워질 수 없습니다. 조금 쉽게 생각하자면 f 함수 Heap Scope 에는 f 함수 수행을 위해 넘긴 파라미터 값 1 도 들고있기 때문에 Heap Scope 를 Garbage Collection 할 수 없는것입니다. 이처럼 함수 호출을 변수에 할당하게 되면 <strong>f 함수의 Heap Scope</strong> 와 <strong>f 를 호출한 함수의 Heap Scope</strong> 가 <strong>파라미터 1 을 기준으로 강하게 묶여있기 때문에 f 함수 실행이 끝났음에도 불구하고 f 함수의 Heap Scope 가 Garbage Collection 되지 않습니다.</strong></p>
<p>Closure 는 함수의 Heap Scope 와 해당 함수를 호출하는 함수의 Heap Scope 를 연결하는것으로, 함수 호출이 끝나더라도 Scope 는 여전히 해당 함수를 호출한 함수의 Scope 에 ‘갇혀있는’ 개념입니다.</p>
<hr>
<p>1: <a target="_blank" rel="noopener" href="https://youtu.be/QyUFheng6J0">https://youtu.be/QyUFheng6J0</a><br>2: <a target="_blank" rel="noopener" href="https://www.quora.com/Is-JavaScript-a-compiled-or-interpreted-programming-language">https://www.quora.com/Is-JavaScript-a-compiled-or-interpreted-programming-language</a><br>3: <a target="_blank" rel="noopener" href="https://medium.com/@almog4130/javascript-is-it-compiled-or-interpreted-9779278468fc">https://medium.com/@almog4130/javascript-is-it-compiled-or-interpreted-9779278468fc</a><br>4: <a target="_blank" rel="noopener" href="https://blog.usejournal.com/is-javascript-an-interpreted-language-3300afbaf6b8">https://blog.usejournal.com/is-javascript-an-interpreted-language-3300afbaf6b8</a><br>5: <a target="_blank" rel="noopener" href="https://youtu.be/QyUFheng6J0?t=435">https://youtu.be/QyUFheng6J0?t=435</a><br>6: <a target="_blank" rel="noopener" href="https://dev.to/genta/is-javascript-a-compiled-language-20mf">https://dev.to/genta/is-javascript-a-compiled-language-20mf</a><br>7: <a target="_blank" rel="noopener" href="https://dev.to/deanchalk/comment/8h32">https://dev.to/deanchalk/comment/8h32</a><br>8: <a target="_blank" rel="noopener" href="https://gist.github.com/kad3nce/9230211#compiler-theory">https://gist.github.com/kad3nce/9230211#compiler-theory</a><br>9: <a target="_blank" rel="noopener" href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf">https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf</a><br>10: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/ko/docs/Web/%EC%B0%B8%EC%A1%B0/API">https://developer.mozilla.org/ko/docs/Web/%EC%B0%B8%EC%A1%B0/API</a><br>11: <a target="_blank" rel="noopener" href="https://medium.com/@antwan29/browser-and-web-apis-d48c3fd8739">https://medium.com/@antwan29/browser-and-web-apis-d48c3fd8739</a></p>
</body></html></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2020-08-20</div></span><span class="level-item"><a class="link-muted" href="/categories/Deployment/">Deployment</a><span> / </span><a class="link-muted" href="/categories/Deployment/Docker/">Docker</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/20/an-introduction-to-docker/">Docker 간단하게 살펴보는 기본 개념</a></h1><div class="content"><html><head></head><body><h1 id="왜-Docker-를-사용하는가"><a href="#왜-Docker-를-사용하는가" class="headerlink" title="왜 Docker 를 사용하는가?"></a>왜 Docker 를 사용하는가?</h1><p>하나의 서버에 다양한 Application 들을 구동시키려면 여러 VM 들을 올려놓고 각 Application 마다 VM 을 할당해주는 방법도 있지만, Docker 는 각 Application 을 VM 보다 가벼운 Container 단위로 패키징 및 관리를 가능하게 합니다.</p>
<h1 id="Container-는-무엇인가"><a href="#Container-는-무엇인가" class="headerlink" title="Container 는 무엇인가?"></a>Container 는 무엇인가?</h1><h2 id="VM-vs-‘Container’"><a href="#VM-vs-‘Container’" class="headerlink" title="VM vs ‘Container’"></a>VM vs ‘Container’</h2><p><strong>VM</strong> 개념은 <strong>단일 Host OS</strong> 위에 <strong>다수의 Guest OS</strong> 를 갖고 각각 Application 을 단일 Guest OS 에 매핑한것인 반면</p>
<blockquote>
<p>[ Host OS - [ <strong>VM</strong>: Guest OS - Libs - App ] ]</p>
</blockquote>
<p><strong>Container</strong> 는 <strong>단일 Host OS</strong> 위에 <strong>다수의 Application 을 바로 구동</strong>할 수 있는 VM 보다 가벼운 단위입니다. <strong>Host</strong> OS 와 <strong>Container</strong> 사이 포트 포워딩이나 파일시스템(디렉토리) 연동 등은 후술할 Image 설정으로 가능합니다.</p>
<blockquote>
<p>[ Host OS - [ <strong>Container</strong>: Libs - App ] ]</p>
</blockquote>
<p>VM 은 Hypervisor 에 의해 물리적 자원 관리가 된다면 Container 는 Docker 에 의해 논리적으로 자원 분배가 됩니다. </p>
<ul>
<li>VM 은 Hypervisor 에 의한 하드웨어 가상화</li>
<li>Container 는 Docker 에 의한 Host OS 가상화</li>
</ul>
<p>과거 학부때 데모 실행을 위해 멀티 노드 하둡구성시 사용 경험이 있는 LXC(Linux Container) 개념이 Docker 의 초기 버전의 구현이었다고 합니다만 이후 Docker 는 자체 컨테이너를 사용한다고 합니다.</p>
<h2 id="Image-and-‘Container’"><a href="#Image-and-‘Container’" class="headerlink" title="Image and ‘Container’"></a>Image and ‘Container’</h2><p>Docker 를 처음 접하며 명확히 구별하지 못했던 개념이 있습니다. ‘Image’와 ‘Container’입니다. Image 는 VM 에서의 개념과 동일하기에 쉽게 이해하실 수 있습니다.</p>
<ul>
<li><strong>Image</strong> 는 Container 구동을 위한 파일시스템과 구동에 필요한 설정들이 모여있는 <strong>정적 설정</strong>이며,</li>
<li><strong>Container</strong> 는 위 Image 를 기반으로 실제 구동(Runtime)된 <strong>동적 인스턴스</strong>라고 보면 됩나다.</li>
</ul>
<h1 id="왜-Container-를-사용하는가"><a href="#왜-Container-를-사용하는가" class="headerlink" title="왜 Container 를 사용하는가?"></a>왜 Container 를 사용하는가?</h1><h2 id="Application-단위-관리"><a href="#Application-단위-관리" class="headerlink" title="Application 단위 관리"></a>Application 단위 관리</h2><p>Application 단위로 패키징을 가능하게 함으로써 개발 시 역할/책임(R&amp;R)을 분리할 수 있습니다. 웹 서비스를 개발하면 하나의 서버 인스턴스에 다양한 역할들이 들어있는데, 각각 독립된 Container 로 분리할 수 있습니다.</p>
<ul>
<li><strong>nginx</strong>: 정적 페이지 제공 및 SPA 프론트엔드</li>
<li><strong>tomcat</strong>: 프론트엔드에 제공될 API 서버</li>
<li><strong>logstash</strong>: nginx, tomcat 에서 발생하는 log 들을 log 적재 서버에 전송</li>
<li><strong>온콜(서비스 상태 추적)</strong>: nginx, tomcat 에서 발생하는 오류 로그 및 CPU, memory 등 자원 상태를 상태 관리 서버에 전송</li>
<li><strong>성능 측정(예, pinpoint)</strong>: tomcat 에서 타 서버들의 API 콜에 대한 횟수, 지연시간 등을 성능 관리 서버에 전송</li>
</ul>
<p>즉, 위 예시와 같이 하나의 서버 인스턴스에 총 5개의 Container 가 작동될 수 있습니다.</p>
<p>만약 프론트엔드에 제공할 API 서버뿐만 아니라 외부에서 직접 호출할 수 있는 API 서버를 추가하고싶다면 tomcat 컨테이너를 하나 더 추가하여 총 2개의 tomcat 을 하나의 서버 인스턴스에 두고 사용할 수 있습니다. Java 기반 tomcat 을 Python 기반 django 로 교체할 수 도 있습니다. 프론트엔드를 제공하는 nginx 서버는 그대로 있으면서 API 서버만 교체된것이죠. </p>
<p>각 Application 을 레고 블럭처럼 관리하는건 배포에도 큰 이점이 있습니다. 단지 하나의 컨테이너 버전만 업데이트하고싶다면 해당 컨테이너의 이미지만 다시 받아서 재배포를 진행하면 됩니다. 각 컨테이너마다 버전 관리를 따로 할 수 있는것이죠.</p>
<blockquote>
<p>레고 블럭처럼 Application 들을 관리할 수 있다는 장점은 VM 도 갖고있지만, 그보다 더 Container 를 선호하는 이유는 <strong>가상화의 레벨이 상위 레벨인 만큼 가볍고(Container = lightweight VM), 위에 설명했듯이 버전 및 배포관리가 이미지로 관리되므로 (1) 이미지 설정과 (2) 배포가 구분되어있어 과정의 자동화가 쉽기 때문입니다. 성능 측면에서도 Container 간 IO 및 네트워크 처리에 있어서 빠르기도 합니다.</strong><a target="_blank" rel="noopener" href="https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd">^1</a> 가상화의 레벨이 로우 레벨인 VM 은 보안 측면에서의 캡슐화가 Container 보다 더 뛰어나다고 하지만, 현재 기술에서는 둘간 얼마나 큰 차이가 있을지 궁금하군요.</p>
</blockquote>
<p>이처럼 Docker 로는 <strong>Application 이 구동될 환경</strong>과 <strong>구동할 이미지</strong>를 설정합니다. <strong>Application 각각의 자체 설정</strong>은 docker 와 별개로 프로젝트 내부에 설정해놓으면 됩니다. 책임 분리인 셈입니다.</p>
<h1 id="Docker-용어-구성요소"><a href="#Docker-용어-구성요소" class="headerlink" title="Docker 용어(구성요소)"></a>Docker 용어(구성요소)</h1><ul>
<li><strong>Registry</strong> = Images storage<ul>
<li>Image 들을 저장헤놓는 중앙 저장소</li>
<li>일반적으로 배포 파이프라인을 구성하면 최신 소스를 통해 Docker Engine 으로 생성한 tomcat/nginx 이미지를 Registry 에 올린뒤, 해당 이미지로 최종 서버 배포를 진행합니다.</li>
<li>기본 Docker Hub 서버 혹은 회사/개인용 Docker Hub 서버를 만들어서 사용하거나</li>
<li>Amazon AWS 에서 제공하는 ECR(AWS EC2 Continaer Registry)를 사용할 수도 있습니다.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Image</strong><ul>
<li>전에 설명했듯 Container 동작을 위한 파일시스템과 구동에 필요한 설정들이 모여있는 <strong>정적 설정</strong>입니다.</li>
<li>Image 는 RO(Read-Only) 파일시스템의 집합<a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/#images-and-layers">^2</a>입니다. 좀 더 상세한 파일시스템 구조는 다음을 참조<a target="_blank" rel="noopener" href="https://rampart81.github.io/post/docker_image/">^3</a>하세요.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Container</strong><ul>
<li>위 Image 기반으로 실제 구동(Runtime)된 <strong>동적 인스턴스</strong></li>
</ul>
</li>
</ul>
<ul>
<li><strong>Application/Service</strong> = Containers on <strong>One host</strong><ul>
<li>이를 위해 <strong>Docker Compose</strong> 를 사용하여 <strong>하나의 호스트 머신에서 Containers 를 관리</strong>할 수 있습니다.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Orchestration</strong> = Containers on <strong>Multiple hosts</strong>(Systems, MSA)<ul>
<li>이를 위해 <strong>Docker Swarm</strong> 를 사용하여 <strong>다수의 호스트 머신에서 Containers 를 관리</strong>할 수 있습니다.</li>
</ul>
</li>
</ul>
<h1 id="Docker-Engine"><a href="#Docker-Engine" class="headerlink" title="Docker Engine"></a>Docker Engine</h1><p><strong>(1) Image 생성</strong> 및 <strong>(2) Container 구동</strong> 모두를 담당하는 엔진<a target="_blank" rel="noopener" href="https://www.quora.com/What-is-the-difference-between-the-Docker-Engine-and-Docker-Daemon">^4</a>이며 구성은 아래와 같습니다.</p>
<ol>
<li>컨테이너 및 이미지 생성을 위한 유저의 입력을 받는 <strong>Docker CLI</strong></li>
<li>컨테이너 구동을 위한 <strong>Docker Daemon</strong></li>
</ol>
<h2 id="Image-생성"><a href="#Image-생성" class="headerlink" title="Image 생성"></a>Image 생성</h2><p>Container 는 Image 기반으로 구동되기때문에 원하는 Container 구동에 앞서 원하는 Image 를 먼저 만들어야합니다. 이미지 생성에서 최종 컨테이너 구동까지는 세 절차로 이뤄집니다.</p>
<ol>
<li><strong>Dockerfile</strong> - Dockerfile 작성</li>
</ol>
<p>Dockerfile 로 원하는 Image 생성에 대한 설정(생성 규칙)을 여러 명령어로 작성합니다. 본 설정을 기반으로 이미지를 생성하고 생성된 이미지를 갖고 추후 컨테이너로 구동하게됩니다. 아래는 간단한 명령어 모음입니다.</p>
<blockquote>
<p><strong>FROM</strong>: 기본 베이스 이미지를 정의합니다. 가져올 해당 이미지 URL 을 적으면 됩니다.<br><strong>ENV</strong>: 이미지 내 환경변수를 설정합니다. 리눅스 터미널에서 <code>SET_VALUE=3</code> &amp; <code>echo $SET_VALUE</code> 를 생각하면됩니다.</p>
<p><strong>RUN</strong>: 실행할 Shell 명령어를 명시하면 <strong>이미지 빌드 시점</strong>에서 해당 명령어를 수행합니다.<br><strong>CMD</strong>: 실행할 Shell 명령어를 명시하면 <strong>이미지 빌드 완료 뒤 컨테이너가 정상 실행되었을때</strong> 해당 명령어를 수행합니다.</p>
<p><strong>EXPOSE</strong>: 외부에 열고싶은 Port 를 설정합니다. <strong>Container 포트</strong>와 <strong>실제 Host 에서 노출할 포트</strong>를 연결합니다.<br><strong>WORKDIF</strong>, <strong>ENTRYPOINT</strong>: RUN/CMD 로 명시한 Shell 을 실행할 디렉토리 위치를 지정합니다.<br><strong>ADD</strong>, <strong>COPY</strong>: 호스트의 디렉토리나 파일을 <strong>이미지에 커밋</strong>합니다.<br><strong>VOLUME</strong>: 호스트의 디렉토리나 파일을 이미지에 커밋하지 않고 <strong>컨테이너 디렉토리에 연결</strong>합니다.</p>
<p>… 더 많은 명령어 및 상세 설명은 공식 Docker 문서를 참조하세요.</p>
</blockquote>
<ol start="2">
<li><strong>Build</strong> (docker build) - 이미지 생성</li>
</ol>
<p><code>docker build</code> 명령어를 실행하면 가장 먼저, 작성되어있는 Dockerfile 를 Docker Daemon 에게 전달합니다. 그 후 Dockerfile 스크립트 내 매 명령어마다 실행하기 위한 컨테이너를 구동하고, 명령어가 성공적으로 수행된다면 해당 스냡샷으로 이미지를 생성합니다. 아래에서 예시로 살펴볼 <code>docker build</code> 수행 로그를 보면 Docker 는 <strong>Dockerfile 내 각 명령어가 실행되는 컨테이너의 ID</strong>와 <strong>실행이 끝난다면 실행완료된 컨테이너의 스냅샷으로 생성한 이미지 ID</strong> 이 둘을 반환하는걸 알 수 있습니다.</p>
<p>만약에 명령어 수행중에 실패하게 된다면 <strong>해당 명령어가 실행되는 컨테이너 ID</strong>에 쉘을 통해 접근하여 로그를 확인할 수 있습니다. 이처럼 중간에 반환되는 컨테이너 ID 를 통해 <code>docker build</code> 디버깅이 가능합니다. 그렇다면 Dockerfile 스크립트의 마지막 라인이 실행 완료된 컨테이너의 스냅샷이 최종적으로 우리가 생성할 이미지가 되는것입니다.</p>
<ul>
<li><strong>2.1. 빌드의 시작은 Dockerfile 를 Docker Daemon 에 전달하면서 시작</strong>됩니다.</li>
</ul>
<p>Docker Daemon 은 Dockerfile 에서 FROM 명령어에 명시된 새로 생성할 이미지의 기반이 될 베이스 이미지를 가져옵니다.</p>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker build .</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 10240 bytes</span><br><span class="line"></span><br><span class="line">Step 1/3 : FROM base-image:1.7.2</span><br><span class="line">Pulling repository base-image:1.7.2</span><br><span class="line"> ---&gt; e9aa60c60128/1.000 MB (100%) endpoint: https://my-own.docker-registry.com/v1/</span><br></pre></td></tr></tbody></table></figure>
<p>개인 Docker Registry 인 <a target="_blank" rel="noopener" href="https://my-own.docker-registry.com/v1">https://my-own.docker-registry.com/v1</a> 에서 base-image:1.7.2 이미지를 가져왔습니다. 마지막 라인에 <code>e9aa60c60128</code>는 다운받은 베이스 이미지에 Docker 가 할당한 ID 입니다. 다음으로 수행될 명령어는 이 이미지 기반으로 중간 이미지를 만듭니다.</p>
<ul>
<li><strong>2.2. 그 다음 명령어는 이전에 생성된 중간 이미지를 다시 컨테이너로 구동하여, 명령어들을 수행한 뒤 스냅샷을 이미지로 반환</strong>합니다.</li>
</ul>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Step 2/3 : WORKDIR /instance</span><br><span class="line"> ---&gt; Running <span class="hljs-keyword">in</span> 9c9e81692ae9</span><br><span class="line">Removing intermediate container 9c9e81692ae9</span><br><span class="line"> ---&gt; b35f4035db3f</span><br></pre></td></tr></tbody></table></figure>
<p>바로 이전에 수행한 FROM 명령어의 결과로 <code>e9aa60c60128</code> 중간 이미지가 생성되었습니다. 본 이미지로 새 컨테이너 <code>9c9e81692ae9</code> 를 구동하였고, 그 내부에서 <code>WORKDIR /instance</code> 명령어를 수행한뒤, 수행 완료된 컨테이너를 내리고 그 스냅샷을 <code>b35f4035db3f</code> 이미지로 반환한것을 볼 수 있습니다.</p>
<ul>
<li><strong>2.3.</strong> 2.2.와 동일합니다. 단, Dockerfile 내 모든 Step 을 마쳤으므로 <strong>마지막으로 생성한 스냅샷 이미지가 우리가 최종적으로 얻는 이미지</strong>가 됩니다.</li>
</ul>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Step 3/3 : CMD <span class="hljs-built_in">echo</span> Hello world</span><br><span class="line"> ---&gt; Running <span class="hljs-keyword">in</span> 02071fceb21b</span><br><span class="line">Removing intermediate container 02071fceb21b</span><br><span class="line"> ---&gt; f52f38b7823e</span><br><span class="line"></span><br><span class="line">Successfully built f52f38b7823e</span><br></pre></td></tr></tbody></table></figure>
<p>우리가 얻는 최종 이미지명(ID)을 <code>f52f38b7823e</code>가 아닌 원하는 이름을 붙여주고 싶다면 tag 옵션을 통해 이름을 붙여줄 수 있습니다. 예를 들면 <strong>base-image:1.7.2</strong> 로 새 이미지를 만들었으니 <strong>custom-image:1.7.2</strong> 로 이름지어볼 수 있습니다.</p>
<ul>
<li><strong>2.4.</strong> <strong>Push</strong> (docker push) - 이렇게 만든 이미지를 Docker Registry 에 저장합니다.</li>
</ul>
<h2 id="Container-구동"><a href="#Container-구동" class="headerlink" title="Container 구동"></a>Container 구동</h2><p>생성된 최종 Image 로 Docker Daemon 위에서 Container 구동합니다.</p>
<ul>
<li><strong>1.</strong> <strong>Pull</strong> (docker pull) - 컨테이너를 구동하기 위해 저정된 이미지를 가져옵니다.</li>
<li><strong>2.</strong> <strong>Execute</strong> (docker run) - 가져온 이미지로 컨테이너를 구동합니다.</li>
</ul>
<h1 id="Docker-이미지-설정-예시"><a href="#Docker-이미지-설정-예시" class="headerlink" title="Docker 이미지 설정 예시"></a>Docker 이미지 설정 예시</h1><p>상품 정보를 저장/조회하는 서비스를 제공하기 위해 <strong>프론트엔드 서버</strong>는 <strong>nginx</strong>(react.js) 로 <strong>백엔드 서버</strong>는 <strong>tomcat</strong>(java) 으로 서비스를 제공하려고합니다. 두 Application 들을 각각 Container 로 총 두 개의 Container 를 하나의 AWS EC2 서버 인스턴스에서 구동하려합니다.</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>먼저 nginx image 설정을 보겠습니다. nginx 구동은 쉘 스크립트를 실행하게되는데 직접 만든 replace-hosts-and-run.sh 쉘을 이미지에 주입해서 알맞은 환경변수와 함께 수행하여 최종적으로 nginx 서버를 띄우는것을 목표로 하겠습니다.</p>
<figure class="highlight dockerfile hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 1. 기본 베이스 이미지를 가져옵니다. 프론트엔드 서버용 nginx 기본 이미지를 받습니다.</span></span><br><span class="line"><span class="hljs-keyword">FROM</span> http://docker-hub.aaronryu.com/nginx:<span class="hljs-number">1.8</span>.<span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 2. nginx 웹 서버에서 다국어 지원을 위한 gettext 를 설치합니다.</span></span><br><span class="line"><span class="hljs-keyword">RUN</span><span class="hljs-bash"> apk --no-cache add gettext</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 3. 현재 프로젝트 디렉토리 중 files/, build/, 쉘 스크립트를 이미지 내 지정한 디렉토리에 추가/붙여넣습니다.</span></span><br><span class="line"><span class="hljs-keyword">ADD</span><span class="hljs-bash"> files/ /instance/program/nginx/conf</span></span><br><span class="line"><span class="hljs-keyword">ADD</span><span class="hljs-bash"> build/ /instance/service/webroot/ui</span></span><br><span class="line"><span class="hljs-keyword">ADD</span><span class="hljs-bash"> replace-hosts-and-run.sh /instance/program/nginx/replace-hosts-and-run.sh</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 4. 위 쉘 스크립트(replace-hosts-and-run.sh)에서 사용할 호스트 명 환경변수를 설정합니다.</span></span><br><span class="line"><span class="hljs-keyword">ENV</span> NGINX_HOST aaronryu.frontend.com</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 5. 로깅 등을 위해 nginx 컨테이너 내 아래 디렉토리를 호스트의 디렉토리에 연결합니다.</span></span><br><span class="line"><span class="hljs-comment"># (Container 가 아래 디렉토리에 하는 작업은 실제 호스트의 디렉토리에 반영됩니다.)</span></span><br><span class="line"><span class="hljs-keyword">VOLUME</span><span class="hljs-bash"> [<span class="hljs-string">"/instance/logs/nginx"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 6. '이미지 완료 뒤'에 아까 복사해둔 아래 쉘 스크립트를 위 환경변수와 함께 실행(CMD)합니다.</span></span><br><span class="line"><span class="hljs-keyword">CMD</span><span class="hljs-bash"> /instance/program/nginx/replace-hosts-and-run.sh</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><p>nginx 서버의 SPA 정적 페이지에서 조회 및 저장을 위해서는 그에 맞는 API 가 필요합니다. 이 API 들을 제공하기위한 tomcat 서버를 구동하겠습니다. Java 서버이기에 JVM 에 대한 설정을 추가하고, 외부에서 본 서버의 상태를 조회하기 위해 12345 포트를 열어두겠습니다.</p>
<figure class="highlight dockerfile hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 1. 기본 베이스 이미지를 가져옵니다. 백엔드 서버용 tomcat 기본 이미지를 받습니다.</span></span><br><span class="line"><span class="hljs-keyword">FROM</span> http://docker-hub.aaronryu.com/tomcat:<span class="hljs-number">8.0</span>.<span class="hljs-number">0</span>-jdk8</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 2. tomcat 의 구현은 spring boot 로 되어있습니다. 구동 시 production 프로파일 옵션을 주겠습니다.</span></span><br><span class="line"><span class="hljs-keyword">ENV</span> SPRING_PROFILE production</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 3. tomcat 은 Java 기반 서버이기에 JVM 메모리 옵션을 추가합니다.</span></span><br><span class="line"><span class="hljs-keyword">ENV</span> JVM_MEMORY -Xms2g -Xmx2g -XX:PermSize=<span class="hljs-number">512</span>m -XX:MAxPermSize=<span class="hljs-number">512</span>m</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 4. 현재 프로젝트 디렉토리내 저장되어있는 setenv.sh 을 이미지 내 tomcat 실행 쉘 파일에 추가/붙여넣습니다.</span></span><br><span class="line"><span class="hljs-keyword">ADD</span><span class="hljs-bash"> setenv.sh <span class="hljs-variable">${CATALINA_HOME}</span>/bin/setenv.sh</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 5. 현재 프로젝트 빌드가 완료된 뒤 생성된 war 파일을 모두 tomcat 실행 webapps 에 추가/붙여넣습니다.</span></span><br><span class="line"><span class="hljs-keyword">COPY</span><span class="hljs-bash"> build/libs/*.war <span class="hljs-string">"<span class="hljs-variable">${CATALINA_HOME}</span>"</span> /webapps/ROOT.war</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 6. 설정한 tomcat 서버 포트 8080 을 호스트의 12345 포트에 연결하여 외부에 노출합니다.</span></span><br><span class="line"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span> <span class="hljs-number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 7. 로깅 등을 위해 tomcat 컨테이너 내 아래 디렉토리들을 호스트의 디렉토리에 연결합니다.</span></span><br><span class="line"><span class="hljs-comment"># (Container 가 아래 디렉토리에 하는 작업은 실제 호스트의 디렉토리에 반영됩니다.)</span></span><br><span class="line"><span class="hljs-keyword">VOLUME</span><span class="hljs-bash"> [<span class="hljs-string">"/instance/logs/tomcat"</span>, <span class="hljs-string">"/instance/logs/tomcat/catalina_log"</span>, <span class="hljs-string">"/instance/logs/tomcat/gc"</span>]</span></span><br></pre></td></tr></tbody></table></figure>
<p>위 예시로 살펴본 각각의 Dockerfile 은 각각 nginx 와 tomcat 프로젝트 내에 위치하게 됩니다. 이 두 컨테이너를 하나의 인스턴스에 동시에 띄우기 위해서는 Docker Compose 설정으로(예, .yml) 설정으로 각 컨테이너의 이미지를 묶어서 명시하면 됩니다.</p>
<hr>
<ol>
<li><a target="_blank" rel="noopener" href="https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd">https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/#images-and-layers">https://docs.docker.com/storage/storagedriver/#images-and-layers</a></li>
<li><a target="_blank" rel="noopener" href="https://rampart81.github.io/post/docker_image/">https://rampart81.github.io/post/docker_image/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.quora.com/What-is-the-difference-between-the-Docker-Engine-and-Docker-Daemon">https://www.quora.com/What-is-the-difference-between-the-Docker-Engine-and-Docker-Daemon</a></li>
<li><a target="_blank" rel="noopener" href="https://www.joyfulbikeshedding.com/blog/2019-08-27-debugging-docker-builds.html">https://www.joyfulbikeshedding.com/blog/2019-08-27-debugging-docker-builds.html</a></li>
</ol>
</body></html></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2019-12-15</div></span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/Develop/">Develop</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/15/one-page-for-regular-expression/">한 장으로 보는 정규표현식</a></h1><div class="content"><html><head></head><body><h1 id="중요성"><a href="#중요성" class="headerlink" title="중요성"></a>중요성</h1><p>개인적으로 좋아했던 구글 Tech Lead 유튜버가 개발자라면 당연히 알아야할 몇가지 스킬을 업로드<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=3MtrUf81k6c">^1</a>한적이 있다.</p>
<ol>
<li>Regular expressions</li>
<li>SQL</li>
<li>Debugging Skills (problem solving).</li>
<li>Tooling language</li>
<li>Anti-Social skill </li>
</ol>
<p>이 중 오늘의 주제는 가장 첫번째에 언급된 <strong>정규표현식</strong>이다. 중간에 5번이라는 스파이가 있는듯 한데 개발자는 사실상 코딩보단 말을 많이하는 직업이라 생각해서 그리 좋은 전략은 아닌듯하다. <strong>정규표현식</strong>은 학사때도 나중에 공부해야지 하고 메모는 많이 해놓았는데 정작 제대로 외우진 않고 매번 필요할때마다 찾아 쓴듯하다. 최근에 정리하였는데 나름 문법처럼 분류해서 외우면 쉽다. 사실 Regex 는 Tech Lead 말대로 개발하는데 너무 널리 사용된다. 텍스트 검색, 정확히는 패턴 매칭에 사용되는데 검색이라면 아래같이 수많은 유즈케이스들이 있다.</p>
<ul>
<li>grep 을 통한 로그/텍스트 분석</li>
<li>개발하고 있는 코드/디렉토리 검색</li>
<li>commit 이전 코드 체킹</li>
<li>웹 크롤링</li>
<li>URL 파싱</li>
<li>값/포맷 validation</li>
</ul>
<h1 id="개요"><a href="#개요" class="headerlink" title="개요"></a>개요</h1><p>Regex 는 처음보았을때나 공부하기 전까지는 암호내지 외계어처럼 보이긴 한다. 우리가 흔히 접하는 언어는 semantic 이 word 혹은 그 조합으로 표현되지만, semantic 들이 각각 하나의 charactor 에 매핑되어있는건 암호체계와 동일하기 때문이다. 이것도 syntax 로 분류하면 아래와 같이 나뉘어지는데, 정규표현식을 익히는데 많은 도움이 된다.</p>
<center><img src="/2019/12/15/one-page-for-regular-expression/one-page-regex.png" class=""></center>

<p>기본적으로 특정 단어를 검색하기 위해 정규표현식을 사용하는데, 단순히 찾고싶은 <strong>1. 특정 단어</strong>를 명시하는 방법도 있지만 <strong>2. 글자나 숫자 조합</strong>으로써 단어를 명시할수도 있다. 정규표현식은 이에 두 가지 방법을 제공한다.</p>
<h1 id="기본"><a href="#기본" class="headerlink" title="기본"></a>기본</h1><h2 id="단어"><a href="#단어" class="headerlink" title="단어"></a>단어</h2><p>간단하게 검색하고 싶은 <strong>특정 단어</strong>만 명시하면 된다.<br>만약 여러 단어를 한번에 검색하고 싶다면 <strong>()</strong> 를 사용하여 <strong>|</strong> 를 통해 다수의 단어를 넣으면 된다.</p>
<h2 id="글자-타입"><a href="#글자-타입" class="headerlink" title="글자 - 타입"></a>글자 - 타입</h2><p><strong>특정 글자</strong>를 명시하고 싶을땐 <strong>단어</strong>와 같은 방식으로 사용하면 되는데 <strong>[]**를 통해 여러 글자를 찾을수도 있고, **[]</strong> 내부에서 확장 표현을 통해 A 부터 Z 까지(<strong>A-Z</strong>) 규칙을 추가하거나 특정 글자를 제외할 수도 있다.</p>
<p>숫자 글자를 검색하고 싶다면 위에서 배운대로 <strong>[0-9]</strong> 도 좋지만 <strong>‘숫자’ 글자 타입</strong>을 명시하여 검색할수도 있다. <strong>글자의 타입</strong>을 명시하기 위한것이 역슬래시(\)며 예를 들면 <strong>‘숫자’ 글자 타입</strong>은 <strong>\d</strong> 로 표현할 수 있고 <strong>‘숫자가 아닌’ 글자 타입</strong>은 <strong>\D</strong> 와 같이 대문자로 표기할 수 있다.</p>
<hr>
<h1 id="확장"><a href="#확장" class="headerlink" title="확장"></a>확장</h1><h2 id="앞-뒤"><a href="#앞-뒤" class="headerlink" title="앞/뒤"></a>앞/뒤</h2><p>특정 단어 혹은 글자를 찾더라도 글의 <strong>가장 앞쪽에</strong> 혹은 <strong>가장 뒷쪽에</strong> 존재하는 것을 찾고 싶을때 사용한다.</p>
<h2 id="횟수"><a href="#횟수" class="headerlink" title="횟수"></a>횟수</h2><p>특정 단어 혹은 글자가 <strong>몇번 반복된 것</strong>을 검색하고 싶은지 명시할 수 있다.</p>
<blockquote>
<p>(abc){1} = abc<br>(abc){1,3} = abc, abcabc, abcabcabc<br>(abc)? = (공백), abc<br>(abc)+ = abc, abcabc …</p>
</blockquote>
<h2 id="캡쳐"><a href="#캡쳐" class="headerlink" title="캡쳐"></a>캡쳐</h2><p>앞부분에서 설명하였듯 패턴으로 검색할 단어를 집합으로 묶을때 사용하거나 <strong>검색한 결과물</strong>들을 활용하려고 할때 결과값을 저장하는 역할을 한다.</p>
<hr>
<p>정규표현식은 한번 배워두면 어떤 개발 언어에서든 모든곳에서 범용적으로 사용가능하며, 개발에서 활용할 수 있는 경우의 수가 매우 많아 유용하다. 이렇게 정리함으로써 이젠 매번 검색할일 없이 잘 사용할 수 있을듯하다.</p>
</body></html></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2019-08-10</div></span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/Licenses/">Licenses</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/10/software-licences/">오픈 소스(공개 소프트웨어)의 다양한 라이센스들</a></h1><div class="content"><html><head></head><body><h1 id="GPL-General-Public-License-GNU-GPL"><a href="#GPL-General-Public-License-GNU-GPL" class="headerlink" title="GPL (General Public License, GNU GPL)"></a><strong>GPL</strong> (General Public License, GNU GPL)</h1><p>공개(자유) 소프트웨어 철학의 조상에 해당하며 그만큼 보수적입니다.</p>
<blockquote>
<p>일반 라이센스는 SW에 대한 공유와 수정의 자유를 제한하려는 목적을 가진 반면<br>GPL은 공유와 수정의 자유를 보장하기 위한 규정</p>
</blockquote>
<ul>
<li><strong>상업적 사용이 가능</strong>하다.</li>
<li>다만, <strong>공개 및 상업적 사용</strong>시 <strong>무료 공개</strong>를 해야한다.</li>
<li><strong>내부 사용시</strong> (개인, 기관, 단체 내부) <strong>무료 공개의 의무가 없다.</strong></li>
<li>GPL 코드의 일부만 사용하더라도 GPL 라이센스를 갖는다.</li>
</ul>
<h1 id="LGPL-Lesser-General-Public-License-GNU-LGPL"><a href="#LGPL-Lesser-General-Public-License-GNU-LGPL" class="headerlink" title="LGPL (Lesser General Public License, GNU LGPL)"></a><strong>LGPL</strong> (Lesser General Public License, GNU LGPL)</h1><p>GPL 은 GPL 인 라이브러리를 사용만해도 2차 저작물에 GPL 이 적용되어,<br>상업적 사용은 가능하지만 소스 코드가 공개되어야하는 단점을 갖습니다.</p>
<blockquote>
<p>FSF(Free Software Foundation) 는 이런 이유로 GPL 라이브러리 사용 기피 방지 및 오픈 소스의 기여를 위해<br>코드 자체를 수정하지 않는한 공개 조항을 강제하지 않습니다.</p>
</blockquote>
<ul>
<li><strong>기본적으로는 GPL 과 동일</strong>하다.</li>
<li>LGPL 코드를 <strong>단순 사용</strong> 시 <strong>무료 공개의 의무가 없다.</strong> 사용했음만을 명시하면 된다.</li>
<li>LGPL 코드를 <strong>수정 사용</strong> 시 <strong>무료 공개</strong>를 해야한다.</li>
</ul>
<h1 id="BSD-Berkeley-Software-Distribution-License-amp-MIT-License"><a href="#BSD-Berkeley-Software-Distribution-License-amp-MIT-License" class="headerlink" title="BSD (Berkeley Software Distribution) License &amp; MIT License"></a><strong>BSD</strong> (Berkeley Software Distribution) License &amp; MIT License</h1><p>유닉스 계열 운영체제인 BSD 가 유닉스의 원 제작자인 AT&amp;T의 벨 연구소에게 소송을 당하게 되고,<br>그 이후 소스코드 작성자 이름 표기 외에 어떠한 저작권 내용이 없는 라이센스를 만들어 배포합니다.<br>추가로 MIT 는 BSD 와 거의 유사하여 따로 항목을 생성하지 않았습니다.</p>
<ul>
<li>소프트웨어계의 <strong>공공재</strong></li>
<li><strong>수정 가능, 자유로운 사용</strong></li>
<li><strong>공개의 의무가 없다.</strong></li>
</ul>
<p>초기 4조항 버전에서 조항이 하니씩 빠지면서 3조항, 2조항 버전이 있습니다.</p>
<h3 id="4조항-Original"><a href="#4조항-Original" class="headerlink" title="4조항 - Original"></a>4조항 - Original</h3><ul>
<li>광고에 <strong>원</strong> 저작권자 표기 필수</li>
<li>광고에 <strong>2차</strong> 저작권자 표기 불가</li>
</ul>
<h3 id="3조항-BSD-License-2-0"><a href="#3조항-BSD-License-2-0" class="headerlink" title="3조항 - BSD License 2.0"></a>3조항 - BSD License 2.0</h3><ul>
<li><del>광고에 <strong>원</strong> 저작권자 표기 필수</del> (제거)</li>
<li>광고에 <strong>2차</strong> 저작권자 표기 불가</li>
</ul>
<h3 id="2조항-FreeBSD-License"><a href="#2조항-FreeBSD-License" class="headerlink" title="2조항 - FreeBSD License"></a>2조항 - FreeBSD License</h3><ul>
<li>제품에 BSD 라이센스 내용과 <strong>원, 2차</strong> 저작권자를 표기해야하는 의무</li>
</ul>
<h1 id="5-Apache-License"><a href="#5-Apache-License" class="headerlink" title="5. Apache License"></a>5. Apache License</h1><p>BSD 라이센스는 공공재에 가까운 조항으로 <strong>2차 저작물에 대한 어떠한 특허도 요구할 수 없습니다.</strong></p>
<blockquote>
<p>Apache License 는 이 라이센스 코드를 자신이 활용하여 2차 저작물을 만들어도 그에 대해 특허를 가질 수 있습니다.<br>단 그렇게 하려면 해당 저작물에는 더 이상 Apache License 를 적용해선 안되겠지요.</p>
</blockquote>
<ul>
<li><strong>공개의 의무가 없다.</strong></li>
<li><strong>2차 변형물</strong>의 <strong>특허출원이 가능</strong>하다.</li>
<li>다만, 수정 여부 및 아파치 재단 이름과 라이센스 내용을 명시해야한다.</li>
</ul>
<hr>
<p>간단한 이해를 위해서 위와같이 정리해 보았는데요. 역시나 가장 재미있는것은 각 라이센스들이 왜? 어떻게? 에 해당하는 역사겠지요. 아래 링크<a target="_blank" rel="noopener" href="https://meetup.toast.com/posts/101">^1</a>에서 약간 상세하게 풀어놓았으니 참조하시면 큰 도움이 되실겁니다.</p>
<hr>
<p>참조</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://meetup.toast.com/posts/101">https://meetup.toast.com/posts/101</a></li>
<li><a target="_blank" rel="noopener" href="http://wiki.kldp.org/wiki.php/OpenSourceLicenseGuide">http://wiki.kldp.org/wiki.php/OpenSourceLicenseGuide</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/BSD_licenses">https://en.wikipedia.org/wiki/BSD_licenses</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/MIT_License">https://en.wikipedia.org/wiki/MIT_License</a></li>
</ol>
</body></html></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2019-06-29</div></span><span class="level-item"><a class="link-muted" href="/categories/Programming/">Programming</a><span> / </span><a class="link-muted" href="/categories/Programming/Develop/">Develop</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/29/ios-design-patterns/">개발 일지 - iOS 아키텍쳐 패턴 MVC, MVVM, VIPER</a></h1><div class="content"><html><head></head><body><p>iOS 는 어떻게 보면 웹 어플리케이션 개발과 거의 유사하다고 생각됩니다. 다만 .NET WebForm 처럼 View 와 Controller 가 강결합 되어있어서, React.js 렌더링(프론트) 로직과 View 데이터를 전달해주는 Controller 를 따로 생각할 수 없습니다. 처음 스위프트 앱을 만들때 앱도 결국 웹 페이지와 거의 유사한 모델이기 때문에 웹 어플리케이션 개발 방식 그대로 개발하려했습니다. MVC 와 MVVM 에 대한 작은 경험을 그대로 적용해보았습니다.</p>
<h1 id="MVC-MVVM"><a href="#MVC-MVVM" class="headerlink" title="MVC / MVVM"></a>MVC / MVVM</h1><p>기존 웹 어플리케이션을 만들때 서버에서는 Controller, Application, Service, Repository 순으로 분류하여 작업했습니다. HTML, Javascript 는 View 에, JPA 같은 데이터 레벨은 Model 에, Model 을 활용한 모든 비지니스 로직과 View 와 POST/GET 통신으로 이벤트를 주고받는 중간 레이어는 Controller 에 해당합니다. 웹 어플리케이션에서 MVC 의 Controller 는 사실상 View Model 에 해당합니다. View 를 그려주는것이 아니라 View 를 그릴 수 있는 View Model 을 전달해주고 이를 처리하는건 클라이언트 엔진위인 Single Page 니까요. 이름만 들어도 알만한 프론트엔드 프레임워크인 .js 류들이 이런 패턴을 사용합니다.</p>
<h2 id="iOS-Massive-Controller-Actually-It’s-‘View’-not-a-Controller"><a href="#iOS-Massive-Controller-Actually-It’s-‘View’-not-a-Controller" class="headerlink" title="iOS - Massive Controller ? (Actually It’s ‘View’ not a Controller)"></a>iOS - Massive Controller ? (Actually It’s ‘View’ not a Controller)</h2><p>MVVM 패턴을 그대로 적용하려니 iOS 에서 에러가 발생합니다. 문제의 핵심은 <strong>View.storyboard 와 ViewController.swift 가 사실상 하나의 View</strong> 라는겁니다. 일반적으로 프론트엔드와 백엔드의 코드 베이스가 JS, Java 등으로 나뉘는것과 달리 iOS Swift 는 View 를 모두 .swift 에서 처리합니다. ViewController.swift 가 Controller 라는 이름을 갖고있지만 사실상 View 에 해당하고 View.storyboard 는 CSS/HTML 및 Router 가 포함된 개념으로 볼 수 있습니다.</p>
<p>스위프트는 본질적으론 MVC 패턴입니다. 다만 언어의 특성상 웹 어플리케이션의 MVC 와는 조금 구별해야하는것 처럼 보입니다. Controller 가 사실상 View 에 해당하는것이기 때문에 <strong>렌더에 해당하는 로직을 Controller 가 갖습니다.</strong> Service, Repository 모듈화를 잘한다해도 Controller 에는 <strong>View 렌더 로직</strong>뿐만 아니라, <strong>View 렌더에 필요한 데이터 조작에 대한 ‘일부’ 비지니스 로직</strong>도 포함하게 됩니다. 이 문제를 <strong>Massive Controller</strong> 라고 칭합니다.</p>
<h1 id="첫-개발-MVC"><a href="#첫-개발-MVC" class="headerlink" title="첫 개발 - MVC"></a>첫 개발 - MVC</h1><p>MVC 를 그대로 적용해본 제 첫 Swift 코드는 아래와 같았습니다. Bar 같은 여러 Asset 에 그려줄 데이터(Model)들을 받아와서 <strong>통계 데이터를 만들고(비지니스 로직)</strong> 그걸 <strong>View 에 주입해서 그려주었죠(View).</strong> 물론 보시는것과 같이 간단한 UIView 임에도 View 를 그리는 로직뿐만 아니라 <strong>View Model 에 대한 로직</strong>을 보실 수 있습니다.</p>
<center><img src="/2019/06/29/ios-design-patterns/mvc-code.png" class=""></center>

<h1 id="리팩토링-MVVM"><a href="#리팩토링-MVVM" class="headerlink" title="리팩토링 - MVVM"></a>리팩토링 - MVVM</h1><p>Controller 가 커지면 무의식적으로 불안감이 발생합니다. 코드를 작성하면서 이건 정말 아닌것같은 느낌을 많이 받으며 리팩토링을 수행했습니다. 사실상 View 의 의미를 갖는 Controller 아래에 진정한 의미의(…) Controller인 View Model 을 두는 것입니다. <strong>모양, 색깔, 크기에 해당하는건 ViewController</strong> 에 두고 이에 필요한 <strong>ViewModel 은 ViewModelController</strong> 가 제공하는것입니다. 아래 예를 보면 <strong>ViewController 에서 ViewModel 인 mockBudgets 만을 잘 사용하고 있습니다.</strong> View(Controller)와 ViewModel(Controller) 바인딩 시 Rx 를 사용한다고 하는데 아직 이것까진 적용해보지 못했습니다.</p>
<center><img src="/2019/06/29/ios-design-patterns/mvvm-code.png" class=""></center>

<h1 id="최근-VIPER"><a href="#최근-VIPER" class="headerlink" title="최근 - VIPER"></a>최근 - VIPER</h1><p>그러다 개인 프로젝트이기에 시간 날때마다 작업을 하니 제가 짠 코드도 몇일 몇주가 지나서 보면 너무 새로운 겁니다. 매번 개발을 진행할때, 더 진척이 생길때마다 코드를 다시 읽고 이해하는 시간이 길어졌고, 이건 코드들이 각 구체적이고 명확한 역할을 가지지도 않는다는걸로 이해됐습니다. 물론 Service, Repository 레벨의 코드들은 정리가 잘되어있어서 문제가 없었지만 View 는 아무리 적응하려해도 힘들더군요. 심지어 저는 Swift 를 처음 공부하면서 첫 어플리케이션을 만들고 있는것이니까요.</p>
<h2 id="VIPER"><a href="#VIPER" class="headerlink" title="VIPER"></a>VIPER</h2><p>VIPER 는 사실 View Model 의 이중화라고 보면 됩니다. 기존 비지니스 로직을 <strong>View 와 연관된 비지니스 로직</strong>, <strong>Model 데이터 레벨에 가까운 비지니스 로직 및 로깅, 네트워크 인스턴스 관리</strong> 이렇게 둘로 세분화한것으로 이해하면 쉽습니다. 전자를 <strong>Presentator</strong> 후자를 <strong>Interactor</strong> 라고 부릅니다. 그렇게 3개에서 4개의 컴포넌트가 되었습니다. 거기에 ViewController 간 화면 전환과 같은 segue 처리를 맡는 <strong>Router</strong> 가 추가되어 총 5개가 됩니다.</p>
<p>제 기존 코드에서 Model 은 이미 잘 정리되어있었기 때문에 이 부분은 Entity 와 Interactor 로 이미 분리되어 있었습니다. ViewModel 에도 최대한 Model 에 대한 로직은 넣지 않았으니까요. 기존 ViewController 에 몰려있던 <strong>View 에 대한 관련 비지니스 로직</strong>들을 <strong>Presentator</strong> 로 이관을 해보니 기존 View 에 View Model 로직들이 너무 많았었구나 싶었습니다. 또한 화면 전환(segue) 처리도 기존 ViewController 가 갖고있었는데 사실 이건 메타적으로 생각해보면 ViewController 간 이동을 조율하는것이므로 상위 레벨의 컴포넌트가 관리하는게 맞았습니다. segue 이동에 대해 매 ViewController 마다 중복해 갖는 보일러플레이트 코드들을 어떻게 중앙처리할까 했더니 VIPER 의 Router 를 사용하면 되는것이었습니다.</p>
<p>이렇게 적용을 해보았는데 컴포넌트가 5개이다 보니 기반 코드가 너무 많습니다. 귀찮았지만 앞으로의 생산성을 위해 적용해봤는데요. 효과는 아직 모르겠습니다. ReSwift(Redux on Swift) 개념도 있는듯한데 React.js 를 짧게 사용해보면서 컴포넌트들이 해봐야 고작 1, 2 레이어여서 굳이 Redux 를 적용할 필요가 없었기 때문에 배워보지 못했습니다. 이건 추후에 적용해보는걸로 해야겠습니다. 아무래도 새로운 아키텍쳐 패턴이나 요즘 핫하다는걸 적용해보면 좋겠지만 아무리 개인 개발이라도 빨리 배포를 하는게 더 중요하겠지요.</p>
</body></html></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2019-05-27</div></span><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Kotlin/">Kotlin</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/05/27/coroutine-and-thread/">Coroutine, Thread 와의 차이와 그 특징</a></h1><div class="content"><p>처음 Kotlin 를 사용하던 중에 <strong>비동기</strong> 처리를 위해 Coroutine 개념을 마주했었습니다. <strong>동기</strong>란 요청을 보낸 후 요청에 대한 <strong>반환값을 얻기 이전까지 대기</strong>하는걸 의미하고, <strong>비동기</strong>는 그 <strong>대기시간동안 다른 일을 수행</strong>하여 효율성을 높히는걸 의미합니다.</p>
<p>동기와 비동기는 ‘대기’가 필요한 작업들이 빈번한 프로그래밍에 등장하는 개념이고 이를 ‘blocking’으로 명명하여 예로는 OS 시간에 배웠던 I/O 나 Network Request/Response 처리가 있습니다. 과거에는 앞서 말한 예를 처리할때에만 비동기를 사용했던것으로 기억하는데요. 현재에는 어떤 작업이든지 잘게 쪼개어 비동기로 하는 것으로 보입니다. 이런 분위기를 이끌어 온것은 사용이 간편해짐을 들 수 있는데 여기서 설명할 Coroutine 개념도 Thread 보다 비동기 사용이 쉽도록 만들어주었기 때문아닐까 생각이 듭니다.</p>
<h1 id="Process-amp-Thread"><a href="#Process-amp-Thread" class="headerlink" title="Process &amp; Thread"></a>Process &amp; Thread</h1><blockquote>
<p><strong>Process</strong>: Program 이 메모리에 적재되어 실행되는 인스턴스<br><strong>Thread</strong>: Process 내 실행되는 여러 흐름의 단위</p>
</blockquote>
<p>먼저 Thread 는 Process 보다 작은 단위의 실행 인스턴스로만 알고 있는데, 메모리 영역도 조금 다릅니다.</p>
<center><img src="/2019/05/27/coroutine-and-thread/process-and-thread.png" class=""></center>

<p><strong>Process</strong> 는 독립된 메모리 영역**(Heap)<strong>을 할당받고 각 **Thread</strong>도 독립된 메모리 영역**(Stack)**을 할당받습니다. Thread 는 본질적으로 Process 내에 속해있기 때문에 Head 메모리 영역은 해당 Process 에 속한 모든 Thread 들이 공유할 수 있습니다. </p>
<p>Program 에 대한 Process 가 생성되면 Heap 영역과 하나의 Thread 와 하나의 Stack 영역을 갖게되고, <strong>Thread 가 추가될때마다 그 수만큼의 Stack 이 추가됩니다.</strong> Thread 가 100 개라면 전체 메모리에 100 개의 Stask 이 생성되는 것입니다.</p>
<h1 id="Concurrency-amp-Parallelism"><a href="#Concurrency-amp-Parallelism" class="headerlink" title="Concurrency &amp; Parallelism"></a>Concurrency &amp; Parallelism</h1><h2 id="Concurrency-동시성"><a href="#Concurrency-동시성" class="headerlink" title="Concurrency 동시성"></a>Concurrency 동시성</h2><blockquote>
<p><strong>Interleaving, 시분할</strong>: 다수의 Task 가 있는데, 각 Task 들을 평등하게 조금씩 나누어 실행하는것</p>
</blockquote>
<center><img src="/2019/05/27/coroutine-and-thread/tasks.png" class=""><img src="/2019/05/27/coroutine-and-thread/concurrency.png" class=""></center>

<p>총 실행시간은 Context Switching 에 대한 비용을 제외하곤 각 Task 수행시간을 합친것과 동일합니다.<br>예를 들어 3 개의 Task 각각이 10분씩 걸린다고 했을때, <strong>총 30분</strong>이 소요되는것입니다.</p>
<h2 id="Parallelism-병렬성"><a href="#Parallelism-병렬성" class="headerlink" title="Parallelism 병렬성"></a>Parallelism 병렬성</h2><blockquote>
<p><strong>Parallelizing, 병렬수행</strong>: 다수의 Task 가 있는데, 각 Task 들이 한번에 수행되는 것</p>
</blockquote>
<center><img src="/2019/05/27/coroutine-and-thread/tasks.png" class=""><img src="/2019/05/27/coroutine-and-thread/parallelism.png" class=""></center>

<p>Task 수 만큼 자원이 필요하며, Context Switching 은 필요없습니다.<br>총 실행시간은 다수의 Tasks 중 가장 소요시간이 긴 Task 만큼 걸립니다.<br>예를 들어 3 개의 Task 각각이 10, 11, 12분씩 걸린다면, <strong>총 12분</strong>이 소요되는것입니다.</p>
<h1 id="Thread-amp-Coroutine"><a href="#Thread-amp-Coroutine" class="headerlink" title="Thread &amp; Coroutine"></a>Thread &amp; Coroutine</h1><p>Thread, Coroutine 모두 Concurrency 동시성 (Interleaving) 를 보장하기 위한 기술입니다. 여러개의 작업을 동시에 수행할 때 Thread 는 각 작업에 해당하는 메모리 영역을 할당하는데, 여러 작업을 동시에 수행해야하기 때문에 OS 레벨에서 각 작업들을 얼만큼씩 분배하여 수행해야지 효율적일지 Preempting Scheduling 을 필요로 합니다. A 작업 조금 B 작업 조금을 통해 최종적으로 A 작업과 B 작업 모두를 이뤄내는 것입니다. Coroutine 은 Lightweight Thread 라고 불립니다. 이 또한 작업을 효율적으로 분배하여 조금씩 수행하여 완수하는 Concurrency 를 목표로하지만 각 작업에 대해 Thread 를 할당하는 것이 아니라 작은 Object 만을 할당해주고 이 Object 들을 자유자재로 스위칭함으로써 Switching 비용을 최대한 줄였습니다.</p>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><ul>
<li>Task 단위 = <strong>Thread</strong><ul>
<li>다수의 작업 각각에 <strong>Thread</strong> 를 할당합니다.<br>각 Thread 는 위에 설명했듯 자체 Stack 메모리 영역을 가지며 <strong>JVM Stack 영역을 차지</strong>합니다.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Context Switching</strong><ul>
<li><strong>OS Kernel</strong> 에 의한 <strong>Context Switching</strong> 을 통해 Concurrency 를 보장합니다.</li>
<li><strong>Blocking</strong>: 작업 1(Thread) 이 작업 2(Thread) 의 결과가 나오기까지 기다려야한다면<br>작업 1 Thread 는 Blocking 되어 그 시간동안 해당 자원을 사용하지 못합니다.</li>
</ul>
</li>
</ul>
<center><img src="/2019/05/27/coroutine-and-thread/context-switch-between-threads.png" class="">* 쉬운 설명을 위해 CPU 는 Single Core 로 가정합니다.</center>

<p>위 그림에서 작업들은 모두 Thread 단위인것을 알 수 있습니다. Thread A 에서 작업 1을 수행중에 작업 2가 필요할때 이를 비동기로 호출하게 됩니다. 작업 1은 진행중이던 작업을 멈추고(Blocked) 작업 2는 Thread B 에서 수행되며 이때 CPU 가 연산을 위해 바라보는 메모리 영역을 Thread A 에서 Thread B 로 전환하는 Context Switching 이 일어납니다. 작업 2가 완료되었을때 해당 결과값을 작업 1에 반환하게 되고, 동시에 수행할 작업 3과 작업 4는 각각 Thread C 와 Thread D 에 할당됩니다. 싱글 코어 CPU 는 동시 연산이 불가능하므로 이때에도 OS Kernel 의 Preempting Scheduling 에 의해 각 작업 1, 3, 4 각각을 얼만큼 수행하고 멈추고 다음 작업을 수행할지 결정하여 그에 맞게 세 작업을 돌아가며 실행함으로써 Concurrency 를 보장합니다.</p>
<h2 id="Coroutine"><a href="#Coroutine" class="headerlink" title="Coroutine"></a>Coroutine</h2><ul>
<li>Task 단위 = <strong>Object (Coroutine)</strong><ul>
<li>다수의 작업 각각에 <strong>Object</strong> 를 할당합니다.<br>이 Coroutine Object 는 객체를 담는 <strong>JVM Heap 에 적재</strong>됩니다.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Programmer Switching</strong> = No Context Switching<ul>
<li><strong>프로그래머의 코딩</strong>을 통해 <strong>Switching 시점을 마음대로 정함으로</strong>써 Concurrency 를 보장합니다.</li>
<li><strong>Suspend (Non-Blocking)</strong>: 작업 1(Object) 이 작업 2(Object) 의 결과가 나오기까지 기다려야한다면<br>작업 1 Object 는 Suspend 되지만 작업 1 을 수행하던 Thread 는 그대로 유효하기 때문에 작업 2 도 작업 1 과 동일한 Thread 에서 실행될 수 있습니다.</li>
</ul>
</li>
</ul>
<center><img src="/2019/05/27/coroutine-and-thread/no-context-switch-between-coroutines.png" class="">* 쉬운 설명을 위해 CPU 는 Single Core 로 가정합니다.</center>

<p>작업의 단위는 Coroutine Object 이므로 작업 1 수행중에 비동기 작업 2가 발생하더라도 작업 1을 수행하던 같은 Thread 에서 작업 2를 수행할 수 있으며, 하나의 Thread 에서 다수의 Coroutine Object 들을 수행할 수도 있습니다. 위 그림에 따라 <strong>작업 1과 작업 2의 전환에 있어 단일 Thread A 위에서 Coroutine Object 객체들만 교체함으로써 이뤄지기 때문에 OS 레벨의 Context Switching 은 필요없습니다.</strong> 한 Thread 에 다수의 Coroutine 을 수행할 수 있음과 Context Switching 이 필요없기 떄문에 Coroutine 을 <strong>Lightweight Thread</strong> 로도 부릅니다.</p>
<p>다만 위 그림의 Thread A 와 Thread C 의 예처럼 다수의 스레드가 동시에 수행된다면 Concurrency 보장을 위해 두 Threads 간 Context Switching 은 수행되어야합니다. 따라서 Coroutine 을 사용할때에는 No Context Switching 이라는 장점을 최대한 활용하기 위해 다수의 Thread 를 사용하는 것보다 <strong>단일 Thread 에서 여러 Coroutine Object 들을 실행하는 것이 좋습니다.</strong></p>
<blockquote>
<p>결국 <strong>Coroutine</strong> 으로 <strong>‘작업’의 단위를 Thread 가 아닌 Object 로 축소</strong>하면서<br><strong>작업의 전환 및 다수 작업 수행에 굳이 다수의 Thread 를 필요로 하지 않게됩니다.</strong></p>
</blockquote>
<blockquote>
<p><strong>Coroutine 은 Thread 의 대안이 아니라 기존의 Thread 를 더 잘게 쪼개어 사용하기위한 개념이다.</strong><br>하나의 Thread 가 다수의 코루틴을 수행할 수 있기 때문에 더 이상 작업의 수만큼 Thread 를 양산하며 메모리를 소비할 필요가 없다.</p>
</blockquote>
<ul>
<li>각 스레드마다 갖는 Stack 메모리 영역을 갖지 않기때문에, 스레드 사용시 스레드 개수만큼 Stack 메모리에 따른 메모리 사용공간이 증가하지 않아도 된다.</li>
<li>같은 프로세스내에 ‘공유 데이터 구조’(Heap)에 대한 locking 걱정도 없다.</li>
</ul>
<center><img src="/2019/05/27/coroutine-and-thread/concurrency-progress-bar-thread-and-coroutine.png" class=""></center>

<p>Thread 와 Coroutine 의 예로 보여드린 그림들을 위와 같이 축약해보았습니다. Coroutine 을 사용한다면 Task 가 바뀌어도 Thread 는 그대로 유지되는 것을 볼 수 있습니다. 그에 따라 자연스레 Context Switching 횟수도 확연히 줄어들은것을 볼 수 있습니다. Coroutine 에서 설명드린바와 같이 Task 3 과 Task 4 도 Thread C 가 아닌 Thread A 에서 수행되도록 한다면 하나의 Context Switching 도 없게 설계할 수 있습니다. 즉, Coroutine 이 수행될 Thread 도 프로그래머가 Shared Thread Pool 을 지정하여 결정한다는 의미이며, Coroutine 을 활용한 효율성은 오로지 프로그래머의 몫이라는 의미입니다.</p>
<h3 id="각-언어의-Coroutine"><a href="#각-언어의-Coroutine" class="headerlink" title="각 언어의 Coroutine"></a>각 언어의 Coroutine</h3><ul>
<li><strong>Future</strong> - <strong>Java</strong> 비동기 지원</li>
<li><strong>Promise, Generators</strong> - <strong>JavaScript</strong> 비동기 지원<ul>
<li>제너레이터는 yield 구문에 의해서만 실행을 멈춥니다. 즉 잘게잘게 쪼개어 (Iterator) 얼려놓았다 (Freeze/Yield)</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Deferred</strong> - <strong>Kotlin</strong> 비동기 지원<ul>
<li>Non Blocking Cancellable ‘Future’(Java) = <strong>Coroutine Object</strong></li>
<li>Coroutine Builder 인 <strong>async { } 를 통해 정의</strong>된다.</li>
<li>Coroutine 에서 설명했듯이 <strong>Deferred</strong> 객체를 수행할땐 <strong>Thread 를 Blocking 하지 않고</strong><br>해당 구문이 끝날때까지 awaits 하였다 끝나면 계속 이어간다.</li>
</ul>
</li>
</ul>
<h3 id="Stackful-amp-Stackless"><a href="#Stackful-amp-Stackless" class="headerlink" title="Stackful &amp; Stackless"></a>Stackful &amp; Stackless</h3><p>Coroutine 을 조금 더 깊게 알아보았다면 <strong>Stackful</strong> 과 <strong>Stackless</strong> 이 두 종류로 나뉘는것을 볼 수 있다. 본 글의 맨 처음에서 언급했듯이 <strong>Thread 는 자체 메모리 영역인 Stack 을 갖는다.</strong> Stack 은 함수 실행 순서를 적재하고 그를 관리할 수 있게 해준다. <strong>Lightweight Thread 인 Coroutine 의 Stackful &amp; Stackless 는 Coroutine 이 자체 Stack 을 가지는가? 갖지 않는가?**를 의미한다. **Stackful Coroutine 은 Coroutine 내부에서 다른 함수를 호출하였을때 해당 함수에서 현재 Coroutine 을 suspend 할 수 있음 (정확히는 yield 호출을 할 수 있음) 을 의미한다.</strong> <strong>Stackless Coroutine 은 함수에 대한 Stack 을 따로 갖지 않기 때문에 호출하려는 함수를 다시 한번 Coroutine 객체로 묶어서 ‘Coroutine 중첩 호출’을 해야지 이전 Coroutine 과 내부 Coroutine 을 suspend 를 통해 연결할 수 있다.</strong></p>
<ul>
<li>Coroutine - Stackful Functions<ul>
<li>Coroutine 내부 함수에서 Yield(Suspending the Coroutine) 호출 가능</li>
</ul>
</li>
</ul>
<ul>
<li>Generators - Stackless Functions<ul>
<li>Coroutine 내부 함수에서 Yield(Suspending the Coroutine) 호출 불가능</li>
<li>예를 들면 Coroutine 내부에 있는 Arrays.forEach() 함수 안 구문에선 forEach() 함수를 코루틴 적용이 가능하게 따로 정의하지 않는한 <strong>Yield 호출이 불가능하다.</strong></li>
</ul>
</li>
</ul>
<h1 id="Kotlin-Coroutine"><a href="#Kotlin-Coroutine" class="headerlink" title="Kotlin Coroutine"></a>Kotlin Coroutine</h1><h2 id="buildSequence"><a href="#buildSequence" class="headerlink" title="buildSequence { }"></a>buildSequence { }</h2><ul>
<li>순차적 Yield/Resuming<ul>
<li>Yield 를 통해 멈춥니다.</li>
<li>Resume 을 통해 순차수행합니다.</li>
</ul>
</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">g</span><span class="params">()</span></span> = buildSequence &#123;</span><br><span class="line">  yield(<span class="number">1</span>); yield(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (v <span class="keyword">in</span> g()) &#123;</span><br><span class="line">  println(v)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="runBlocking"><a href="#runBlocking" class="headerlink" title="runBlocking { }"></a>runBlocking { }</h2><ul>
<li><strong>Main Thread</strong> 를 <strong>Blocking</strong> 한 채 <strong>{ } 구문 내 작업을 새 Thread</strong> 에 할당하여 수행합니다.</li>
<li>runBlocking { } 내부에 다수의 async { } 들을 정의하였다면 해당 모든 async 들이 다 수행 완료, 반환되었을때 Main Thread 에 대한 Blocking 을 풉니다.</li>
</ul>
<h2 id="launch"><a href="#launch" class="headerlink" title="launch { }"></a>launch { }</h2><ul>
<li><strong>Main Thread</strong> 를 <strong>Unblocking</strong> 한 채 { } 구문 내 작업을 수행합니다.</li>
</ul>
<h2 id="async"><a href="#async" class="headerlink" title="async { }"></a>async { }</h2><ul>
<li><strong>Main Thread</strong> 를 <strong>Unblocking</strong> 한 채 { } 구문 내 작업을 하고 <strong>반환값이 존재</strong>합니다.<ul>
<li>async { } 는 launch { } 와 같은 동작을 하지만 반환값이 존재하는 <strong>Deferred</strong> 입니다.<br>즉, launch 는 끝까지 실행하면 끝나는거고 async 는 끝까지 실행하고 반환값을 가진 객체를 반환한다.</li>
<li>Deferred<T>, which has an await() function that returns the result of the coroutine.</li>
</ul>
</li>
</ul>
<hr>
<p>출처: </p>
<ol>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/1934715/difference-between-a-coroutine-and-a-thread">https://stackoverflow.com/questions/1934715/difference-between-a-coroutine-and-a-thread</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/43021816/difference-between-thread-and-coroutine-in-kotlin/43232925">https://stackoverflow.com/questions/43021816/difference-between-thread-and-coroutine-in-kotlin/43232925</a></li>
<li><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/tutorials/coroutines/coroutines-basic-jvm.html">https://kotlinlang.org/docs/tutorials/coroutines/coroutines-basic-jvm.html</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@jooyunghan/stackful-stackless-%EC%BD%94%EB%A3%A8%ED%8B%B4-4da83b8dd03e">https://medium.com/@jooyunghan/stackful-stackless-%EC%BD%94%EB%A3%A8%ED%8B%B4-4da83b8dd03e</a></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2019-03-24</div></span><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Functional-Programming/">Functional Programming</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/24/only-one-page-for-functional-programming/">한 장으로 보는 함수형 프로그래밍 - 클로저, 커링, Functor, 모나드</a></h1><div class="content"><html><head></head><body><h1 id="‘함수’형-프로그래밍"><a href="#‘함수’형-프로그래밍" class="headerlink" title="‘함수’형 프로그래밍"></a>‘함수’형 프로그래밍</h1><p>‘함수’형 프로그래밍은 한 마디로 요약할 수 있습니다.</p>
<blockquote>
<p>‘함수’를 <strong>1. 변수</strong>에 <strong>2. 파라미터</strong>에 <strong>3. 반환값</strong>에 사용할 수 있으며, <strong>4. 순수 함수</strong> 특성을 갖습니다.</p>
</blockquote>
<ol start="0">
<li>‘함수’는 <strong>일급함수(first-class function)</strong> 입니다.</li>
<li>‘함수’를 <strong>변수</strong>에 대입할 수 있습니다.</li>
<li>‘함수’를 <strong>파라미터</strong>로 넘길 수 있습니다.</li>
<li>‘함수’를 <strong>반환</strong>할 수 있습니다</li>
</ol>
<ol start="4">
<li>‘함수’는 <strong>순수 함수</strong> 특성을 갖습니다.</li>
</ol>
<ul>
<li><strong>참조 투명성 (No Side-Effects)</strong>: 외부 상태나 변수, 환경의 영향을 받지 않고,<br>같은 파라미터로 함수를 호출하면 매 항상 같은 결과를 반환합니다.</li>
</ul>
<h2 id="함수-포인터"><a href="#함수-포인터" class="headerlink" title="함수 포인터"></a>함수 포인터</h2><p>함수는 값이 아닌 참조인 만큼 <strong>함수를 일급함수로 사용하기 위해서는 함수 포인터</strong>를 이용해야 합니다.</p>
<ol>
<li>함수 포인터를 통해 함수를 <strong>변수</strong>로 사용할 수 있습니다.</li>
<li>함수를 <strong>파라미터</strong>로 넘기고 싶다면 함수 포인터를 전달하면 가능합니다.</li>
<li>함수를 <strong>반환</strong>하고 싶으면 반환하려는 함수에 대한 포인터를 반환하면 가능합니다.</li>
</ol>
<figure class="highlight c hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">qsort</span> <span class="hljs-params">(<span class="hljs-keyword">void</span>* base, <span class="hljs-keyword">size_t</span> n, <span class="hljs-keyword">size_t</span> size,  <span class="hljs-keyword">int</span> (*compare)(<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*,<span class="hljs-keyword">const</span> <span class="hljs-keyword">void</span>*))</span></span>;</span><br></pre></td></tr></tbody></table></figure>
<p>위 C 언어 예를 보면 퀵소트 알고리즘의 마지막 <strong>파라미터</strong>로 <strong>compare 함수 포인터</strong>를 넘겨주는걸 볼 수 있습니다. 다만 C 언어에서의 함수는 <strong>런타임에 정의된 함수</strong>가 아니라 <strong>미리 컴파일된 함수</strong>는 이유로 일급함수(first-class function)가 아닌 이급함수(second-class function)로 부르자는 의견<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/First-class_citizen#Functions">^3</a>도 있는듯 합니다.</p>
<hr>
<h1 id="람다-익명함수"><a href="#람다-익명함수" class="headerlink" title="람다 (익명함수)"></a>람다 (익명함수)</h1><p><strong>람다</strong>는 컴퓨터과학 및 수리논리학에 사용되는 개념으로 현 프로그래밍 함수의 원형에 해당하는 개념입니다.</p>
<blockquote>
<p><strong>입력값</strong>을 받고 함수 외부에 정의된 <strong>자유변수</strong>를 활용하여 결과를 반환하는 함수 <strong>추상</strong>표현법 입니다.</p>
</blockquote>
<p>함수를 정의만 할 뿐 수행하지 않는다는 점이 프로그래밍 내에서 함수를 정의를 먼저하는 것<a target="_blank" rel="noopener" href="https://ko.wikipedia.org/wiki/%EB%9E%8C%EB%8B%A4_%EB%8C%80%EC%88%98#%ED%95%B5%EC%8B%AC_%EA%B0%9C%EB%85%90">^8</a>과 같습니다. 수리논리 개념이자 함수의 원형인만큼 <strong>람다는 함수명이 존재하지 않습니다.</strong> 이런 이유로 <strong>람다</strong>를 프로그래밍에서는 <strong>익명함수</strong>로 부르기도 합니다. 개념이라는 것은 알겠는데 그럼 람다는 언제 왜 사용되는것일까요?</p>
<p>프로그래밍에서는 <strong>값</strong>을 사용하는 두 가지 방법이 있습니다.</p>
<ul>
<li><strong>재사용성</strong>을 위해 값을 정의 후 변수에 할당하여 <strong>변수로 사용</strong>하는 방법<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> defined: <span class="hljs-type">Int</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span></span><br><span class="line"><span class="hljs-built_in">print</span>(defined)</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>일회성</strong> 사용을 위해 값을 바로 <strong>inline 으로 사용</strong>하는 방법<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">print</span>(<span class="hljs-number">10</span>)</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p><strong>함수</strong>를 사용하는 방법도 값과 같이 두 가지 방법이 있습니다.</p>
<ul>
<li><strong>재사용성</strong>을 위해 함수를 정의 후 <strong>참조로 사용</strong>하는 방법<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">defined</span><span class="hljs-params">()</span></span> -&gt; (<span class="hljs-type">Int</span>) {</span><br><span class="line">  <span class="hljs-keyword">return</span> <span class="hljs-number">10</span></span><br><span class="line">}</span><br><span class="line"><span class="hljs-built_in">print</span>(defined)</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>일회성</strong> 사용을 위해 함수를 바로 <strong>inline 으로 사용</strong>하는 방법<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-built_in">print</span>({ <span class="hljs-keyword">return</span> <span class="hljs-number">10</span> })</span><br></pre></td></tr></tbody></table></figure></li>
</ul>
<p><strong>람다</strong>는 변수, 파라미터, 반환값에 함수 포인터를 넘겨준다는 것은 일반 함수 사용과 동일하지만, <strong>함수 정의 시점</strong>이 다르기 때문에 </p>
<ul>
<li>함수 이름이 필요없으며</li>
<li>함수의 유효범위가 일회성이라는 장점이 있습니다. <ul>
<li><strong>일반 함수</strong>는 정의 시 정의 구역 내 <strong>전역으로 존재</strong>합니다.<br>(어려운 말로 <strong>전역 네임스페이스에 소속되는 정적인 구현체</strong><a target="_blank" rel="noopener" href="http://seorenn.blogspot.com/2014/06/swift-closures.html">^1</a>)</li>
<li><strong>람다</strong>는 정의 시 정의 블럭 내 <strong>일회성으로 존재</strong>합니다. </li>
</ul>
</li>
</ul>
<p><strong>람다</strong>를 통해 함수를 <strong>일급함수</strong>로 사용 시 미리 정의할 필요없이 <strong>inline 으로 함수를 정의하여 바로 사용</strong>이 가능해졌습니다.</p>
<h2 id="함수객체"><a href="#함수객체" class="headerlink" title="함수객체"></a>함수객체</h2><p>객체지향 프로그래밍에서는 함수가 단일 함수로는 존재할 수 없으며 꼭 클래스안에 속해야하는 한계가 있습니다. 함수를 람다로 사용하고싶다면 <strong>함수객체</strong>를 만들어 객체레벨로 사용해야합니다. 객체지향 프로그래밍에서 <strong>람다</strong>는 겉으로 보기에는 단일 함수로 존재하는것 같지만, 실제론 이름없는 객체가 단일 함수를 감싸고 있는 <strong>‘함수객체’의  Syntactic Sugar</strong> 라고 보시면됩니다.</p>
<hr>
<h1 id="클로저"><a href="#클로저" class="headerlink" title="클로저"></a>클로저</h1><p><strong>람다</strong>와 <strong>클로저</strong> 이 둘은 같아보이지만 엄연히 다른 개념<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/220728/3231395">^4</a>입니다. 각 정의를 살펴보면</p>
<blockquote>
<p><strong>람다</strong>는 <strong>익명함수</strong>를 뜻합니다.<br>함수를 변수, 파라미터, 반환값에 <strong>일회성</strong>으로 바로 사용하고싶을때 쓰입니다.</p>
</blockquote>
<blockquote>
<p><strong>클로저</strong>는 <strong>함수가 정의될 때의 환경(상태)**을 갖는 **함수</strong>를 뜻합니다.<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Closure_(computer_programming)#cite_note-2">^5</a><br>여기서 <strong>환경</strong>은 <strong>클로저가 정의되는 범위(Scope)에 있는 지역변수</strong>을 의미합니다.</p>
</blockquote>
<p>일반적으로 클로저는 함수 A 내부에서 함수(클로저) C 를 정의하는 방식으로 많이 사용합니다. 함수 A 내에 <strong>클로저</strong> C 가 정의된다면 C 는 <strong>A 의 변수</strong>들을 파라미터로 넘기지 않았음에도 자연적으로 <strong>참조</strong>하여 사용할 수 있습니다. 이것이 **환경(상태)**입니다.</p>
<ul>
<li><strong>함수 A 의 변수</strong> 와 <strong>클로저 C</strong> 의 관계를 <strong>클래스 A 내 필드</strong>와 <strong>메서드 C</strong>의 관계로 생각하시면 이해가 쉽습니다. </li>
</ul>
<p><strong>클로저를 함수를 객체처럼 사용하기 위한 방법</strong>으로 본다면, 클로저를 사용하는 이유는 객체를 사용하는 이유와 비슷합니다.</p>
<ul>
<li>클로저 C 가 참조하는 외부 변수를 상태처럼 계속 갖기 때문에 반복 호출하더라도 해당 상태를 계속 활용할 수 있습니다.</li>
<li>외부 변수는 함수 A 범위 내에만 정의되었기 때문에 외부 접근이 불가능합니다.</li>
</ul>
<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">query</span><span class="hljs-params">(dbName: String)</span></span> -&gt; (<span class="hljs-type">String</span>) -&gt; (<span class="hljs-type">Person</span>) {</span><br><span class="line">  <span class="hljs-keyword">let</span> instance: <span class="hljs-type">DBInstance</span> <span class="hljs-operator">=</span> <span class="hljs-type">DBConfig</span>.getInstance(dbName)</span><br><span class="line">  <span class="hljs-comment">// * 클로저 내부 { } 에서 클로저가 정의된 함수 내 존재하는 instance 변수를 사용하였습니다.</span></span><br><span class="line">  <span class="hljs-keyword">return</span> { (tableName: <span class="hljs-type">String</span>) -&gt; (<span class="hljs-type">Person</span>) <span class="hljs-keyword">in</span> </span><br><span class="line">    <span class="hljs-keyword">return</span> instance.getTable(tableName).getFirst()</span><br><span class="line">  }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Swift-클로저"><a href="#Swift-클로저" class="headerlink" title="Swift 클로저"></a>Swift 클로저</h2><p>위에서 살펴보았듯 클로저의 정의가 익명함수는 아니지만, <strong>Swift 에서는 클로저가 이름 없이 사용되기 때문에 익명함수이기도 합니다.</strong> Swift 의 클로저는 ‘파라미터’와 ‘반환에 해당하는 구문’을 in 으로 구별합니다.</p>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/closure.svg" class=""></center>

<p>Swift 의 클로저는 아래와 같이 원하는 만큼 축약할 수 있습니다. </p>
<ol>
<li><strong>기본형</strong>: 파라미터 타입, 반환 타입을 명시하고 in 이후 함수 구문을 작성합니다.<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{ (parameters) -&gt; (return_type) <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> <span class="hljs-comment">/* statements using parameters */</span> }</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>축약형</strong>: 반환 타입을 암시적으로 결정합니다<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{ parameters <span class="hljs-keyword">in</span> <span class="hljs-keyword">return</span> <span class="hljs-comment">/* statesments using parameters */</span> }</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>축약성애자</strong>: 반환 타입뿐만 아니라 반환 식의 return 도 없앴습니다.<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{ parameters <span class="hljs-keyword">in</span> <span class="hljs-comment">/* statesments using parameters */</span> }</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>변태</strong>: 파라미터 타입을 암시적으로 결정합니다. 사용은 파라미터 순으로 <strong>$0</strong>, <strong>$1</strong> 로 사용합니다.<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">{ <span class="hljs-comment">/* statesments using parameters with $0, $1 ... */</span> }</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>Trailing Closure</strong>: 클로저가 마지막 파라미터로 사용된다면 파라미터에 넣지않고 함수 뒤 클로저 { } 로 바로 명시합니다.<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">var</span> sorted <span class="hljs-operator">=</span> sort(names, { <span class="hljs-variable">$0</span> <span class="hljs-operator">&lt;</span> <span class="hljs-variable">$1</span> })</span><br><span class="line"><span class="hljs-keyword">var</span> sorted <span class="hljs-operator">=</span> sort(names) { <span class="hljs-variable">$0</span> <span class="hljs-operator">&lt;</span> <span class="hljs-variable">$1</span> }</span><br></pre></td></tr></tbody></table></figure>
</li>
</ol>
<hr>
<h1 id="고차함수"><a href="#고차함수" class="headerlink" title="고차함수"></a>고차함수</h1><p>**’고차함수’**는 일급함수 세 조건 중 두번째 혹은 세번째에 해당하는 함수를 뜻합니다.</p>
<ol>
<li><del>‘함수’를 <strong>변수</strong>에 대입할 수 있습니다.</del></li>
<li>‘함수’를 <strong>파라미터</strong>로 받거나</li>
<li>‘함수’를 <strong>반환</strong>하는 함수</li>
</ol>
<blockquote>
<p><strong>‘고차함수’**는 **’함수’를 파라미터로 혹은 반환값으로 사용하는 것</strong>을 의미합니다. </p>
<ul>
<li>함수를 사용하는 함수다보니 **메타적 ‘함수’**라는 의미에서 한 차원 높은 함수, 고차함수라고 명명합니다.</li>
</ul>
</blockquote>
<hr>
<h1 id="커링"><a href="#커링" class="headerlink" title="커링"></a>커링</h1><p>**’커링’**은 일급함수 세 조건 중 세번째에 해당하는 함수를 뜻합니다.</p>
<ol>
<li><del>‘함수’를 <strong>변수</strong>에 대입할 수 있습니다.</del></li>
<li><del>‘함수’를 <strong>파라미터</strong>로 넘길 수 있습니다.</del></li>
<li>‘함수’를 <strong>반환</strong>하는 함수</li>
</ol>
<blockquote>
<p><strong>커링(Curring)**은 **’함수’가 ‘함수’를 반환하는 것</strong>을 의미합니다. </p>
<ul>
<li>일반적으로 <strong>Swift</strong> 에서 <strong>커링</strong>은 <strong>함수가 ‘클로저’를 반환</strong>하는 방식으로 많이 사용됩니다.</li>
</ul>
</blockquote>
<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">curringExample</span>: <span class="hljs-params">(a: Int, b: Int, c: Int)</span></span> -&gt; (<span class="hljs-type">Int</span>, <span class="hljs-type">Int</span>) -&gt; (<span class="hljs-type">Bool</span>) { <span class="hljs-operator">...</span> }</span><br></pre></td></tr></tbody></table></figure>
<p>위 <code>curringExample</code> 예를 보면 a, b, c 파라미터를 받아 <code>(Int, Int) 두 파라미터를 받아 -&gt; (Bool) 을 반환하는 함수</code>를 <strong>반환</strong>합니다</p>
<p>Swift 에서 <strong>‘클래스의 객체’**가 **’클래스 객체의 함수’**를 호출하는 방법도 **커링</strong>을 사용합니다.<a target="_blank" rel="noopener" href="https://academy.realm.io/kr/posts/currying-on-the-swift-functions/">^2</a></p>
<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">let</span> someInstance <span class="hljs-operator">=</span> <span class="hljs-type">SomeClass</span>()</span><br><span class="line">someInstance.someFunction(params: <span class="hljs-comment">/* parameters */</span>) </span><br></pre></td></tr></tbody></table></figure>
<p>위 <strong>클래스 객체의 함수</strong>는 실제로 아래와 같이 <strong>클래스 함수에 객체를 넘겨 수행합니다.</strong></p>
<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-type">SomeClass</span>.someFunction(<span class="hljs-keyword">self</span>: someInstance)(params: <span class="hljs-comment">/* parameters */</span>) </span><br></pre></td></tr></tbody></table></figure>
<p>사담으로 Kotlin 의 확장함수도 수신객체타입(클래스)에 대한 함수에 수신객체를 파라미터로 넘기는 형태로 사용됩니다.</p>
<hr>
<h1 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h1><p>Functor 는 <strong>데이터 구조</strong>입니다. Functor 개념에 앞서 함수에 대해서 짧게 살펴보겠습니다.</p>
<h2 id="함수-Mapping"><a href="#함수-Mapping" class="headerlink" title="함수 = Mapping"></a>함수 = Mapping</h2><p>함수는 Input A 를 넣으면 Output B 라는 결과가 나오는 것입니다.<br>달리보자면 함수는 Input A -&gt; Output B, 이 둘에 대한 <strong>매핑</strong>입니다.</p>
<h2 id="데이터-구조-Mapping"><a href="#데이터-구조-Mapping" class="headerlink" title="데이터 구조 Mapping"></a>데이터 구조 Mapping</h2><p>어떤 데이터 구조 전체에 대해 매핑을 적용한다면, 데이터 구조 내 원소 각각에 대해 매핑을 적용해야합니다.<br>예를 들어 데이터 구조가 <strong>리스트</strong>라면 0, 1 .. 이터레이팅을 통해 </p>
<ul>
<li><strong>Pull</strong>: 각 원소를 꺼내어 </li>
<li><strong>Mapping</strong>: 매핑을 적용한 후 </li>
<li><strong>Push</strong>: 결과 원소를 반환하려는 데이터 구조에 넣습니다.</li>
</ul>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/functor-example.svg" class=""></center>

<p><strong>각 원소에 대한 매핑 함수를 적용할 수 있음</strong>을 Mappable 로 정의한다면, 예로 살펴본 리스트는 <strong>Mappable 데이터 구조</strong>라고 정의할 수 있습니다. 위 그림 예는 Int 데이터 구조에서 String 데이터 구조로 각 원소에 대해 stringify 한 Functor 의 예입니다.</p>
<ul>
<li><strong>Functor</strong> 정의</li>
</ul>
<blockquote>
<p><strong>Functor</strong> 는 <strong>Mappable (Mapping 함수를 갖는) 데이터 구조</strong><a target="_blank" rel="noopener" href="https://medium.com/@sjsyrek/five-minutes-to-functor-83ef9075978b">^9</a>입니다.<br>각 원소에 대한 매핑 함수를 적용할 수 있는 데이터 구조라면 Functor 로 부를 수 있습니다.</p>
</blockquote>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/functor-definition.svg" class=""></center>

<ol>
<li><strong>‘단위 원소’들로 구성된 데이터 구조</strong></li>
<li><strong>각 ‘단위 원소’에서 ‘단위 윈소’로의 Mapping 함수</strong></li>
</ol>
<p>어떤 <strong>1. 데이터 구조</strong>든 원하는 연산을 적용하고싶다면 데이터 구조안의 <strong>단위 원소</strong>가 어떤 타입(T)이고, <strong>2. 단위 원소(T)에 대한 Mapping</strong>만 정의하면 됩니다. 1.을 클래스의 프로퍼티, 2.를 클래스의 메서드로 본다면 <strong>Functor 를 Function Object, 함수객체로 부르기도 합니다.</strong><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Function_object">^10</a></p>
<blockquote>
<p><strong>Functor</strong> 는 <strong>범주론(Category Theory)**에서 **카테고리에서 동일 카테고리로 사상</strong>되는 개념에서 유래했습니다. <strong>데이터 구조에서 동일 데이터 구조로 각 단위 원소들에 대해 Mapping</strong>하는것과 개념적으로 동일한 것을 알 수 있습니다. 이처럼 데이터 구조(카테고리)는 바뀌지 않은 채 값만 Mapping 되는 것을 범주론에서는 <strong>natural transformation<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Natural_transformation">^6</a></strong> 라고 정의합니다.</p>
</blockquote>
<h2 id="Haskell’s-Functor"><a href="#Haskell’s-Functor" class="headerlink" title="Haskell’s Functor"></a>Haskell’s Functor</h2><p>Functor 를 찾다보면 하스켈의 Functor 개념을 먼저 접하실텐데 하스켈의 Functor 는 typeclass 로 아래와 같이 정의하며, 데이터 구조 타입을 명시해서 원하는대로 인스턴스화 하여 사용합니다. Swift-like 문법으로 표현해보면 아래로 볼 수 있습니다.</p>
<ul>
<li><strong>Functor (typeclass)</strong><ul>
<li>Operation(<strong>T</strong>) -&gt; (<strong>R</strong>) </li>
<li><strong>S</strong> (Any Data Structure)</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Functor 구현 (instantiation)</strong><ul>
<li>Operation(<strong>Int</strong>) -&gt; (<strong>String</strong>) { +1 and Stringfy }</li>
<li><strong>List</strong></li>
</ul>
</li>
</ul>
<p>하스켈에서 Functor 는 <strong>데이터 구조 타입(S)**과 **원소(T)에서 원소(R)로의 Mapping 추상 함수</strong>를 가진 <strong>제네릭(S, T, R) 추상 클래스</strong>로 볼 수 있습니다. 하스켈에서 fmap() 이나 map() 함수를 정의할때 Mapping 추상 함수를 정의하고 변환하고자하는 데이터 구조를 주입하면 내부 값만 바뀐 동일한 데이터 구조가 반환됩니다.</p>
<p>Java 유저라면 Stream 의 map() 함수를 떠올리시면 이해가 쉽습니다. </p>
<ul>
<li>Stream 이 Mapping 함수를 가질 수 있는, Mappable 데이터 구조에 해당하므로 Functor 라고 부를 수 있고, </li>
<li>그 Mapping 함수는 Stream.map() 에 람다(익명함수) 형태로 정의하여 파라미터로 넘겨주면 됩니다. </li>
</ul>
<p>Java 의 Stream 은 정확히는 모나드입니다. 이유는 Mapping 함수가 </p>
<ul>
<li><code>Operation(T) -&gt; (R)</code>: **원소(T)에서 원소(T)**로 **’매핑’**하는 것이 아니라</li>
<li><code>Operation(T) -&gt; (S)</code>: <strong>원소(T)에서</strong> 아예 **새 Functor(S)**로 **’반환’**한다는 것입니다. </li>
</ul>
<p><strong>Functor</strong> 에서는 연산 전 데이터 구조에서 단위 원소를 꺼내 <strong>‘매핑’**을 적용 후 **결과 원소</strong>를 데이터 구조에 넣었습니다. 반면 <strong>모나드</strong>에서는 연산 전 데이터 구조에서 단위 원소를 꺼내 <strong>‘매핑’**을 적용 후 해당 원소를 **데이터 구조에 넣어</strong>서 <strong>결과 데이터 구조</strong>를 <strong>‘반환’**합니다. 함수 자체가 데이터 구조를 반환하기 때문에 매핑 함수 결과에 **Stream.map().map().map()…</strong> 과 같이  계속해서 Chaining 으로 연결할 수 있습니다. </p>
<p><strong>왜</strong> <strong>‘원소 - 원소 매핑’**이 아닌 **’원소 - 데이터 구조 매핑’**을 하는지 아래 **모나드</strong>에서 살펴보겠습니다.</p>
<hr>
<h1 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h1><p>모나드가 무엇인지 한 마디로 정리하기에 앞서, 왜 모나드가 필요한지에 대해 알아보겠습니다. 프로그래밍 언어의 ‘프로그래밍 함수’와 학문에서의 ‘함수’의 차이점이 무엇인지 아시는지요? </p>
<ul>
<li><strong>함수</strong><ul>
<li>함수 실행 시 내부에 어떤 상황이 발생하더라도 최종적으로 <strong>값을 반환하는걸 보장</strong>합니다. </li>
</ul>
</li>
</ul>
<ul>
<li><strong>프로그래밍 함수</strong><ul>
<li>함수 실행 시 내부에 어떤 <strong>처리할 수 없는</strong> 상황이 발생하면 <strong>값을 반환하지 못한채 중간에 Exception</strong>을 발생시킵니다.</li>
</ul>
</li>
</ul>
<p>고등, 대학 수학에서 그 어떠한 함수도 f(x) 중간에 실행하다가 입력해준 값이 잘못되어있으면 중간에 Exception을 내지(…) 않았습니다. 하지만 프로그래밍 함수는 작동 중 상태가 잘못되었을 경우 Exception 을 발생시킵니다. </p>
<blockquote>
<p><strong>Exception 을 발생시키는 것</strong>을 <strong>순수함수</strong> 관점에서는 <strong>Side-Effect</strong> 로 정의하기 때문에 <strong>Exception 이 발생하는 함수</strong>를 **’비순수 함수’**로 정의합니다.<a target="_blank" rel="noopener" href="https://github.com/funfunStudy/study/wiki/%EC%88%9C%EC%88%98%ED%95%A8%EC%88%98-(Pure-Function)">^7</a> </p>
</blockquote>
<p>만약 ‘프로그래밍 함수’에서 Exception 발생시 <strong>중간에 멈추는것</strong>이 아니라 <strong>해당 ‘상태’가 발생했음을 ‘상태’값으로써 결과에 함께 반환</strong>한다면 Side-Effect 는 없어지게 됩니다. 프로그래밍 함수의 <strong>순수함수화</strong>인 셈입니다. 이렇게 <strong>‘상태’값</strong>과 함수 본연의 <strong>‘결과’값</strong>을 함께 반환하기 위해서는 이 둘을 묶는 데이터 구조가 필요할 것 같습니다. </p>
<blockquote>
<p>Functor 의 <strong>Mapping 함수를 순수함수로 만들기위해</strong> 함수의 결과에 <strong>Exception 이 발생할 수 있는 ‘상태’</strong> 및 <strong>‘결과’**를 **모두 포함하는 데이터 구조를 반환</strong>해보았습니다.</p>
</blockquote>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/functor-return-functor.svg" class=""></center>

<p>Functor 의 Mapping 함수가 데이터 구조를 반환하도록 만들었지만 <strong>반환되는 데이터 구조</strong>가 <strong>한번 더 Functor 의 데이터 구조</strong>로 감싸져서 반환되는 문제가 발생했습니다.</p>
<ul>
<li><strong>Exception ‘상태’를 갖는 데이터 구조</strong>가 </li>
<li><strong>Mapping 함수를 수행한 Functor 의 데이터 구조</strong>에 <strong>한번 더 감싸진채로 반환</strong>되었습니다.</li>
</ul>
<p>Functor 는 자신의 데이터 구조의 내부 원소에서 그에 대한 연산을 수행하고 결과 원소를 데이터 구조에 Mapping 하여 반환하기 때문입니다.</p>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/monad-return-functor.svg" class=""></center>

<p>불필요하게 두 번 감싸지 않고 Exception 상태만을 포함한 데이터 구조를 반환하기 위하여 Mapping 함수의 결과를 그대로 반환하고, Mapping 함수 수행 전에 갖고있는 데이터 구조에서 값을 추출하는 Unwrap 함수를 명시합니다. 이를 flatMap 함수라고 부르며 이 <strong>flatMap 으로 얻어진 ‘데이터 구조의 내부 원소’**에 대한 **Mapping 결과인 ‘데이터 구조’를 바로 반환</strong>하도록 하는것이 <strong>모나드</strong> 패턴입니다.</p>
<ul>
<li><strong>Monad</strong> 정의</li>
</ul>
<blockquote>
<p><strong>Monad</strong>는 <strong>Unwrap(flatMap) 함수</strong>를 포함하는 <strong>Mappable 데이터 구조</strong>입니다.<br><strong>Monad</strong>의 <strong>Mapping 함수</strong>는 <strong>‘결과’와 ‘상태’ 모두를 갖는 데이터 구조를 반환</strong>합니다.</p>
</blockquote>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/monad-definition.svg" class=""></center>

<ol>
<li><strong>‘단위 원소’로 구성된 (1) 데이터 구조</strong></li>
<li><strong>‘단위 원소’에서 ‘Exception 상태를 포함한 (2) 데이터 구조’로의 Mapping 함수</strong></li>
<li><strong>(1) 데이터 구조에서 ‘단위 원소’을 꺼내는 Unwrap(flatMap) 함수</strong></li>
</ol>
<p>모나드에 대한 설명을 보면 Context 와 Content 이 둘을 가진 데이터 타입으로 설명하는 글들이 많습니다. Context 를 값이 있음/없음에 대한 ‘상태’값으로, Content 는 우리가 연산하려는 ‘값’ 내지 ‘결과’값으로 설명합니다. Monad 의 Context 가 꼭 값이 있음/없음의 상태를 가져야하는것은 아니지만 <strong>일반적으로 함수 수행 중에 Exception 이 발생할 수 있는 경우들은 값이 null 인 경우</strong>가 대부분이기 때문에 많은 설명들에서 nullable 로 설명하는것 같습니다. </p>
<h2 id="Function-Composition"><a href="#Function-Composition" class="headerlink" title="Function Composition"></a>Function Composition</h2><p>모나드는 <strong>결과 데이터 구조가 ‘상태’를 갖는다는것</strong> 뿐만 아니라 <strong>함수의 합성이 가능하다는 성질</strong>도 갖습니다.</p>
<ul>
<li><strong>composition</strong> with <strong>associative</strong>:<br>두 Mapping 함수 f(x), g(x) 가 있다면 두 함수를 합성시 f(g(x)) = (f.g)(x) 의 결과를 갖는다.<br>또한 associative 성질에 의해 f(g(x)) = (f.g)(x) = (g.f)(x) = g(f(x)) 도 만족한다.</li>
</ul>
<center><img src="/2019/03/24/only-one-page-for-functional-programming/monad-composition.svg" class=""></center>

<p>이렇게 함수형 프로그래밍의 클로저, 고차함수, 커링, Functor, 모나드 총 5개의 개념을 다뤄보았습니다. 질문이나 논의할 사항이 있으면 댓글이나 개인적으로 알려주시면 감사하겠습니다. 특히 이번 글은 시니어 개발자분의 도움으로 틀린 내용들을 가다듬고 다시 보완할 수 있었습니다. 다음 글에서는 Swift 의 클로저가 외부 변수를 참조하면서 생기는 참조 순환 문제와 그걸 해결하기 위한 기법들을 설명하겠습니다.</p>
<hr>
<p>참조</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://medium.com/@sjsyrek/five-minutes-to-functor-83ef9075978b">https://medium.com/@sjsyrek/five-minutes-to-functor-83ef9075978b</a></li>
<li><a target="_blank" rel="noopener" href="https://medium.com/@jooyunghan/functor-and-monad-examples-in-plain-java-9ea4d6630c6">https://medium.com/@jooyunghan/functor-and-monad-examples-in-plain-java-9ea4d6630c6</a></li>
<li><a target="_blank" rel="noopener" href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html</a></li>
<li><a target="_blank" rel="noopener" href="http://seorenn.blogspot.com/2014/06/swift-closures.html">http://seorenn.blogspot.com/2014/06/swift-closures.html</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/356950/what-are-c-functors-and-their-uses">https://stackoverflow.com/questions/356950/what-are-c-functors-and-their-uses</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor">https://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor</a></li>
</ol>
</body></html></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2019-03-09</div></span><span class="level-item"><a class="link-muted" href="/categories/Language/">Language</a><span> / </span><a class="link-muted" href="/categories/Language/Swift-4-iOS/">Swift 4+ / iOS</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/03/09/swift-keyword-open/">Swift 4+ Keywords - &quot;open&quot;</a></h1><div class="content"><html><head></head><body><h1 id="접근-제어자-Access-Modifier"><a href="#접근-제어자-Access-Modifier" class="headerlink" title="접근 제어자 (Access Modifier)"></a>접근 제어자 (Access Modifier)</h1><p>프로그래밍 언어에서 Java 를 예로 들자면 public, private, protected 으로 <strong>필드, 함수, 클래스</strong>의 <strong>접근 범위</strong>를 제어할 수 있습니다. final, open, override, abstract 과 같이 상속 관련 키워드들도 ‘접근 제어자’의 범주에 함께 포함됩니다. (접근 제어자를 가시성 변경자 (Visibility Modifier)로 부르기도 합니다.)</p>
<h2 id="취약-기반-클래스-Fragile-Base-Class"><a href="#취약-기반-클래스-Fragile-Base-Class" class="headerlink" title="취약 기반 클래스 (Fragile Base Class)"></a>취약 기반 클래스 (Fragile Base Class)</h2><p><strong>취약 기반 클래스 문제<a target="_blank" rel="noopener" href="http://www.cas.mcmaster.ca/~emil/Publications_files/MikhajlovSekerinski98FragileBaseClassProblem.pdf">^1</a>**는 **상속</strong>에 의해 발생하는 문제로 <strong>기반 클래스</strong>와 그를 상속하는 <strong>하위 클래스</strong>가 있다고 가정하였을 때 <strong>기반 클래스의 변경</strong>이 발생하면 <strong>하위 클래스가 깨지는 문제</strong>를 의미합니다. 기반 클래스를 하위 클래스에서 상속할 시 <strong>어떤 메소드를 어떻게 오버라이드할 지에 대한 규칙</strong>을 명시하지 않는다면 하위 클래스에서 의도와 다른 방식으로 메소드 오버라이드를 할 수 있습니다. 또한 기반 클래스의 메소드 목적이 변경되었을 때 하위 클래스의 오버라이드 메소드는 기존 의도와 예기치 못한 채 달라지게 되기 때문에 기반 클래스의 변경은 그를 상속하는 모든 하위 클래스에 영향을 줍니다. 이를 기반 클래스가 취약하다는 의미로 <strong>취약 기반 클래스</strong>라고 부릅니다.</p>
<p>초기 객체지향 프로그래밍 언어에 해당하는 Java, C#, C++ 의 경우에는 객체지향의 특징인 상속이 용이하도록, 접근 제어자를 따로 명시하지 않는다면 <strong>모든 기본 클래스는 상속이 가능</strong>합니다. 하지만 <strong>취약 기반 클래스 문제</strong>를 방지하기 위하여 ‘Effective Java’ 저서에서도 “상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라”로 언급되듯 <strong>모든 기본 클래스는 상속하지 말 것</strong>을 소프트웨어 아키텍쳐 및 디자인 패턴에서 권장하고 있습니다.</p>
<p>초기 객체지향 프로그래밍을 사용하면서 발견된 한계와 문제들은 언어를 꾸준히 업데이트하면서 보완되기도 하지만, 새로 나오는 언어들은 이러한 좋은 패턴들을 자신들의 특징으로 가져가기도 합니다. 현대 객체지향 프로그래밍 언어인 <strong>Kotlin</strong> 과 <strong>Swift</strong> 가 그 중 하나에 속합니다. 우스갯소리로 이런 언어들을 짬뽕이라고 얘기하기도 하지만 그만큼 패턴들을 문법으로서 강제하는 장점을 갖습니다.</p>
<h1 id="Swift-Kotlin-final-class"><a href="#Swift-Kotlin-final-class" class="headerlink" title="Swift, Kotlin - final class"></a>Swift, Kotlin - final class</h1><p>Java 는 취약 기반 클래스 문제를 갖는 초기 프로그래밍 언어로써 기본적으로 <strong>모든 기본 클래스는 상속이 가능</strong>합니다.<br>Kotlin 과 Swift 는 위 문제 해결을 위하여 기본적으로 **모든 기본 클래스는 상속이 불가능(final)**합니다.<br>따라서 Swift 의 두 타입인 class 와 struct 모두 기본적으로 상속이 불가능합니다. </p>
<p>추가로 Java 의 변수, 클래스, 함수 모두 기본적으로 아무 접근 제어자를 명시하지 않으면 package-<strong>private</strong> 로 선언되지만<br>Kotlin 과 Swift 의 경우 아무 접근 제어자를 명시하지 않으면 <strong>public</strong> 으로 선언되어 어디서든지 사용할 수 있으며, public 은 기본적으로 final로 상속이 불가능합니다.</p>
<ul>
<li><strong>public</strong> = <strong>Uninheritable</strong>, Callable</li>
<li><strong>open</strong> = <strong>Inheritable</strong>, Callable</li>
</ul>
<figure class="highlight swift hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">open</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">open</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">login</span><span class="hljs-params">()</span></span> { }</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">playGame</span><span class="hljs-params">()</span></span> { }</span><br><span class="line">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">init</span>() { }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>Kotlin, Swift 모두 상속을 하기 위해서는 클래스, 함수, 변수 모두에 open 키워드를 추가해야합니다. 함수와 변수에 open 키워드를 사용하여 클래스 전체 레벨이 아닌 함수, 변수 레벨에서 ‘상속 가능한 것’과 ‘상속 불가능한 것’들을 쉽게 관리할 수 있다는 장점이 있습니다.</p>
<hr>
<p>살펴본 바와 같이 Java 와 Kotlin, Swift 의 상속에 대한 처리는 완전히 반대입니다. Public 한 클래스와 함수들에게 <strong>기본적으로 상속 가능</strong>하게 하고 상속을 제한하기 위해서 private 나 protected 와 같은 접근 제한자를 사용하게 하는 <strong>Java</strong> 와 반대로 <strong>Kotlin, Swift</strong> 는 개발자들에게 <strong>기본적으로 모두 상속 불가능</strong>하게 하고 상속을 하기위해선 open 을 명시하게끔 제한함으로써 잘못 상속하는걸 방지합니다. 그래서 Swift 에서 얼핏 open 을 사용하다보면 함수, 변수 단위의 상속 여부를 결정하기 때문에 Java 에서 abstract 와 비슷하단 느낌을 받습니다.</p>
<hr>
<p>참조</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.hackingwithswift.com/example-code/language/what-does-the-open-keyword-do">https://www.hackingwithswift.com/example-code/language/what-does-the-open-keyword-do</a></li>
</ol>
</body></html></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/page/0/">Previous</a></div><div class="pagination-next"><a href="/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/">1</a></li><li><a class="pagination-link" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Deployment/"><span class="level-start"><span class="level-item">Deployment</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Deployment/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Design-Pattern/"><span class="level-start"><span class="level-item">Design Pattern</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Design-Pattern/Adapter-Decorator/"><span class="level-start"><span class="level-item">Adapter, Decorator</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Factory/"><span class="level-start"><span class="level-item">Factory</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Observer/"><span class="level-start"><span class="level-item">Observer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Singleton/"><span class="level-start"><span class="level-item">Singleton</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Language/"><span class="level-start"><span class="level-item">Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Language/Functional-Programming/"><span class="level-start"><span class="level-item">Functional Programming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Java-8/"><span class="level-start"><span class="level-item">Java 8</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Swift-4-iOS/"><span class="level-start"><span class="level-item">Swift 4+ / iOS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Programming/Develop/"><span class="level-start"><span class="level-item">Develop</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Licenses/"><span class="level-start"><span class="level-item">Licenses</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Workplace/"><span class="level-start"><span class="level-item">Workplace</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Aaron Ryu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Aaron Ryu</p><p class="is-size-6 is-block">Software Engineer</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">17</p></a></div></div></nav><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/aaronryu"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitlab" href="https://gitlab.com/aaronryu"><i class="fab fa-gitlab"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Crucian Carp</a><p class="is-size-7"><span>&copy; 2021 Aaron Ryu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>