{"pages":[{"title":"","text":"“잘 까먹어서 슬픈 붕어, 사진은 연어입니다.” Aaron Ryu Software Developer “Cool Heads, Warm Hearts” aaron.ryu.dev@gmail.com | +82 10 5549 7201 Seoul, 05328, Republic of KoreaResume:Page | LinkedIn | Google Docs(Korean, English) Specialty Web Development: Front-end &amp; Back-end iOS Development with Swift 4+","link":"/about/index.html"},{"title":"","text":"Aaron Ryu Software Developer “Cool Heads, Warm Hearts” aaron.ryu.dev@gmail.com | +82 10 5549 7201 Seoul, 05328, Republic of Korea Specialty Web Development: Front-end &amp; Back-end iOS Development with Swift 4+ Skills Kotlin 1.3, Java 8+ w/ Spring React.js and Angular.js w/ Typescript Swift 4+ (iOS) C# w/ ASP.NET AWS Education &amp; Experience Coupang, Seoul - Software Developer 2017.08 ~ Current - 쿠팡 내 여행 관련 상품에 대한 유저 경험을 증진시키기 위한 Java, Spring 를 활용한 웹 및 API 서비스 개발 한국과학기술원 전산학부 - 석사 2015.08 ~ 2017.08 - HypergraphDB와 같은 그래프 데이터베이스 조사, 하이퍼그래프에 대한 질의 프로세싱 관련 연구 한국항공대학교 컴퓨터 및 정보 공학과 - 학사 2011.02 ~ 2015.02 - Hadoop 및 HDFS 을 활용한 영상처리 연구 및 개발 Papers &amp; Conferences Attended 대용량 하이퍼그래프에 대한 효율적인 탐색 기법과 분석에의 응용 2017.07 - 컴퓨팅의 실제 분야: 정보과학회 컴퓨팅의 실제 논문지(KIISE Transactions on Computing Practices, KTCP)&gt; 류충모, 서정혁, 김명호 동형 서브그래프 검사를 이용한 향상된 하이퍼그래프 쿼리 시스템 설계 2017.06 - 2017 한국컴퓨터종합학술대회 (KCC 2017)&gt; 류충모, 서정혁, 김명호 대용량 하이퍼그래프에 대한 효율적인 BFS, DFS 탐색 기법 2016.12 - 한국정보과학회 (제43회) 2016년 동계학술대회 논문집, 205-207 + 우수발표논문상 수상&gt; 류충모, 서정혁, 김명호 하둡 분산 시스템에서의 효율적인 데이터 분할 기법 2015.06 - 한국정보과학회 학술발표논문집 (한국컴퓨터종합학술대회 논문집) 제42권 1호 1668~1670&gt; 장민욱, 이대철, 정재헌, 류충모, 김철기 Extensible Video Processing Framework in Apache Hadoop 2013.12 - IEEE International Conference on Cloud Computing Technology and Science (CloudCom) + Demo session&gt; 류충모, 이대철, 장민욱, 김철기, 서의성 Hadoop 기반 클라우드 컴퓨팅을 이용한 영상 처리 프레임워크 구현 2013.11 - 제40회 한국정보처리학회 추계학술발표대회 논문집 제20권 2호 139~142&gt; 류충모, 이대철, 장민욱, 김철기 Projects 대형 바이오 네트워크 데이터 분석을 위한 도구와 하이퍼그래프 데이터베이스 시스템 개발 2016.06 ~ 2017.07 GRRC (Cloud Computing System for Next-generation Broadcast Media) 2012.07 ~ 2013.06 - 비디오 작업을 위한 Hadoop 기반 프레임워크 제작 Patents 동영상 파일을 하둡 분산 파일 시스템에 분산 저장하는 시스템, 동영상 맵리듀스 시스템 및 그 제공방법 2013 - 특허 제 10-1460062호- 출원번호: 2013-0071441 / 출원일: 2013년 06월 21일, 등록일: 2014년 11월 04일- 김철기, 장민욱, 이대철, 유충모 Extracurricular activities TEDxKAIST – 오거나이저 중 ‘스피커(연사자 모집)’ 팀 2016.11 ~ 2017.03 - 12th TEDxKAIST WITH 개최 동아시아 평화 인권 캠프 (서울대 팀) 2014.02 ~ 2015.06","link":"/resume/index.html"}],"posts":[{"title":"1. 디자인 패턴에 앞서","text":"디자인 패턴은 대학교에서 간단하게만 배웠던 기억이 닙니다. 대학원에서도 입사 준비 때도 주변에서는 디자인 패턴이 중요하다지만 실제로 잘 사용하는 사람은 없었고, 이게 왜 중요한지에 대해서도 체감하기 힘들었었습니다. 어렸을때는 내 코드에 대한 리뷰어나 배울만한 시니어 개발자들이 없었으니 당연하다 생각합니다. 제가 코딩과 공부를 능동적으로 안해온것이 크겠지만 패턴이 왜 쓰이는지 경험적으로 습득한것은 입사하고 나서부터 였으니까요. 디자인 패턴디자인 패턴은 짧게 “객체지향 패러다임에서 더 좋은 코드란 무엇인가에 대한 고민의 결과” 입니다. 중복의 최소화: 한 곳의 수정이 중복된 다른 코드에서의 수정을 동반해선 안됩니다 코드 변경의 용이성: 코드는 항상 완벽하지 않고, 요구사항은 상시 바뀔 수 있습니다. 재사용성: 정돈된 코드는 전혀 다른 요구사항 및 비슷한 경우에도 그대로 사용이 가능합니다. 너무나도 먼 디자인 \u001c패턴우리는 어떻게보면 디자인 패턴을 모르는것이 당연합니다. 코드 한 줄의 변경이 다른 줄의 변경을 일으킬만한 큰 프로젝트를 만들어본적이 없습니다. 교내 팀 프로젝트에서 Web Application 으로 API 서버를 만들어서 고객 폰의 앱으로 주변 AP 정보를 파싱하고, LCD 패널이 붙은 라즈베리 파이로 해당 고객 위치에 따른 재실표시기를 만들었을때도 정말 코드가 단순명료했습니다. 학생분들이라면 아시죠 환경 계획 및 구축이 60% 고 개발이 20% 입니다. 남은 20% 은 술마셔야죠. 팀 프로젝트로 만든 코드는 다신 볼일이 없습니다.요구사항 변경을 요청할 교수도 다른 프로젝트에 활용할 일도 없습니다. 팀 프로젝트 발표를 마치고 학점을 받으면 친척동생이 놀러와 롤을 깔때즘 용량문제로 소스코드를 지우는 상황에 이릅니다. 가끔 입사 준비 중 볼일이 있습니다만 예로 학부생 코드는 고쳐쓰는게 아니라했습니다. 결국엔 직접 해보아야 합니다.본 카테고리에선 직접 해보며 조금이나마 짧고 명료하게 정리해놓으려합니다.복습없인 항상 까먹기 일수거든요. 앞으로 본 카테고리에선 여러 디자인 패턴들에 대해서 살펴보려합니다. 각 패턴의 설명은 기본적으로 글을 사용하겠지만 클래스 다이어그램을 통해 이해를 도우려고 합니다. 클래스 다이어그램 화살표클래스 다이어그램은 이름 자체가 내포하고있듯 Class 간의 관계를 표로 간단하게 설명한 것으로 Class 개념이 존재하는 객체지향 프로그래밍(OOP)에서 프로젝트 구현을 위한 설계도라고 보시면 될 것 같습니다. 클래스 다이어그램 자체로 한 챕터 분량이지만, 디자인 패턴에는 Class, Interface 이 둘만 필요하므로 딱 핵심적인 화살표 세 개만 살펴보겠습니다. 앞으로 Java 기반으로 설명하겠습니다. implements (구현) 일반적으로 코드는 인터페이스를 단위로 구성됩니다. 사용하려는 구현 클래스를 코드 내에 지정하지 않고 인터페이스만을 명시하고 그 인터페이스의 위치에 원하는 구현 클래스를 연결(주입)하여 실제 작업을 수행합니다. 앞으로 설명할 모든 디자인 패턴의 주축이 되는 제 1 원칙이니 조금 더 설명드리겠습니다. 학생분들은 모든 클래스를 사용할때 아래 코드를 사용하실겁니다.1ConcreteClass class = new ConcreteClass(); 우리가 배운 다형성을 활용하면 인터페이스와 구현 클래스를 나눠서 인터페이스에 우리가 원하는 구현 클래스들을 다음과 같이 동적으로 주입할 수 있습니다.1Interface class = new ConcreteClass(); 1Interface class = new SuperConcreteClass(); 주입을 직접 Interface 에 하지않고 아래처럼 더 간편하게 함수를 통해 해줄 수 있습니다.12345private Interface class;public void setClass(Interface class) { this.class = class;}setClass(new ConcreteClass(); 사용하려는 구현 클래스가 무엇인지 바로 명시하지 않고 원하는 구현 클래스를 동적으로 Interface 에 외부에서 주입하기 때문에 결정권을 갖지 않는다는 이유로 Dependency Injection, 내지는 Inversion of Control 이라 부릅니다. extends (상속) 상속은 클래스의 몇몇 함수에 대해 추가적인 기능이나 다른 로직의 함수로 대체하고 싶을때 사용합니다. 일반적으로 대학교때 객체지향 프로그램의 가장 큰 특성을 상속으로 배우고 Animal 과 같은 상위 클래스와 그를 상속하는 Cat, Dog 같은 하위 개념 클래스를 예제로 배우니 상위, 하위 클래스를 사용할때 상속을 많이 사용합니다. 하지만 상위, 하위 개념은 앞서 설명드린 implements(구현)에 해당합니다. 상위 개념을 Interface 로 두고 상위 개념에 해당하는 함수들을 하위 개념 Class 에서 명시하는것입니다. 반면 extends(상속)은 extends 가 의미하는대로 단순 확장에 해당합니다. Cat 중에서 줄무늬가 있는 Cat이 있을때 StripeCat 은 Cat 의 줄무늬를 제외한 모든 함수와 변수는 동일합니다. composite (구성, 합성) 특정 클래스가 특정 클래스를 내부 변수로 갖고있는것을 뜻합니다. 구성은 단순히 갖고있다는 의미인데 왜 패턴에서 중요하게 쓰일까요. extend 가 interface 와 composite 의 조합으로 표현될 수 있기 때문입니다. CatClass 가 줄무늬를 갖는것을 상속을 통해 Sprite 함수 및 변수를 넣어주지 않고, “종” 이라는 하나의 상위 클래스를 두고 “줄무늬종” 임을 하위 클래스로 명시해준다면 상위 개념인 “종”에 그 하위에 무슨 “종”이든 다 넣을 수 있는 확장성을 갖게됩니다. 바로 위 extends(상속)과 비교해보십시오. 좌측에 SpriteCatClass 가 갖고있던 Sprite 정보가 우측 클래스로 이동했습니다. Inversion of Control 의 의미가 조금 짐작되시는지요. CatClass 가 줄무늬뿐만 아니라 두 눈이 오드아이라고 설정해봅시다. 이 또한 상위-하위 개념인 interface 와 has 를 통해 EyesClass 에 OddEyesClass 를 명시하는것이 좋겠지요. 아까 제 1 원칙 “구현이 아닌 인터페이스에 맞춰 프로그래밍 한다.” 다음에 제 2 원칙 “상속대신 구성과 인터페이스를 사용한다” 가 되겠습니다. 이제 이 세 개의 화살표(구현, 상속, 구성)와 두 개의 원칙으로 디자인 패턴들을 살펴보겠습니다. 1: https://martinfowler.com/articles/injection.html2: http://www.nextree.co.kr/p11247/3: http://www.nextree.co.kr/p6753/","link":"/2018/12/30/a-introduction-to-design-patterns/"},{"title":"프로페셔널해 보이는 메일 주소 만드는 방법","text":"좋은 메일 주소메일은 내용 및 형식뿐만 아니라 주소에도 예절이 있습니다. 가끔 전화번호에도 외우기 쉬운 전화번호들이 있습니다. 어떤 일에 연락하기 적합한 사람을 찾을때 머릿속에서 가장 쉽고, 먼저 떠오른다면 업무에 있어서나 헤드헌터에 의해 회사와 연결될때 더 많은 성과를 가져갈 수 있겠죠. 우리의 이메일 주소는 대개 아이디에 그 뒤에 네이버나 다음같은 도메인이 붙습니다.문제는 우리가 매우 어린나이에 네이버주니어 같은 서비스를 이용하기 위해 해당 도메인에 가입을 했다는것입니다. 그러다보면 우스꽝스럽거나 어떤 캐릭터 이름 혹은 귀여운 아이디가 대다수입니다. 마치 과거 버디버디 아이디를 들췄을때 부끄러운 그것 말이죠. 부끄러운건 당사자 뿐만이 아닙니다. 그 아이디로 연락을 하는 상대분들은 어떨까요. 외국 대학, 기업뿐아니라 외국인과 같이 커뮤니케이션을 하고싶다면 위와 같은 과거의 주소는 지양하는것이 좋습니다. 계속 써왔던 메일이라 새 메일주소를 생성하는것이 불편하시다면 메일 포워딩을 사용하시길 권장합니다. 추천 이메일일반적으로 다음과 같은 규칙을 갖기를 추천합니다. 핵심은 기억하기 쉬운 이메일 입니다.각 규칙에 들어가는 단어들은 첫글자나 약어로 하셔도 좋습니다만 되도록이면 온전한 단어로 쓰시는것이 기억하기 좋습니다. First Name 이름 First Name 이름 + Last Name 성 Generic : 메일 수신 목적에 맞는 이름 예는 다음과 같습니다. aaron@domain.com aaronryu@domain.com contact@domain.com 만약 Gmail 을 사용하신다면 다음과 같은 좋은 기능^1을 제공해주니 활용하시는것이 좋습니다. . : 마음껏 점을 찍어서 가독성을 높힐 수 있습니다. 점을 찍지않은 본래의 메일로 자동 포워딩됩니다. aaron.ryu@domain.com + : 받을때 특정 필터를 적용한 채로 메일을 수신할 수 있습니다. 이 또한 본래의 메일로 자동 포워딩됩니다. 이력서에 명시한 메일은 aaron.ryu+recruit 이라면 recruit 필터 규칙에 걸러집니다. aaron.ryu+recruit@domain.com 중복 이메일개인적으로 지메일에서 메일을 생성하려하니 중복된 주소가 이미 생성되어있었습니다.그럴때에는 각 아이디나 메일 입력 폼에 숫자를 붙이거나 성과 이름의 방향을 바꿔 추천해줍니다만 사용하지 않는것이 좋습니다. 외국인들은 이름 내 순서를 이름 + 성 으로 사용하기때문에 그 규칙을 그대로 따르는것이 좋습니다. 그렇지 않다면 외국인이 “성” 으로 저를 부를지도 모릅니다.생년을 적는다면 특히 나이에 대해 동양만큼 민감하지 않은 외국인들에게 그 사람을 떠올렸을때 몇년에 태어났는지까지 기억해야하는 불필요한 정보를 제공하게 됩니다. 이럴땐 어떻게 하는것이 좋을까요.쉽게는 직무를 명시할 수 있겠고, 번거롭게는 하나의 도메인을 생성하는것도 좋습니다. aaron.ryu.dev@domain.com = aaronryudev@domain.com aaronryu@aaronryu.com 아이디뿐만 아니라 도메인에도 자신의 이름이 중복으로 들어가서 언프로페셔널하게 느껴질것이 걱정되신다면 걱정하지 않으셔도 될 것 같습니다. 오히려 자신만의 도메인이 있다는것과 메일 시 직접 그 사람과 이야기한다는 느낌을 줄 수 있을 것입니다.^2 1: http://consultantjournal.com/blog/professional-email-address-ideas-for-common-names2: https://yeonlab.com/check-your-email-address/3: https://workplace.stackexchange.com/questions/11731/what-should-a-professional-email-address-look-like","link":"/2019/02/17/how-do-i-make-email-address/"},{"title":"5. 옵저버 패턴","text":"디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다. 1. 디자인 패턴에 앞서 2. 디자인 패턴의 제 1, 2 원칙 설명에 사용할 코드는 Java-like Pseudo Code 입니다. 변수프로그래밍을 처음 배울때 우리는 먼저 변수에 대해 배웁니다.변하지 않는 값은 Constant 상수라고 부르며, Variable 변수의 값은 수시로 변합니다.변수는 수시로 변할 수 있기 때문에 말 그대로 프로그램 내내 산전수전을 다 겪습니다. 상태변수는 위에서 언급한대로 정말 다양한 상태를 갖습니다. 이러한 변수의 상태를 알기 위해서는 두 가지 방법이 있습니다. Push 방식 자동: 변수가 자신이 상태가 바뀌었음을 우리에게 알려줍니다. Pull 방식 수동: 우리가 변수가 상태가 바뀌었는지를 직접 알아봅니다. 자동으로 우리에게 알려주는게 가장 편해보일 수도 있겠지만 굳이 알 필요가 없는데 계속해서 자신의 상태에 대해 말해준다면 매우 귀찮겠지요. 그 상태를 계속 추적하기 위한 자원도 불필요하게 낭비될것입니다. 그럴때는 우리가 필요할때만 상태를 볼 수 있는 수동의 방법도 필요합니다. 이를 조금 고지식하게 Push 와 Pull 방식으로 이야기합니다. 변수의 상태를 하나의 ‘주제’라고 본다면 주제를 중심으로 우리에게 알려주는지(Push) 아니면 우리가 알아보는지(Pull)에 따라 상태를 알 수 있는 방법이 나뉘는것입니다. 옵저버 패턴 옵저버 패턴은 변수의 상태를 Push 와 Pull 중 원하는 방식을 통해 알 수 있는 패턴입니다. 일반적으로 이 패턴을 설명할때 상태를 ‘주제’라 보고 Publish-Subscribe(발행-구독) 모델로 설명하곤합니다. 여기선 패턴 이름이 옵저버 패턴인 만큼 헷갈리지 않게 구독모델이 아닌 Observer와 Observable 두 가지 용어로만 설명을 드리겠습니다. 옵저버 패턴에는 앞서 말씀드린 딱 두 종류의 인터페이스만 존재합니다. 하나는 상태를 갖고있는 옵저버블, 나머지 하나는 상태를 보려하는 옵저버입니다. Observable위 옵저버 패턴 그림을 보시면 옵저버블 인터페이스는 두 가지 정보를 ‘구성’(has)합니다. 상태 (State) 옵저버 리스트 (Observers) 오해를 해서는 안되는 점이 옵저버블 인터페이스는 상태 자체가 아니라 상태를 ‘갖고 있다’는 것입니다. 상태를 갖고있다는 의미로 옵저버블, 즉 옵저버는 이 인터페이스를 통해 상태를 ‘볼 수 있다’는 의미인것입니다. 그리고 옵저버블은 상태를 알려주거나/알아보려는 옵저버들을 리스트(물론 다른 자료구조형도 가능합니다)로 관리하여 Push 방식의 경우에는 상태를 누구에게 보내줄지? 그리고 Pull 방식의 경우에는 상태를 누구만 볼 수 있는지? 결정할 수 있습니다. 옵저버블 인터페이스 123456interface Observable { protected List&lt;Observer&gt; observers; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObserver(Object obj);} 옵저버블 구현 123456class StateObservable implements Observable { private State state; public void changeState() { /* 상태가 변경됩니다. */ } public void registerObserver(Observer o) { /* 옵저버 제외 */ } public void removeObserver(Observer o) { /* 옵저버 추가 */ } notifyObserver 구현 - 1) Push 방식 12 public void notifyObserver(State state) { /* 2. 옵저버 리스트의 각 옵저버들에게 1. 상태를 전송 */ }} notifyObserver 구현 - 2) Pull 방식 123 public void notifyObserver() { /* 아무것도 하지 않습니다. */ null } public State getState() { /* 상태를 보고싶으면 옵저버가 이 함수를 호출하면 됩니다. */ return state; }} Observer옵저버는 길게 설명할 것 없이 상태를 보고자 하는 인터페이스입니다. 인터페이스인 만큼 해당 정보를 보고, 활용하고싶다면 의도에 맞게 원하는 방식대로 구현하여 사용하시면 됩니다. 옵저버 인터페이스 1234interface Observer { protected Observable observable; public void getStateFromObservable();} 옵저버 구현 1234567891011class StateObserver implements Observer { private State state; public StateObserver(Observable observable) { this.observable = observable; this.observable.registerObserver(this); } public void update(state) { this.state = state; }} 왜 StateObserver 를 Observable.getObservers().add(new StateObserver()) 방식으로 추가하지 않고 StateObserver 객체를 생성할때 Observable 를 넣어줌으로써 생성자 안에서 추가를 해주었을까요? Observable.getObservers()를 호출하지 않음으로써 옵저버 리스트를 옵저버블 외부에 절대 노출하지 않습니다. 옵저버 패턴을 왜 굳이 패턴으로 정의했을까요? 저렇게 복잡하게 할 필요까진 없을텐데요. 옵저버블과 옵저버 두 인터페이스가 서로의 구현에 대해서 전혀 알 필요없이 데이터만을 주고 받는데 의의가 있습니다. 좀 더 풀어쓰자면 아래와 같습니다. 옵저버블이 갖는 1. 상태와 2. 옵저버 테이블 모두 외부에 노출하지 않은채 오로지 옵저버들만 알게끔하는 것이죠.“서로 상호작용을 하는 객체 사이에는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.”는 원칙입니다. 잘 이해가 되셨는지요. 오늘의 디자인 패턴은 여기서 마치도록 하겠습니다.","link":"/2019/02/27/observer-pattern/"},{"title":"2. 디자인 패턴의 제 1, 2 원칙","text":"설명에 사용할 코드는 Java-like Pseudo Code 입니다. 내게 대학교 시절에 객체지향 프로그램은 다형성과 상속뿐이었지만 책이 아닌 실제 프로그래밍으로 접한 객체지향 프로그램은 학문이 아니라 실전이었습니다. 왜 이걸 배웠고 이게 사실 어떤 의미를 갖는건지 그제서야 깨달을 수 있었습니다. 여기서는 짧게 우리가 생각했던 상속을 살펴보고 디자인 패턴으로 도약하기 위해 상속을 버리는 두 개의 원칙을 익히려고 합니다. 상속 = 객체지향 프로그램?처음 엔터프라이즈 객체지향 프로그램을 작성한다고 가정해봅시다. 학교에서 공부한대로라면 객체지향 프로그램은 상속이라고 배웠습니다. 그래서 우리는 과감히 상위 클래스를 만들고 이를 상속하여 하위 개념에 해당하는 클래스를 활용할 것입니다. 그리고 객체지향 프로그래밍 프로젝트 #1 이라고 이름 짓겠죠. 코드는 아래 헤드퍼스트 책의 예제와 같을 것입니다. 처음 배웠던 상속 상위 클래스 + 상위 행위 1class Duck { swim(), display(), fly(), quack() } 하위 클래스 + 상위 행위 확장 1234class RedHeadDuck extends Duck { swim(), display(), fly(), quack() }class RubberDuck extends Duck { swim(), display(), fly(){ null }, quack() } 상속을 사용하였더니 상위 Duck 클래스에 있는 모든 상위 행위들을 하위 Duck 클래스들이 모두 갖게됩니다. 어떤 하위 Duck 클래스는 의지와 상관없이 갖고싶지 않지만 무조건 모든 상위 행위를 갖고 확장해야합니다. 개발에 있어 불필요한 제약을 갖게되는 것입니다. 그럼 아래와 같이 선택적으로 행위를 가져갈 수 있도록 행위를 인터페이스로 분리해 가져보겠습니다. 상속 대신 인터페이스 상위 클래스 1234class Duck { interface Flyable; interface Quackable; swim(), display() } 행위 인터페이스 12interface Flyable { fly() }interface Quackable { quack() } 하위 클래스 + 행위 인터페이스 구현 1234class RedHeadDuck extends Duck implements Flyable, Quackable{ swim(), display(), fly(), quack() }class RubberDuck extends Duck implements Quackable { swim(), display(), quack() } 드디어 상위 클래스에 속하던 행위를 인터페이스로 분리하여 하위 클래스에 원하는 행위들만 붙일 수 있게 되었습니다. 하지만 두 개의 오리가 같은 소리를 갖는다면 Quackable 오리 각각에 quack() 을 똑같이 구현해주어야 합니다. 두 개의 오리면 괜찮겠지만 100 중 70 종의 오리가 같은 소리를 낸다면 70 개의 같은 quack() 구현 코드를 작성해야합니다. 그 중 몇 개의 quack() 소리를 다른 타입으로 바꾸려해도 같은 반복작업이 생기게 됩니다. 그럼 행위 인터페이스 구현을 따로 만들어서 원하는 구현을 선택적으로 가져보면 더 좋지 않을까요? 인터페이스 ‘구현’이 아닌 ‘구성’ 상위 클래스 1234class Duck { interface Flyable; interface Quackable; swim(), display(), doFly(){ Flyable.fly() }, doQuack(){ Quackable.quack() } } 행위 인터페이스 12interface Flyable { fly() }interface Quackable { quack() } 행위 인터페이스 구현 1234class NotFlyable implements Flyable { fly(){...} }class SuperFlyable implements Flyable { fly(){...} }class ShoutQuackable implements Quackable { quack(){...} }class QuiteQuackable implements Quackable { quack(){...} } 하위 클래스 + 행위 인터페이스 구현 12345678class RedHeadDuck extends Duck{ interface Flyable = class SuperFlyable(); interface Quackable = class ShoutQuackable(); swim(), display(), doFly(){ Flyable.fly() }, doQuack(){ Quackable.quack() } }class RubberDuck extends Duck{ interface Flyable = class NotFlyable(); interface Quackable = class QuiteQuackable(); swim(), display(), doFly(){ Flyable.fly() }, doQuack(){ Quackable.quack() } } 인터페이스를 구현하는것이 아닌 구성을 통해 클래스 내부 변수로 갖게되면서 원하는 행위 인터페이스 구현을 마음껏 갖고 바꿀 수 있게 되었습니다. 이로써 인터페이스를 대학교때 배웠듯이 클래스의 템플릿이다.라는 이해에서 조금 더 나아가 클래스가 갖는 행위나 특성을 담을 수 있는 하나의 ‘변수’로 생각할 수 있으면 좋을것 같습니다. 이것이 우리가 다형성을 배운 이유이기도 합니다. 디자인 패턴의 제 1, 2 원칙위에서 배운 내용은 사실 아래 두 원칙에 해당합니다.복습 겸 한번 더 복기하고 다음 챕터로 넘어가도록 하겠습니다. 구현보다 인터페이스에 맞춰서 코딩한다. 구현은 언제나 바뀔 수 있다. 인터페이스를 통해 유연하게 구현하자 fly(), quack() 같은 행위를 클래스 내부에서 구현하지 않고 인터페이스로 대체함으로써 필요한 것과 필요하지 않은 것들을 분리할 수 있습니다. 인터페이스는 ‘상속’보다는 ‘구성’으로 사용하자 인터페이스를 ‘상속’이 아닌 ‘구성’ 시 원하는 구현을 붙였다 떼었다 할 수 있다. 인터페이스를 ‘상속’하면 인터페이스의 모든 함수들을 그를 상속하는 클래스 안에서 구현해야합니다. 구현이 클래스 안에 갖혀버림과 동시에 구현과 클래스 내부간의 강결합이 생깁니다. 반면 ‘구성’을 사용하면 인터페이스를 구현한 구현 클래스 단 하나로 어느곳에서든지 사용 가능합니다. 레고처럼 붙였다 떼었다 할 수 있어 쉽게 바꿀 수 있고, 구현 클래스 로직과 그걸 사용하는 클래스 간 결합이 풀리게 됩니다.","link":"/2019/02/21/two-principles-of-design-patterns/"},{"title":"Swift 4+ Keywords - \"open\"","text":"Java - Class자바에서는 Class 를 정의하면 기본적으로 상속이 가능합니다. Java - Abstract Class자바에서는 공통된 부분은 구현해놓고, 변경이 필요한 부분은 추상 메서드로 분리하여 상속한 클래스에서 구현하도록 강제합니다. 이 전략 패턴을 위해 추상 클래스을 제공합니다. 추상 클래스는 아래 두 부분으로 구성됩니다. 변경이 필요한 부분: 추상 클래스 상속 시 따로 정의해야하는 추상 메서드와 (오버라이딩 필수) 공통 부분: 기본으로 제공되는 메서드 (오버라이딩 불가) 기본 메서드는 일반 상속과 달리 상속임에도 오버라이딩이 불가능한 반면 추상 메서드는 상속 시 꼭 오버라이딩을 통해 구현해주어야합니다. Swift 에서 “open” 키워드가 Java - Abstract Class 와 동일합니다. Swift - Open12345open class User { open func login() { } public func playGame() { } public init() { }} “public” = Uninheritable, CallableSwift 에서는 Java - Class 와 달리 class 가 기본적으로 상속가능하지 않습니다. public 도 마찬가지로 Java - Public 과 달리 기본적으로 상속가능하지 않습니다. struct 도 마찬가지입니다. “open” = Inheritable, Callable클래스를 상속을 하기 위해서는 class 에 상속이 가능하다는 의미의 “open” 키워드를 추가해야합니다. 함수에 “open” 키워드를 사용한다면 클래스 전체가 아니라 함수 레벨에서 ‘상속 가능한 함수’와 ‘상속 불가능한 함수’들을 쉽게 관리할 수 있습니다. Java 와 Swift 의 상속에 대한 처리는 완전히 반대입니다. Public 한 클래스와 함수들에게 기본적으로 상속 가능하게 하고 상속을 제한하기 위해서 private 나 protected 와 같은 접근 제한자를 사용하는 Java 와 반대로 Swift 는 개발자들에게 기본적으로 모두 상속 불가능하게 하고 상속을 하기위해선 open 을 명시하게끔 제한함으로써 잘못 상속하는걸 방지합니다. 출처: https://www.hackingwithswift.com/example-code/language/what-does-the-open-keyword-do","link":"/2019/03/09/swift-keyword-open/"},{"title":"4. 데코레이터, 어댑터, 퍼사드 패턴","text":"디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다. 1. 디자인 패턴에 앞서 2. 디자인 패턴의 제 1, 2 원칙 설명에 사용할 코드는 Java-like Pseudo Code 입니다. 분장술아기돼지 삼형제를 보면 양가죽을 쓰고 하얀색 분으로 손을 칠해 양으로 변장한 늑대가 나옵니다. 물론 너무 어설픈 나머지 막내돼지한테 비웃음을 당하지만 돼지들의 집을 들어가기 위해서는 ‘변장’이 필요했던 것이죠. 이번에 얘기할 내용은 분장과 변장에 대한 이야기입니다. 여기서 잠깐 그 차이를 알아볼까요. 분장분장은 현재 나의 모습에서 조금 더 과장한 나의 모습으로 꾸민것입니다.나 자신은 그대로, 어렵게 말하면 본질은 해치지 않는 선에서 그 위에 무엇인가를 추가로 꾸민것이죠. 변장변장은 현재 나의 모습에서 완전 다른것의 모습으로 꾸민것입니다.나 자신이 아닌 완전 다른 어떤것으로 꾸민것이죠. 이번 챕터에서 배울것은 분장에 해당하는 데코레이터 패턴과 변장에 해당하는 어댑터 패턴입니다. 마지막으론 앞서 두 패턴처럼 한 클래스를 다른 클래스로 바꾸는것이 아닌 다수의 클래스를 하나의 클래스로 단순히 묶어주는 퍼사드 패턴을 다루고 마칠 예정입니다. 어댑터 패턴 - 변장앞서 늑대가 돼지삼형제 집으로 들어가기 위해 순한 양으로 변장했습니다. 무시무시한 발톱을 하얀 분칠을 통해 예뻐보이는 손으로 바꾸었고, 그르렁거리는 목소리를 순한 양처럼 메에 흉내내기도 해봅니다. 이를 클래스로 표현하면 이해가 매우 Sheep습니다. 늑대 12345678class Wolf { public String Claw() { return \"Sharp Claw\"; } public String Growl() { return \"Grrrrrrr\"; }} 늑대가 돼지삼형제 집에 들어가기 위해 양으로 ‘변장’했군요. 123456789class WolfWantsToBeSheep implements Sheep { public Wolf wolf; public String Hand() { wolf.Claw().replace(\"Sharp Claw\", \"White Hand\"); } public String Sound() { wolf.Growl().replace(\"Grrrrrrr\", \"Baaaaaaa\"); }} 이제 늑대는 양이 들어갈 수 있는곳이면 어디든 갈 수 있습니다. 양만 들어갈 수 있는 돼지삼형제 집에 한번 들어가보겠습니다. 돼지삼형제 집 1public void WelcomeToPigHouse(Sheep sheep); 실제 양은 돼지삼형제 집에 잘 들어갑니다. 1WelcomeToPigHouse(new Sheep()); 이런, 양으로 변한 늑대도 돼지삼형제 집에 들어갔군요. 1WelcomeToPigHouse(new WolfWantsToBeSheep(new Wolf())); 어떤 클래스나 함수를 클라이언트로 본다면 클라이언트들은 특정 타켓 인터페이스에만 맞게 구현되어있습니다. 이런 제약때문에 다른 클래스를 해당 클라이언트에서 사용하고 싶을지라도, 해당 클래스가 타겟 인터페이스의 구현체가 아니라면 사용할 수 없습니다. 위의 예처럼 태어났을때부터 늑대였지만 돼지삼형제 집에 가기위해서는 순한 양이 되어야하는 상황말이죠. 일반 비지니스에서도 이와 같이 어떤 클래스를 클라이언트 목적에 맞는 클래스로 사용해야하는 갑작스런 요구사항이 발생하곤 합니다. 객체 어댑터위 늑대와 양의 예시처럼 어댑터 패턴은 어댑터라는 타겟 인터페이스의 구현 클래스를 생성하고 그 안에 타켓 인터페이스로 변장하고자 하는 클래스를 객체로 갖습니다. 이를 어댑티라고 명명하는데요. 어댑티의 원래 함수와 프로퍼티들을 활용하여 타겟 인터페이스의 각 함수들을 구현하면 됩니다. 이걸 객체 어댑터로 부르는 이유는 어댑티를 어댑터가 객체로 갖고 있기 때문입니다. 이를 우리는 ‘구성’이라고 배웠었지요. 아래의 코드를 보면 Adapter 가 Adaptee 를 객체로 가지고 있습니다. 클래스 다이어그램이 이해를 조금 더 도와줄겁니다. 123456public void Client(TargetInterface interface);class Adapter implements TargetInterface { private Adaptee adaptee; // ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.} 1this.Client(new Adapter(new Adaptee())); 어답티는 어답터의 도움으로 TargetInterface 만을 사용하는 클라이언트에 주입가능해졌습니다. 그럼 클래스 어댑터은 무엇일까요? Adapter 가 Adaptee 를 객체의 형태로 ‘구성’하지 않고 클래스의 형태로 ‘상속’하면 됩니다. 클래스 어댑터클래스 어댑터는 되려 단순합니다. 아래 코드와 클래스 다이어그램을 보시면 객체 어댑터와 두 가지 차이점이 있습니다. Adapter 가 Adaptee 를 구성(has)하지 않고 상속(extends)하고 있습니다. Target 이 Interface 가 아니라 Class 로 존재하며, 그에 따라 구현(implements)이 아닌 상속(extends)을 하고 있습니다. 객체 어댑터1234class Adapter implements TargetInterface { private Adaptee adaptee; // ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.} 클래스 어댑터123class Adapter extends Target, Adaptee { // ... adaptee 함수를 활용해 Target 의 함수를 확장합니다.} 위 코드를 보고 흠칫하셨을것입니다. Java 에서는 다중 상속을 지원하지 않기때문에 extends A, B 와 같은 문법은 사용할 수 없습니다. 또한 이렇게 사용할 경우 Target 이 Interface 가 아닌 Class 이기 때문에 다른 클래스로 대체할 수 없을뿐더러 Adapter 와 Target 이 단단히 엮어버렸습니다. 이는 배운대로 유연성을 해치는 구조이기에 사용을 권하지 않습니다. 다중 어댑터다중 어댑터는 기존에 하나의 타겟 인터페이스만 지원하는것이 아닌 다수의 타겟 인터페이스를 모두 지원하는걸 의미합니다. 하나의 어댑티 클래스를 여기 인터페이스뿐만 아니라 저 인터페이스에서도 사용하고 싶을때 TargetOneInterface, TargetTwoInterface 를 하나의 어댑터 클래스로 연결하고 두 인터페이스의 모든 것을 구현하면 됩니다. 객체 어댑터가 아니라 클래스 어댑터라면 두 개의 클래스 TargetOne, TargetTwo 를 상속(extends) 하면 됩니다. 다중 (객체) 어댑터1234567public void ClientOne(TargetOneInterface interface1);public void ClientAnother(TargetTwoInterface interface2);class Adapter implements TargetOneInterface, TargetTwoInterface { private Adaptee adaptee; // ... adaptee 함수를 활용해 TargetOne/TwoInterface 의 함수들을 모두 구현합니다.} 데코레이터 패턴 - 분장데코레이터 패턴은 클래스에 추가적인 기능을 무수히 많이 추가하더라도 그 클래스는 본래 클래스의 기능을 유지하는 ‘분장’에 해당합니다. 데코레이터 패턴을 어댑터 패턴 다음에 같이 다루는 이유는 사실 원리는 어댑터-어댑티 개념과 같기 때문입니다. 어댑터가 Adaptee를 TargetInterface로 변장시켰다면, 데코레이터는 Decoratee를 Decoratee 자기 자신으로 분장시키는 꼴이 됩니다. 어댑터 패턴 - 변장: Adaptee != TargetInterface 123class Adapter implements TargetInterface { private Adaptee adaptee;} 데코레이터 패턴 - 분장: Decoratee == Decoratee 123class Decorator extends Decoratee { private Decoratee decoratee; } 데코레이터 패턴은 한번만 분장하기 위해 사용되지 않습니다. 자기 자신을 재귀적으로 계속 분장할 수 있는데요. 아무리 다양한 DecoratorA, DecoratorB 를 만들어 꾸미더라도 결국에 Decoratee 클래스기 때문에 기존 클라이언트에서는 크게 신경쓰지 않고 쓰던 그대로 사용하면 됩니다. 데코레이터 패턴은 Decorater 클래스가 Decoratee 를 Decoratee 로 분장하는것입니다.Decorator 는 Decoratee 를 상속받기 때문에 그 자신도 Decoratee 가 될 수 있습니다.따라서 Decorator 는 재귀적으로 Decoratee 에 위치할 수 있어 무한정 분장될 수 있습니다. 데코레이티: 꾸미고 싶은 객체 123class Decoratee { // ... } 데코레이터: 꾸며주는 객체 1234class Decorator extends Decoratee { private Decoratee decoratee; // ... decoratee 함수를 활용해 더 개선된 decoratee 함수로 확장합니다.} 단순한 코드는 위와 같지만 아마 책으로 접하신 데코레이터 패턴 코드는 아래와 같은 구조를 갖고 있었을것입니다. 추상 데코레이터: 꾸며주는 추상 객체 123456abstract class Decorator extends Decoratee { protected Decoratee decoratee; Decorator(Decoratee decoratee) { this.decoratee = decoratee }} 구현 데코레이터: 꾸며주는 구현 객체 123456class DecoratorA extends Decorator { DecoratorA(Decoratee decoratee) { super(decoratee) } // ... } 정말 단순한 데코레이팅만 원하신다면 처음에 설명해드린 형태로도 충분합니다. 그렇다 하더라도 위와 같이 추상 데코레이터와 구현 데코레이터를 나누는 걸 추천드리는 이유는 다음과 같은 이점을 갖기 때문입니다. 구현 데코레이터에서 공통으로 필요로하는 로직이나 프로퍼티(특히 데코레이티)를 두고 구현 시 활용 가능합니다. 수많은 구현 데코레이터들을 추상 데코레이터 하나로 관리할 수 있습니다. 구현보다 인터페이스를 사용하라.던 디자인 패턴 제 1원칙 기억하시나요? 구현이 아닌 인터페이스(혹은 추상클래스)의 이점은 원하는 구현클래스를 붙였다 떼었다 할 수 있는 유용성과 재사용성이었습니다. 예를 들어 구현 데코레이터들을 하나의 리스트나 셋으로 담아 관리하고싶을때 추상 데코레이터 타입의 리스트, 셋을 생성하여 사용할 수 있겠죠. 퍼사드 패턴 - 묶음마지막으로 배울 패턴은 퍼사드 패턴입니다. 어댑터와 데코레이터 패턴은 각 하나의 어댑티나 데코레이티를 갖는다는 공통점이 있고, 차이점은 어댑터는 다른 클래스로 ‘변장’하고 데코레이터는 같은 데코레이터(사실상 데코레이티)로 ‘분장’한다는 것 이었습니다. 퍼사드 패턴을 이 챕터에서 다룬다는것은 이들과 공통점이 있다는 것일텐데요. 어떤것이 같을까요? 퍼사드 패턴은 어댑터, 데코레이터 패턴의 공통점을 그대로 갖습니다. 어댑티, 데코레이티와 같이 활용하기 위한 클래스를 내부에 갖고있습니다. 다만 어댑터, 데코레이터가 어댑티, 데코레이티를 하나씩만 가졌다면 퍼사드는 엄청 많은 수의 클래스를 갖습니다. 그리고 어댑터와 데코레이터의 차이점이 ‘변장’이나 ‘분장’이냐의 차이였다면 퍼사드는 그저 그 자체로 새로운 클래스가 됩니다. 어댑터 패턴도 클래스 자신이 아닌 다른 클래스로 ‘변장’한다고 했는데 그럼 퍼사드 패턴도 마찬가지가 아닐까요? 아닙니다. 퍼사드 패턴은 특정 클래스가 다른 특정 클래스로 변장하는것이 아닌 다수의 클래스가 다른 하나의 클래스로 단순히 묶이는 것입니다. (객체) 어댑터 1234class Adapter implements TargetInterface { private Adaptee adaptee; // ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.} 퍼사드 123456class Facade { private ClassA classA; private ClassB classB; private ClassC classC; // ... ClassA, B, C 를 활용한 새 함수들을 만듭니다.} 퍼사드는 뒤에 어떠한 extends, implements 도 존재하지 않습니다. 단순히 여러 클래스를 묶어주는 하나의 클래스인 셈입니다. 항상 마지막에 가면 집중력이 흐트러지곤 합니다. 중간쯤 읽다보면 세줄요약을 시급하게 찾는 자신을 발견하셨을겁니다. 그래도 꼭 한번은 다 잃고 아래 세줄요약을 읽어주시기 바랍니다. 그래야 머리속에 한번에 들어갈 수 있으니까요. 어댑터 패턴 하나의 클래스(어댑티)를 다른 하나의 클래스(타겟 인터페이스)로 ‘변장’합니다. 1234class Adapter implements TargetInterface { private Adaptee adaptee; // ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.} 데코레이터 패턴 하나의 클래스(데코레이티)를 그 하나의 클래스(데코레이티)로 ‘분장’합니다. 1234class Decorator extends Decoratee { private Decoratee decoratee; // ... decoratee 함수를 활용해 더 개선된 decoratee 함수로 확장합니다.} 위 예제 코드는 이해를 위해 간단한 데코레이터 클래스를 작성했습니다. 본문에서 설명드린바와 같이 추상/구현 데코레이터로 사용하는걸 추천드립니다. 퍼사드 패턴 다수의 클래스를 다른 하나의 클래스로 묶습니다. 123456class Facade { private ClassA classA; private ClassB classB; private ClassC classC; // ... ClassA, B, C 를 활용한 새 함수들을 만듭니다.}","link":"/2019/02/27/adapter-decorator-facade-pattern/"},{"title":"3. 팩토리 메소드, 추상 팩토리 패턴","text":"디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다. 1. 디자인 패턴에 앞서 2. 디자인 패턴의 제 1, 2 원칙 설명에 사용할 코드는 Java-like Pseudo Code 입니다. 여러 상태에 따른 코드개발을 하다보면 어떤 상태에 따라 다른 플로를 작성해야할 상황이 발생합니다. 단순히 예/아니오 같은 단일 상태라면 if 문을 사용하도록 배웠고, 다중 상태라면 if-else 혹은 switch 를 사용하도록 배웠습니다. 코드는 간단하게는 로직의 나열이라고 볼 수 있는데요. 우리의 실생활에서도 이처럼 다중 상태에 따라 다양한 작업을 수행하곤 합니다. 결국 모든 실생활도 if-else/switch 로 설명이 가능하다는 의미겠지요. if-else 에 “의존한” 처리 라면 종류별 끓이기12345678910111213class RamemMaker { public void makeRamen(String type) { Water water = new Water(100); Ramen ramen; heat(water); if (type == \"볶음\") { ramen = 볶음라면; } else if (type == \"국물\") { ramen = 국물라면; } water.add(ramen); }} 라면 종류를 상태로 본다면 명시해준 라면 종류 String type 따라서 다른 라면을 끓입니다. 함수 makeRamen(String type) 은 아래와 같이 두 파트로 나눠볼 수 있습니다. 상태: 1.1. 라면 종류를 고르고 처리: 라면을 끓입니다. 상태와 처리라는 두 책임이 하나의 코드에 모여있군요. 1.상태와 2.처리를 한번 떼어내볼까요. if-else 를 “분리한” 처리 라면 끓이기 123456789class RamemMaker { RamenGetter ramenGetter = new RamenGetter(); public void makeRamen(String type) { Water water = new Water(100); Ramen ramen = ramenGetter.getRamen(type); heat(water); water.add(ramen); }} 라면 종류별 생성 123456789class RamenGetter { public Ramen getRamen(String type) { if (type == \"볶음\") { return 볶음라면; } else if (type == \"국물\") { return 국물라면; } }} 라면 종류별 생성을 책임지는 상태 함수는 재사용성을 갖게되었고, 상태 책임이 더 명확해 졌습니다. 여기서 함수 getRamen(String type)와 같이 상태에 따라 알맞은 클래스를 만들어서 주입해주는 함수를 팩토리라고 합니다. 팩토리는 if-else/switch 상태에 따라 다른 클래스를 생성 및 주입해주는 함수를 의미합니다. 일반적으로 팩토리 함수는 하나만으로 충분하기 때문에 정적 팩토리로 많이 사용됩니다. 다만 static 으로 정의된 함수는 상속을 통해 하위 클래스에서 해당 함수 사용 및 확장이 불가능하다는 단점만 유념하시면 됩니다. if-else + if-else팩토리는 단순히 한 상태에 따른 구현 클래스를 생성합니다. 라면은 라면 종류라는 한 상태뿐만 아니라 라면 업체라는 또 하나의 상태도 있습니다. 두 개의 상태가 생겼군요. 이를 이차원 상태로 보면 아래와 같이 if-else 문 안에 또 하나의 if-else 문을 갖는 구조로 볼 수 있습니다. 이차원 상태: 라면 업체 + 라면 종류12345678910111213if (company == \"A 업체\") { if (type == \"볶음\") { return A_볶음라면; } else if (type == \"국물\") { return A_국물라면; }} else if (company == \"B 업체\") { if (type == \"볶음\") { return B_볶음라면; } else if (type == \"국물\") { return B_국물라면; }} 같은 볶음라면이지만 제조를 어느 업체에서 했는지에 따라서도 나눌 수 있는것이죠. 일차원 상태분기는 비교적 쉬웠습니다. 이차원 상태를 고려하도록 확장하려면 아래와 같이 될텐데요. 상태: 1.1. 라면 종류를 고르고 1.2. 라면 업체를 고르고 처리: 라면을 끓입니다. 이번에는 1.상태와 2.처리라는 두 책임뿐 아니라 두 상태인 1.1.과 1.2.도 나누어야겠군요. 라면 끓이기 123456789class RamemMaker { RamenGetter ramenGetter = new ACompanyRamenGetter(); public void makeRamen(String type) { Water water = new Water(100); Ramen ramen = ramenGetter.getRamen(type); heat(water); water.add(ramen); }} 라면 종류별 생성 123interface RamenGetter { public Ramen getRamen(String type);} A 업체의 라면 종류별 생성 123456789class ACompanyRamenGetter implements RamenGetter { public Ramen getRamen(String type) { if (type == \"볶음\") { return A_볶음라면; } else (type == \"국물\") { return A_국물라면; } }} B 업체의 라면 종류별 생성 123456789class BCompanyRamenGetter implements RamenGetter { public Ramen getRamen(String type) { if (type == \"볶음\") { return B_볶음라면; } else (type == \"국물\") { return B_국물라면; } }} 라면 종류가 함수 내 if-else 로 분기를 탔다면, 라면 업체는 클래스를 따로 만들어서 분기를 탔습니다. 전자를 팩토리 함수 후자를 팩토리 클래스로 볼 수 있겠네요. 어떤 회사의 어떤 종류의 라면인지에 따라 그에 맞는 RamenGetter 팩토리 클래스를 선택하면 RamenMaker 는 RamenGetter 가 생성한 라면을 만들어줍니다. 상태와 처리뿐만 아니라 두 상태도 깔끔하게 책임이 분리되었습니다. 지금까지 살펴본 코드에서는 어떤 라면인지 다양한 상태에 따라 RamenMaker 는 makeRamen 라는 동일한 처리 함수를 수행합니다. 하지만 잘 생각해보면 볶음라면과 국물라면은 끓이는 법은 동일할지라도 그 이후에 물을 버리느냐에 대한 차이가 있습니다. 즉 어떤 상태(What)인지에 따라 어떻게 처리(How)할지가 바뀌어야할 경우가 존재합니다. 팩토리 메서드 패턴상태에 따라서 처리 함수를 바꿔주고 싶은데, RamemMaker 는 하나밖에 존재하지 않습니다. 그러면 RamemMaker 를 인터페이스로 만들어서 ACompanyRamemMaker, BCompanyRamemMaker 와 같이 원하는 상태(라면 회사)에 따라 다른 처리 함수를 수행할 수 있습니다. 심지어 이전 처리 함수를 활용해서말이죠. 라면 생성 + 라면 끓이기 123456789abstract class RamemMaker { protected abstract Ramem getRamen(String type); public void makeRamen(String type) { Water water = new Water(100); Ramen ramen = getRamen(type); heat(water); water.add(ramen); }} A 업체의 라면 종류별 생성 + 라면 끓이기 1234567891011121314151617class ACompanyRamenMaker extends RamenMaker { @Override public Ramen getRamen(String type) { if (type == \"볶음\") { return A_볶음라면; } else (type == \"국물\") { return A_국물라면; } } @Override public void makeRamen(String type) { super.makeRamen(type); if (type == \"볶음\") { drainWaterForFrying(); } }} 기존에는 라면 종류를 RamenGetter 팩토리 클래스를 통해 선택했지만 위 코드에서는 getRamen 추상함수에서 선택하도록 만들었습니다. 상태 추상함수를 상속하여 오버라이드해서 원하는 상태 구현함수를 만들어 사용하는 것입니다. 팩토리 메서드 패턴은 팩토리가 생성하는 구현 클래스를 팩토리 클래스가 아닌 추상함수에 의존합니다 팩토리 클래스 - 팩토리는 클래스 RamenGetter 로 존재 123class RamenMaker { RamenGetter ramenGetter = new ... ; public void makeRamen(String type) { ... 팩토리 메서드 패턴 - 팩토리는 추상함수 getRamen 으로 존재 123abstract class RamenMaker { protected abstract Ramem getRamen(String type); public void makeRamen(String type) { ... 왜 팩토리 클래스로도 충분한데 추상함수를 갖는 추상 클래스를 상속받아서 구현하도록 제안할까요? RamenMaker 에 상태 추상로직과 처리 구현로직을 넣어서해당 클래스를 상속받으면 원하는 상태 구현로직을 만들 수 있을 뿐더러덩달아 처리 구현로직도 “확장”할 수 있다는 큰 장점을 갖기 때문입니다. 선택 추상로직을 클래스로 받았을때는 행위 구현로직에 대해 개입이 전혀 불가능했던것에 비하면 유연성이 매우 높아졌습니다. 추상 팩토리 패턴항상 팩토리를 검색하면 “팩토리 메서드 패턴”과 “추상 팩토리 패턴” 두 패턴이 나와 배울때 그 차이를 이해하는데 꽤나 힘들었습니다. 구분하자면 일차원 조건은 ‘팩토리’로 충분했으며, 이차원 조건을 위해 ‘팩토리 메서드 패턴’을 사용했습니다. 다음 ‘추상 팩토리 패턴’은 삼차원 조건을 처리하기위한 패턴이라고 이해하시면 쉽습니다. 라면업체와 라면종류 뿐만 아니라 라면에 들어가는 재료에 따라서 다른 라면이 생성된다고 가정합시다. 상태: 1.1. 라면 종류를 고르고 1.2. 라면 업체를 고르고 1.3. 라면 재료를 고르고 처리: 라면을 끓입니다. 쉬운 이해를 위해 아래와 같이 분류될 수 있습니다. 삼차원 상태: 라면 업체 + 라면 종류 + 재료1234567891011121314151617if (company == \"A 업체\") { if (type == \"볶음\") { if (type == \"치즈\") { return A_치즈_볶음라면; } else if (type == \"불닭\") { return A_불닭_볶음라면; } } else if (type == \"국물\") { if (type == \"해물\") { return A_해물_국물라면; } else if (type == \"사골\") { return A_사골_국물라면; } }} else if (company == \"B 업체\") { ...} 추가된 재료 상태를 지원하기 위해서는 단순히 재료를 생성해서 주입해주는 팩토리 클래스 단 한줄만 추가해주면 됩니다. 무언가 떠오르지 않으신가요? 가장 처음에 우리가 배웠던 팩토리 클래스 말입니다. 상태에 따른 라면 생성을 위해 팩토리 클래스를 적용하였다가 팩토리 메서드 패턴으로 바꾸었었는데요, 여기서는 그 팩토리 클래스를 다시 활용합니다. 단 이번엔 라면 생성 팩토리가 아닌 재료 생성 팩토리 클래스라는점이 다릅니다. 라면 끓이기 123456789class RamemMaker { protected abstract Ramem getRamen(String type); public void makeRamen(String type) { Water water = new Water(100); Ramen ramen = getRamen(type); heat(water); water.add(ramen); }} A 업체의 라면 종류별 끓이기 123456789101112131415161718class ACompanyRamenMaker extends RamenMaker { IngredientFactory ingredientFactory = new HotIngredientFactory(); @Override public Ramen getRamen(String type) { if (type == \"볶음\") { return A_볶음라면(ingredientFactory); } else (type == \"국물\") { return A_국물라면(ingredientFactory); } } @Override public void makeRamen(String type) { super.makeRamen(type); if (type == \"볶음\") { drainWaterForFrying(); } }} 이제 재료에 따라서 A 업체의 볶음라면은 다양한 바리에이션을 갖게 되었습니다. 위 예제에서는 HotIngredientFactory 매운재료를 사용했으니 A_불닭볶음라면이 생성될테고 부드러운 맛을 좋아한다면 MildIngredientFactory 치즈와 같은 재료를 가미한 A치즈_볶음라면을 생성할 수 있습니다. 라면을 만들었던 팩토리 클래스와 재료를 만드는 팩토리 클래스는 무엇을 만드는지가 다르다는것을 알 수 있습니다. 재료를 만드는 팩토리 클래스는 결국에 라면에 재료라는 상태 하나를 더 추가하여 한번 더 추상화한것입니다. (구현) 팩토리 클래스123456class RamemMaker { RamenGetter ramenGetter = new ACompanyRamenGetter(); public void makeRamen(String type) { ... Ramen ramen = ramenGetter.getRamen(type) // A_불닭_볶음라면 ... 구현 팩토리 클래스 = RamenGetter라면 팩토리 클래스는 그 자체로 완전한(재료가 다 가미된) 라면(구현 클래스)을 반환합니다. 추상 팩토리 클래스123456class ACompanyRamenMaker extends RamenMaker { IngredientFactory ingredientFactory = new HotIngredientFactory(); public Ramen getRamen(String type) { ... return A_볶음라면(ingredientFactory); // Hot 이므로 A_불닭_볶음라면 ... 추상 팩토리 클래스 = IngredientFactory재료 팩토리 클래스는 불완전한 라면(추상 클래스)에 가미할 재료들을 반환합니다.즉, 불완전 라면에 재료를 가미하여 완제품 라면(구현 클래스)로 만들어주는 추상 팩토리 클래스입니다. 두 클래스 RamenGetter, IngredientFactory 모두 내부에서 클래스를 생성해서 주입해주는 ‘팩토리’ 클래스 입니다. 다만 전자의 경우는 A_불닭_볶음라면이라는 구현 클래스를 주입해주고, 후자의 경우는 A_볶음라면이라는 추상 클래스에 들어가는 재료를 주입해줍니다. A_볶음라면이 A_불닭볶음라면이 될지 A치즈볶음라면이 될지는 추상 팩토리 클래스 IngredientFactory 의 구현에 의존합니다. 위의 예를 보자면 HotIngredientFactory 라는 매운재료를 사용했으니까 A불닭_볶음라면이라는 구현 클래스가 생성 &amp; 반환될 것입니다. 추상 팩토리 패턴은 추상 팩토리 클래스를 통해 팩토리가 생성하는 구현 클래스를 동적으로 변경할 수 있습니다. 이번 챕터에서는 팩토리 - 일차원, 팩토리 메서드 패턴 - 이차원, 추상 팩토리 패턴 - 삼차원을 익혔습니다. 앞으로는 “팩토리 메서드 패턴”, “추상 팩토리 패턴”을 구분 못할일은 없을것입니다. 더불어 누군가가 팩토리 패턴이라고 말한다면 그건 패턴이 아니라 클래스나 함수를 명명하는것이라고 귀띔해줄 수도 있게 되었습니다. 상태가 삼차원도 아니라 4차원, 5차원이라면 어떻게 다루면 될까요? 이 또한 재료뿐만 아니라 육수나 냄비와 같이 모두 추상 팩토리 패턴으로 추상화하면 됩니다. 하지만 상태가 그렇게 복잡해진다면 불필요하게 상태가 많아진것은 아닌지, 조건들을 단순화할 수 있는지 다시 한번 동료 프로그래머와 함께 검토해보시기 바랍니다. 팩토리 클래스 상태에 따라 그에 맞는 구현 클래스를 생성합니다. 팩토리 메서드 패턴 추상 클래스의 상태 추상함수를 통해 구현 클래스를 생성합니다. 상태 추상함수가 구현 클래스를 생성한다는 의미로 팩토리 메서드라고 합니다.추상 클래스를 상속하여 상태 추상함수 오버라이드를 통해 상태 구현함수를 구현합니다.추상 클래스의 처리 구현함수 또한 오버라이드를 통해 확장할 수 있는 장점이 있습니다. 추상 팩토리 패턴 추상 팩토리 클래스를 통해 추상 클래스(불완전 라면)를 특정 구현 클래스(완전 라면)로 결정할 구현 클래스(재료)를 생성합니다. 추상 클래스(불완전 라면)가 어떤 구현 클래스(완전 라면)가 될지는 추상 팩토리 클래스를 상속받은 구현 팩토리 클래스(재료 팩토리)를 구성(composition)함으로써 동적으로 결정됩니다.","link":"/2019/02/22/factory-method-and-abstract-factory-pattern/"},{"title":"6. 싱글턴 패턴","text":"디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다. 1. 디자인 패턴에 앞서 2. 디자인 패턴의 제 1, 2 원칙 설명에 사용할 코드는 Java-like Pseudo Code 입니다. ‘정적 변수’ 및 ‘정적 메서드’코드를 작성하다보면 변수나 메서드를 단 하나만 생성하여 모든 곳에서 공유하여 사용할 때가 있습니다. 정적 변수와 정적 메서드에 해당하는 개념입니다. Java 와 같이 객체지향 프로그램에서는 변수, 메서드 모두 클래스 내 존재해야하는 제약사항 때문에 공유하려는 전역 변수, 메서드를 클래스에 담아서 공유해야합니다. 재미있는 점은 정적 클래스라는 개념은 없기 때문에 클래스 안의 정적 변수나 메서드는 따로 객체 초기화 할 필요없이 바로 접근이 가능함과 동시에 원한다면 이 클래스를 객체로 초기화해서도 사용가능하다는 것입니다. 객체 초기화 없이 해당 클래스의 정적 변수와 정적 메서드를 사용한다니 이게 어떻게 가능한걸까요? Java, JVM 메모리Java 는 JVM 위에서 프로그램을 동작시키는데요. JVM 의 M, Machine 이 뜻하는대로 작은 OS 라고 보시면 됩니다. JVM 에서 돌리는 모든 프로그램의 자원을 JVM 이 관리합니다. 이런 이유로 Java 에 대한 이해는 JVM 메모리 관리에 대한 이해와 1:1의 관계에 놓여있습니다. 싱글턴 패턴을 배우기에 앞서 정적 변수, 메서드를 이해하기 위해 클래스, 변수, 메서드가 메모리에 어떤 JVM 메모리 영역에 할당이 되고 어떻게 정리가 되는지 간단하게 살펴보겠습니다. JVM 메모리 영역은 다음 세 영역으로 나뉩니다. 변하지 않는 값을 담는 Static 영역 (이를 칭하는 용어는 아래 총 3가지가 있습니다) 변하지 않는 값을 담는다는 의미에서 Static 영역이라 부르기도 하고 객체화 되기 전 Class 그 자체를 담는다는 의미에서 Class 영역이라 부르기도 하고 (Class Loading) 객체화 되기 전 Class 의 함수를 담는다는 의미에서 Method 영역이라 부르기도 합니다. 변하는 값을 담는 Heap 영역과 Stack 영역으로 나뉩니다. Stack 영역: 함수 내 ‘파라미터’나 ‘로컬변수’와 같이 그 함수 블록 내에만 생존하는 변수들을 저장 Heap 영역: 객체들을 저장 객체 생성의 가장 근간이 되는 Class 는 바이트코드 형태로 Static 영역에 적재됩니다. 그 Class 를 객체화할때마다 그 객체와 객체의 변수, 메서드는 위 클래스 바이트코드를 참조하여 생성된 뒤에 Heap 영역에 적재됩니다. 정적 변수, 메서드는 객체없이 Class 에 존재하는것이므로 Static 영역에 저장되겠군요. Static 영역에 Class 적재 및 객체 생성을 담당하는 것을 Classloader(클래스로더)라고 부르며 이 로더는 커스텀하게 바꾸지 않았다면 일반적으로 JVM 위에 하나만 존재합니다. 만약 두 개의 클래스로더가 있다면 같은 정적 변수라 할지라도 각자 다른 Static 영역에 적재됩니다. 정적 변수, 메서드와 일반 객체의 변수, 메서드는 적재된 영역이 다르기 때문에 서로 참조하지 못하는 특징을 갖습니다. 싱글턴 패턴정적 변수, 메소드정적 변수, 메서드는 ‘클래스로더’ 내 단 하나만 존재하는 유일무이한 “클래스”의 변수, 메서드입니다.(클래스로더는 한 프로그램에 다수 개일 수 있습니다.) Static 영역에 생성되는 클래스 변수, 메서드입니다. 프로그램의 시작과 동시에 클래스로더 에 의해 바이트코드형태로 Static 영역 메모리에 바로 적재됩니다. 12345678class Calculator { // * Public: Can be initialized from outer public Caculator() {} // * Static: sum(a, b) public static sum(Integer a, Integer a) { return a + b; }} 싱글턴 변수, 메소드싱글턴 패턴의 정의는 ‘클래스로더’ 내 단 하나만 존재하는 유일무이한 “객체”의 변수, 메서드입니다.(클래스로더는 한 프로그램에 다수 개일 수 있습니다.) Heap 영역에 생성되는 객체 변수, 메서드입니다. 프로그램 실행 도중 필요한 그 시점에 객체로 Heap 영역에 적재됩니다. 그리곤 오랜기간 사용되지 않는다면 GC 됩니다.(필요한 시점에 객체 생성하는것을 Lazy Loading 이라고 합니다. 싱글턴 패턴의 존재 의의기도 합니다.) 1234567891011121314151617class Calculator { // * Priavte: Cannot be initialized from outer private Caculator() {} // * Non-Static: sum(a, b) public sum(Integer a, Integer a) { return a + b; } // * Singleton: Can be initialized only once using getInstance() private static Calculator uniqueInstance; public static Calculator getInstance() { if (uniqueInstance == null) { uniqueInstance = new Calculator(); } return uniqueInstance; }} 차이를 아시겠나요? 하지만 유일한 클래스의 정적 변수, 메서드든 유일한 객체인 싱글턴 패턴이든 진입점이 한 곳인 만큼 다중 스레드가 한번에 진입점에 들어올 때 서로를 어떻게 독립적으로 수행할 수 있게 보장할지가 문제가 됩니다. 이를 유식한 말로는 다수의 스레드가 모두 이 클래스 내지는 객체에 접근을 하려 경쟁한다는 의미로 Race Condition(경쟁 상태)라고 합니다. Race ConditionJava 에서 다중 스레드를 사용할지라도 JVM 메모리에서는 따로 스레드별로 영역들을 지정해주지 않기 때문에 프로그래머가 접근제어를 해주지 않는다면 하나의 클래스 혹은 객체를 두 스레드에서 접근할 수 있습니다. Java 의 객체, 변수, 메서드 모두 기본적으로 non-blocking 이므로 여러 스레드에서 하나의 클래스 혹은 객체 접근을 동시에 할 경우 함수, 변수를 중복 호출/사용하는 문제가 발생합니다. 이를 해결하기 위해 가장 단순하게 생각할 수 있는것은 함수 단위로 blocking 하는것입니다. 위 싱글턴 패턴의 예로 사용한 Caculator 클래스의 getInstance() 함수를 두 개의 스레드에서 동시에 진입했다고 가정합시다. 동시에 if (uniqueInstance == null) 구문에 진입했을때 어느 스레드도 그 다음 라인인 new Caculator() 를 수행하지 않았다고 가정한다면 두 스레드 모두 uniqueInstance 가 null 인것으로 판단할것입니다. 그리고 그 다음 라인에 두 스레드 각각 새 객체를 생성하게 되고, 이렇게 된다면 두 스레드는 하나의 객체 함수가 아닌 각자의 객체 함수를 보게됩니다. 단순 계산 객체라면 큰 영향은 없겠지만 만약 하나의 상태를 공유하려는 객체라면 두 스레드가 서로 다른 상태를 보고있는 끔찍한 상황이 연출됩니다. 123Thread1: getInstance() if (uniqueInstance == null) { // 2019-03-03 00:00:01 uniqueInstance = new Calculator(); // 2019-03-03 00:00:03 - Calculator 객체 1 생성 (Thread1) 123Thread2: getInstance() if (uniqueInstance == null) { // 2019-03-03 00:00:02 uniqueInstance = new Calculator(); // 2019-03-03 00:00:04 - Calculator 객체 2 생성 (Thread2) 함수 단위 Blocking - Synchronized다수의 스레드가 한 함수에 접근하려 한다면, 하나의 스레드가 해당 함수를 수행하는 동안에는 기다리도록 blocking 합니다. Java 가 제공하는 synchronized 키워드를 사용하면 손쉽게 해당 함수 호출을 blocking 할 수 있습니다. 이젠 Thread 1 이 해당 함수를 호출하고 끝날때까지 Thread 2 는 해당 함수 호출을 계속 기다려야합니다. 두 스레드가 한 함수를 동시에 호출할일은 없어졌습니다. 12345678910class Calculator { ... public static synchronized Calculator getInstance() { if (uniqueInstance == null) { uniqueInstance = new Calculator(); } return uniqueInstance; }} 하지만 싱글턴 함수가 위에 로직보다 더 복잡하고 수행시간이 길다면 다른 스레드들은 한 스레드가 해당 함수 호출을 완료하는 그 긴 시간동안 멈춰있어야하는 성능의 이슈가 있습니다. 이런 경우에는 함수 단위의 blocking 이 아니라 함수 내 blocking 해야하는 딱 그 변수만 집어서 blocking 하는게 좋겠지요. 변수 생성 단위 Blocking - DCL (Double Checked Locking)우리의 원래 목적은 “변수”의 스레드간 공유인데, 굳이 함수 단위의 blocking 을 해서 변수 외 나머지 로직 수행의 시간까지 손만 빨며 성능 이슈까지 발생시킬 이유는 없습니다. 똑똑한 프로그래머들의 고민 결과 “함수”가 아닌 “변수” 단위의 Blocking 을 고안해내었고 이를 DCL (Double Checked Locking)이라고 명명합니다. 왜 Double Checked 일까요? 아래 코드를 보시면 객체 생성 로직 진입 전과 진입 후 생성하기전에 한번 더 null 여부를 검사하기 때문인것으로 알 수 있습니다. 함수 단위 Blocking - 함수에 synchronized 추가 1234567private static Calculator uniqueInstance;public static synchronized Calculator getInstance() { if (uniqueInstance == null) { uniqueInstance = new Calculator(); } return uniqueInstance;} 변수 생성 단위 Blocking - 변수에 volatile 추가, 함수 내 해당 변수에 synchronized 추가 1234567891011private volatile static Calculator uniqueInstance;public static Calculator getInstance() { if (uniqueInstance == null) { synchronized (Calculator.class) { if (uniqueInstance == null) { uniqueInstance = new Calculator(); } } } return uniqueInstance;} 기존 방식은 getInstance() 함수에 synchronized 가 붙어있는 반면, 변수 생성 단위 Blocking 에서는 변수에 volatile 이 추가되었고, 해당 함수 내 아까 volatile 을 추가한 변수에 대해서 synchronized 붙여준걸 알 수 있습니다. 여기서 유념히 보셔야할것은 변수를 사용하는 부분이 아닌 변수를 생성하는 부분에 synchronized 를 붙여줬음을 꼭 기억하시기 바랍니다. DCL (Double Checked Locking) 의 의미모든 프로그램 및 스레드는 CPU 을 통해 연산들을 수행하고, 연산을 위한 변수값들은 “메인 메모리”로부터 CPU 바로 옆 “캐시”로 가져와 사용하게 됩니다. 만약 두 스레드가 각자 다른 CPU (멀티코어 환경) 에서 하나의 싱글턴 혹은 정적 변수를 공유하여 작동한다면 어떤 일이 발생할까요? 두 스레드가 공유하는 하나의 변수는 기본적으로 “메인 메모리”에 적재되어 있습니다. 각 스레드가 각 CPU 에서 값을 변경하는 경우 1) 먼저 메인 메모리로부터 캐시로 변수값을 가져오고, 2) CPU 가 해당 캐시의 값을 변경하고, 3) 캐시에 변경된 값을 메인 메모리에 작성(동기화)하는 과정을 거칩니다. 두 스레드가 동시에 변수의 값에 접근할 경우, 첫번째 스레드가 자신이 할당된 CPU 내 캐시의 변수값을 먼저 바꿨음에도 불구하고 아직 메인 메모리에 쓰지 않아 두번째 스레드는 변경된 값을 모른채 자신의 CPU 에서 독립적으로 값 변경을 수행하는 문제가 발생합니다. 그렇다고 다수 스레드가 하나의 CPU 에서 수행된다고 하더라도 아예 문제가 없는것은 아닙니다. JIT 컴파일러에 의해 어셈블리 레벨 코드 재배열(Reorder)이 발생하여 스레드 간 참조하는 변수값이 달라질 수 있기 때문입니다. 위에서 설명한 스레드간 변수 동기화 내지는 불일치 문제를 한 스레드의 값 업데이트를 다른 스레드에서는 볼 수 없다는 의미의 가시성(Visibility) 문제라고 일컫습니다. 볼 수 있다면 Visible 하다. 라고 표현합니다. 가시성 문제를 해결하기 위해 “캐시”와 “메인 메모리” 간 읽은(READ) 값이 일치하도록 강제하는 것이 volatile 키워드 입니다. 변수에 volatile 키워드를 추가하면 해당 변수는 CPU 에서 “캐시”의 값을 읽을때 동시에 “메인 메모리”의 값을 Read 함을 보장합니다. 한 스레드에서 값을 변경한다면 바로 메인 메모리에 적용되고 다른 스레드가 값을 읽을 때 최신의 값을 읽을 수 있습니다. 하지만 두 스레드가 같은 메인 메모리 값을 가져다가 변경할 경우는 여전히 문제입니다. 값을 쓰는것은 어쩔 수 없이 blocking 을 걸어두어야합니다. 한 스레드가 작성하고있다면 다른 스레드는 기다렸다가 앞 스레드가 작성을 마치면 바로 메인 메모리로부터 값을 읽어서 그 다음 쓰기를 진행하면 됩니다. 이를 위해 값을 변경(WRITE)할때는 해당 클래스에 blocking 을 거는 synchronized 키워드를 함께 사용하면 됩니다. 변수 사용 단위 Blocking - Lazy Holder애석하게도 변수 생성 단위의 Blocking 으로 단일 생성이 완벽히 보장되진 않았습니다. 세상에, CPU 캐시까지 고려했는데 무엇을 또 놓쳤다는걸까요? 트랜지스터 레벨이라도 봐야하는 것일까요? DCL 을 통해 변수의 단일 생성 자체는 보장되었습니다. 다만 단일 생성 바로 직후에 다른 스레드에서 해당 변수를 바로 사용하려 한다면, 아직 채 완전히 생성되지 못한 변수를 사용하게 될 수 있다는 것입니다. 단일 생성을 시작하면 해당 클래스의 new ..를 통해 생성자를 수행하게 될 것입니다. 생성자가 조금이라도 복잡하다면 온전한 객체가 만들어지기 까지는 조금의 시간이 걸릴 것입니다. 하지만 해당 객체를 접근하는 다른 스레드는 그 라인의 끝마침을 기다려주지 않습니다. 이때 미처 다 온전하게 생성되지 않은 불완전한 객체를 다른 스레드에서 가져다가 사용하게 되는것입니다. 이를 out-of-order write 문제라고 명명합니다. 해결은 해당 객체가 단순히 생성되었다 여부가 아닌 완벽히 생성되었다는걸 보장하면 됩니다. 이를 보장하는 방식은 더 똑똑한 프로그래머들에 의해 정말 다양하게 제시되었는데요. 기발한것들도 있지만 그 중에 가장 이해가 쉬운것은 아래와 같습니다. 123456789public class Calculator { ... private static class LazyHolder { private static final Calculator UNIQUE_INSTANCE = new Calculator(); } public static Calculator getInstance() { return LazyHolder.UNIQUE_INSTANCE; }} static final 로 정의된 UNIQUE_INSTANCE는 클래스로더에 의해 프로그램 시작 시 가장 먼저 Static 영역에 바로 적재됩니다. 이를 통해 getInstance() 호출되기 이전에 UNIQUE_INSTANCE = new Calculator(); 가 무조건 존재함을 보장합니다. 사실상 위에서 배운 모든 것을 활용한 해결책에 해당합니다. 개인적으로 이 해결책이 기억에 남는 이유가 C# 에서 LazyHolder 형식을 기본적으로 제공해주기 때문에 싱글턴 패턴 사용이 아래와 같이 매우 쉽게 해결했던 기억이 있습니다. 123456public sealed class Singleton{ private static readonly Lazy&lt;Singleton&gt; lazy = new Lazy&lt;Singleton&gt;(() =&gt; new Singleton()); public static Singleton Instance { get { return lazy.Value; } } private Singleton() {}} https://gampol.tistory.com/entry/Double-checked-locking%EA%B3%BC-Singleton-%ED%8C%A8%ED%84%B4 http://thswave.github.io/java/2015/03/08/java-volatile.html","link":"/2019/03/02/singleton-pattern/"},{"title":"한 장으로 보는 함수형 프로그래밍 - 클로저, 커링, Functor, 모나드","text":"Swift 를 무턱대고 집어서 개인 프로젝트를 진행하던 중 함수형 프로그래밍 개념을 처음 제대로 마주했습니다. 개념을 제대로 모른채 사용해왔었지만 (사용은 정말 쉬우니까요) 이번 기회로 한번 정리해보았습니다. 클로저, 커링, Functor, 모나드. 희안하게 이름만 들어도 배우고 싶지 않은 ‘함수형 프로그래밍’을 처음 접하는 분들에게 도움이 되었으면 좋겠습니다. 본 글에선 함수형 프로그래밍 관련하여 접했던 개념들 ‘클로저’, ‘커링’, ‘Functor’, ‘모나드’ 의 개념’만’을 다룹니다. 이것을 사용하는 의의나 활용 방법들에 대해서는 본 글을 통해 개념을 익히신 후 다른 좋은 강좌들을 찾아서 공부하시면 좋을 것 같습니다. ‘함수’형 프로그래밍‘함수’형 프로그래밍은 아래 단 한마디로 요약할 수 있습니다. ‘함수’를 1. 변수에 2. 파라미터에 3. 반환값에 사용할 수 있으며, 수리학의 4. ‘순수 함수’와 동일한 특성을 갖습니다. ‘함수’는 일급시민(first-citizen) 함수입니다. ‘함수’를 변수에 대입할 수 있습니다. ‘함수’를 파라미터로 넘길 수 있습니다. ‘함수’를 반환할 수 있습니다 ‘함수’는 ‘순수 함수’ 특성을 갖습니다. No Side-Effects: 외부 상태나 변수, 환경의 영향을 받지 않는다. 같은 파라미터에 같은 반환값을 반환한다. 앞 세 특성은 시민권으로 비유되어 프로그래밍 변수의 권리를 모두 보장한다는 의미에 일급시민(first-citizen) 함수라 부릅니다. 함수 포인터꼭 함수형 프로그래밍이 아니더라도 우리는 과거에도 함수를 변수, 파라미터, 반환값으로도 사용할 수는 있었습니다.C 언어를 생각해보시면 함수는 “값, value”가 아니라 “참조, refer” 였기 때문에 이 함수를 가리키는 포인터가 있었고 이를 통해 포인터를 이 함수에 대한 변수로 사용할 수 있었고, 이 함수를 파라미터로 넘기고 싶다면 포인터를 전달하면 되었으며 함수를 반환하고 싶으면 반환하려는 함수에 대한 포인터를 반환하면 되었습니다. 1void qsort (void* base, size_t n, size_t size, int (*compare)(const void*,const void*)); 위 예를 보면 퀵소트 알고리즘의 마지막 파라미터로 compare 함수 포인터를 넘겨주는걸 볼 수 있습니다. 이처럼 함수 포인터로 변수, 파라미터, 반환값에 모두 쓸 순 있지만 포인터가 가리키는것이 정확히 어떤 함수인지를 알기위한 과정(dereferencing^1) 때문에 성능이 저하되는 단점을 갖습니다. 함수 값 함수를 포인터가 아닌 우리가 일반적으로 쓰는 Integer 1, 100 처럼 바로 값으로 사용하면 안될까? 1func qsort (base: Collection, n: Int, size: Int, compare: CompareFunc) 함수를 포인터가 아닌 값으로 사용한다면 ‘참조’하는 방식이 아닌 함수를 ‘복사’하는 방식으로 사용가능하게 되고, 참조에서 오는 성능 저하도 없을 뿐더러 함수타입만 맞다면 어떤 함수든지 사용가능한 유연성을 가질 수 있습니다. 클로저 (람다, 익명함수)함수가 값처럼 사용된다면 굳이 함수를 사용하기 전에 꼭 정의하고 사용해야할까요? 12qsort (..., n: n, size: size, ...)qsort (..., n: 0, size: 1000, ...) 우리가 값을 따로 정의하지 않고 바로 사용하는것처럼 함수도 정의하지 않고 사용하는 곳에서 바로 inline으로 만들어 사용하는걸 ‘클로저’라고 부릅니다. 당연히 일회성 사용이기 때문에 함수 이름은 필요없습니다. 클로저는 함수 이름이 없어서 익명함수 내지, 현대 수학 및 공학에 함수의 원형에 해당하는 람다(함수)로도 불립니다. 함수: 외부에서 정의하여 대입합니다. 1234var sorted = sort(names, forwards)func forwards(s1: String, s2: String) -&gt; Bool { return s1 &lt; s2} 클로저: 사용하는곳에서 바로 정의하여 사용합니다. 12var sorted = sort(names, /* 이곳에 비교함수를 inline 으로 넣고 싶습니다. */ )var sorted = sort(names, { (s1: String, s2: String) -&gt; Bool in return s1 &lt; s2 } ) 일반함수 쓰던대로 미리 정의하고 사용해도 될텐데 왜 굳이 클로저를 사용할까요? 함수는 정의 시 정의 구역 내 전역으로 존재합니다. (어려운 말로 전역 네임스페이스에 소속되는 정적인 구현체^2) 클로저는 정의 시 정의 블럭 내 일회성으로 존재합니다. 함수 예제의 경우 forwards 함수는 sort 에서 사용할 수 있을 뿐만 아니라 ‘접근 제한자’ 내라면 어디서든 사용할 수 있는 반면, 클로저 예제의 경우 { } 으로 정의된 함수는 sort 에서 사용됨과 동시에 없어져 다른곳에서 재사용이 불가능합니다. 결국 재사용할 함수냐 일회성 함수냐에 따라서 클로저 사용을 고려하면 됩니다. 클로저 사용 시 가독성 뿐만 아니라 메모리 효율의 장점도 갖게 되는것이죠. 클로저는 ‘익명함수’라 어디가 함수 구문의 시작이고 어디가 끝인지 구분해야하는데요. Swift 의 경우는 in 이후가 함수 구문입니다. Swift 클로저Swift 의 클로저는 아래와 같이 원하는 만큼 축약할 수 있습니다. 기본형: 파라미터 타입, 반환 타입을 명시하고 in 이후 함수 구문을 작성합니다. 1{ (parameters) -&gt; (return_type) in return /* statements using parameters */ } 축약형: 반환 타입을 암시적으로 결정합니다 1{ parameters in return /* statesments using parameters */ } 축약성애자: 반환 타입뿐만 아니라 반환 식의 return 도 없앴습니다. 1{ parameters in /* statesments */ } 변태: 파라미터 타입을 암시적으로 결정합니다. 사용은 파라미터 순으로 $0, $1 로 사용합니다. 1{ /* statesments using parameters with $0, $1 ... */ } Trailing Closure: 클로저가 마지막 파라미터로 사용된다면 파라미터에 넣지않고 함수 뒤 클로저 { } 로 바로 명시합니다. 12var sorted = sort(names, { $0 &lt; $1 })var sorted = sort(names) { $0 &lt; $1 } 함수객체 객체지향 프로그래밍에서의 클로저 객체지향 프로그래밍에서는 함수가 단일 함수로는 존재할 수 없는 한계가 있어 클로저를 사용하고싶다면 함수객체를 만들어 객체레벨로 사용해야합니다. 흔히 객체지향 프로그래밍에서 제공하는 람다는 단순히 ‘함수객체’의 Syntactic Sugar 라고 보시면됩니다. 겉으로는 함수만 달랑 존재하는것 같지만 실제론 이름없는 객체로 해당 함수를 감싸주어 사용되는것입니다. 고차함수‘고차함수’는 일급객체 함수 세 조건 중 두번째 혹은 세번째에 해당하는 함수를 뜻합니다. ‘함수’를 변수에 대입할 수 있습니다. ‘함수’를 파라미터로 받거나 ‘함수’를 반환하는 함수 ‘고차함수’는 ‘함수’를 파라미터로 혹은 반환값으로 사용하는 것을 의미합니다. 함수를 사용하는 함수다보니 메타적 ‘함수’라는 의미에서 한 차원 높은 함수, 고차함수라고 명명한것 같습니다. 커링‘커링’은 일급객체 함수 세 조건 중 세번째에 해당하는 함수를 뜻합니다. ‘함수’를 변수에 대입할 수 있습니다. ‘함수’를 파라미터로 넘길 수 있습니다. ‘함수’를 반환하는 함수 Curring, 커링은 ‘함수’가 ‘함수’를 반환하는 것입니다. 1func curringExample: (a: Int, b: Int, c: Int) -&gt; (Int, Int) -&gt; (Bool) { ... } 위 curringExample 예를 보면 a, b, c 파라미터를 받아 (Int, Int) 두 파라미터를 받아 -&gt; (Bool) 을 반환하는 함수를 반환합니다 Swift 에서 ‘클래스의 객체’가 ‘클래스 객체의 함수’를 호출하는 방법도 커링을 사용합니다. 12let someInstance = SomeClass()someInstance.someFunction(params: /* parameters */) 위 클래스 객체의 함수는 실제로 아래와 같이 클래스 함수에 객체를 넘겨 수행합니다.^3 1SomeClass.someFunction(self: someInstance)(params: /* parameters */) Functor모나드는 Functor 의 하위개념에 해당하므로 모나드 설명에 앞서 Functor 를 먼저 살펴보겠습니다. Functor 는 타입이자 패턴에 해당한다고 말할 수 있습니다. Functor 개념을 배우기에 앞서 일반 ‘함수’에 대해서 짧게 살펴보겠습니다. Mapping함수에 단일 데이터 A 를 적용하면 단일 데이터 B 라는 결과가 나옵니다.이를 달리 생각해보면 Input A 와 Output B 이 둘을 함수가 매핑하는것으로 볼 수 있습니다.즉, 함수를 ‘단일 데이터에 대한 Mapping’으로 볼 수 있습니다. Mappable단일 데이터인 A 와 B 는 List, Queue, Tree 등 다양한 데이터 구조의 구성 원소가 됩니다. 전체 데이터 구조에 대해 연산을 적용하고 싶다면 각 원소에 대해 원소에 대한 연산(함수)를 적용하면 됩니다. 위에 말했듯이 이 함수를 Mapping으로 본다면 각 원소에 대한 Mapping을 적용하면 되는것입니다. Functor = Mappable Funtor는 Mappable(Mapping 함수를 갖는) 데이터 구조입니다. Functor 는 아래 두 가지로 구성됩니다. 데이터 구조 단위 원소에 대한 Mapping 함수, 결과값은 단위 원소 어떤 2) 데이터 구조든 원하는 연산을 하고싶다면 데이터 구조안의 단위 원소가 어떤 타입(T)이고, 1) 단위 원소에 대한 Mapping만 정의하면 됩니다. 이렇게 단위 원소에 대한 Mapping을 정의할 수 있는 데이터 구조를 Mappable 하다고 합니다. Mapping 은 우리가 원하는 어떤 연산이든지 정의만 하면 됩니다. 1.은 클래스의 프로퍼티, 2.는 클래스의 메서드에 해당하므로 Functor 를 Function Object, 함수객체 로 보기도 합니다. Functor 개념은 범주론(Category Theory)에서 “하나의 카테고리에서 하나의 카테고리로 사상”되는걸 뜻합니다. 위에서 배운 “하나의 데이터 구조에서 하나의 데이터 구조로 내부 각각 원소들에 대해 Mapping”하는것과 개념적으로 전혀 다를바가 없음을 알 수 있습니다. 여기서 Mapping 은 범주론의 사상 개념과 동일하다고 생각하시면 되는데, 데이터 구조(범주)는 바뀌지 않은 채 값만 Mapping 되는 것을 natural transformation 라고 부릅니다. 따라서 이 Mapping 을 어떤 설명에서는 Transformation 으로 설명하기도 합니다. Haskell’s FunctorFunctor 를 찾다보면 하스켈의 Functor 개념을 먼저 접하실텐데 하스켈의 Functor 는 typeclass 로 아래와 같이 정의하며, 데이터 구조 타입을 명시해서 원하는대로 인스턴스화 하여 사용합니다. Swift-like 문법으로 표현하면 아래로 볼 수 있습니다. Functor (typeclass) 1) Operation(T) -&gt; (R) 2) S (Any Data Structure) Functor 구현 1) Operation(Int) -&gt; (String) = +2 and Stringfy 2) List 결국 Functor 는 데이터 구조 타입(S)과 그 내부 원소 타입(T, R)에 대해 Generic&lt;S, T, R&gt; 하며 내부 원소(T, R) Mapping 추상 함수를 가진 제네릭 추상 데이터 구조 클래스라고 부를 수도 있겠네요. Functor 패턴을 사용하는 다양한 언어들에서 이 추상함수를 위에서 배운 클로저로 바로 정의해서 주입해주는 방법으로 사용합니다. Functor 데이터 구조에 클로저로 넘겨준 Mapping 함수를 수행한 ‘결과 데이터 구조’를 받고 싶다면 사용하시는 언어에서 제공하는 Functor Map 의 의미를 가진 fmap() 이나 map() 함수를 정의하고 호출하면 됩니다. Java 유저라면 Stream 의 map() 함수를 떠올리시면 이해가 쉽습니다. Stream 이 Mapping 함수를 가질 수 있는, Mappable 데이터 구조에 해당하므로 Functor 라고 부를 수 있고, 그 Mapping 함수는 Stream.map() 에 클로저 형태로 정의해서 파라미터로 넘겨주면 됩니다. 어? Java Stream 은 모나드라고 배웠는데? 네 맞습니다. 정확히 말하자면 Java 의 Stream 은 Functor 보다 모나드라고 하는것이 맞습니다. 이유는 Mapping 함수가 1) Operation(T) -&gt; (R) 가 아니라 1) Operation(T) -&gt; (S) 이며 S 에서 T 를 추출하는 함수를 추가로 갖기 때문입니다. 원소(T)에서 원소(T)로 Mapping 하는 것이 아니라 아예 원소(T)에서 또 다른 Functor(S)로 반환하는 것이죠. 원소(T) 는 모나드 데이터 구조로부터 추출하여 사용합니다. 이 두 성질을 통해 Stream.map() 의 결과가 Stream 이니까 우리가 Stream.map().map().map()… 으로 사용할 수 있는것입니다. 조금 더 자세히 아래에서 살펴보겠습니다. Monad모나드가 무엇인지 한 마디로 정리하기에 앞서, 왜 모나드가 필요한지에 대해 알아보겠습니다. 프로그래밍 언어의 ‘프로그래밍 함수’와 우리가 배우는 수리학문에서의 ‘순수 함수’의 차이점이 무엇인지 아시는지요? 순수 함수 함수 실행 시 내부에 어떤 상황이 발생하더라도 최종적으로 값을 반환하는걸 보장합니다. 프로그래밍 함수 함수 실행 시 내부에 어떤 처리할 수 없는 상황이 발생하면 값을 반환하지 못한채 중간에 Exception을 발생시킵니다. 고등, 대학 수리 수업에서 그 어떠한 함수도 f(x) 중간에 실행하다가 입력해준 값이 잘못되어있으면 중간에 Exception을 내지(…) 않았습니다. 하지만 ‘함수형 프로그래밍’에서는 함수들이 ‘일급시민 함수’임과 동시에 ‘순수함수’여야 하는 조건이 있습니다. 이를 만족시키기 위해 ‘프로그래밍 함수’에서 Exception 발생시 중간에 멈추는것이 아니라 해당 ‘상태’가 발생했음을 ‘상태’값으로써 반환하도록 해야합니다. ‘상태’값과 함수 본연의 ‘결과’값을 함께 반환하기 위해 이 둘을 묶는 데이터 구조가 필요할것 같습니다. 데이터 구조에 들어있는 ‘결과’값에 대해서 우리가 원하는 Mapping 연산들을 수행해야하니까 Functor 라는 데이터 구조를 사용하면 딱 적합할 것 같습니다. ‘순수함수’성을 위해 Exception 이 발생할 수 있는 ‘상태’ 및 ‘결과’를 모두 포함하는 데이터 구조로 Functor 를 사용해 보겠습니다. 하지만 Functor 를 그대로 사용하였더니 Functor 의 성질에 따라서 Exception ‘상태’를 갖는 Functor가 우리가 연산을 통해 ‘결과’값을 알고싶어서 주입한 데이터 ‘T’가 있는 Functor에 한번 더 감싸진채로 반환되었습니다. Functor 는 연산을 수행하려는 데이터 구조에서 내부 원소를 꺼내고(Unwrap) 그에 대한 Mapping 을 수행하고, Mapping 의 결과 원소를 데이터 구조에 다시 한번 넣어서(Wrap) 반환합니다. 문제는 Unwrap/Wrap 을 함수로 따로 명시하지 않고 Functor 자체적으로 지원하는 구조라는 것입니다. 우리는 Unwrap 과정만 필요하고, Wrap 과정은 불필요합니다. 해결을 위해 우리는 Unwrap/Wrap 구조를 사용하지 않고 명시적으로 Unwrap 에 대한 함수만 정의해 주면 됩니다. 그리고 Functor 와 똑같이 Unwrap(flatMap) 함수에 의해 얻어진 ‘데이터 구조의 내부 원소’에 대한 Mapping 을 정의하고 그 결과를 내부에서 ‘데이터 구조’로 반환하도록 하는것이 모나드 패턴입니다. Monad? Monad는 Unwrap(flatMap) 함수를 포함하는 Mappable 데이터 구조입니다.Monad의 Mapping 함수는 ‘결과’와 ‘상태’ 모두를 갖는 데이터 구조를 반환합니다. 모나드는 아래 세 요소를 갖습니다. 데이터 구조 단위 원소에 대한 Mapping 함수, 결과값은 데이터 구조 데이터 구조에서 값을 꺼내는 Unwrap(flatMap) 함수 모나드에 대한 설명을 보면 Context 와 Content 이 둘을 가진 데이터 타입으로 설명하는 글들이 많습니다. 위에서 설명한 내용을 바탕으로 Context 는 값이 있음/없음에 대한 ‘상태’값이고, Content 는 우리가 연산하려는 ‘값’ 내지 ‘결과’값에 해당합니다. Monad 의 Context 가 꼭 값이 있음/없음의 상태를 가져야하는것은 아니지만 일반적으로 함수 수행 중에 Exception 이 발생할 수 있는 경우들은 값이 null 인 경우가 대부분이기 때문에 많은 설명들에서 nullable 로 설명하는것 같습니다. 모나드를 확실하게 이해했다면 nullable 이 아닌 다른 ‘상태’를 갖게 할 수 있을것 같습니다. 예를 들면 Async 를 위한 데이터 구조의 경우 NotRequested, Requested, Wait, Responsed 와 같이 다양한 상태들을 갖고 각각에 대한 Mapping 함수들도 원하는대로 만들 수 있지 않을까요. 이에 대해서는 저도 더 깊은 공부와 여러 강의들^4을 듣고 실제로 프로젝트에 활용해 보면서 그때가서야 ‘함수형 프로그래밍’에 대한 더 깊은 글을 쓸 수 있을것 같습니다. Function Composition모나드는 설명드렸듯이 ‘프로그래밍 함수’의 ‘순수함수’화를 위해 ‘함수형 프로그래밍’에 도입된 개념입니다. 순수함수는 두 성질을 갖는데요. 모나드의 의의는 데이터 구조가 ‘상태’를 갖는다는것 뿐만 아니라 함수의 합성이 가능하다는 점도 있습니다. identity: 자기 자신으로 Mapping 할 경우 외/내부 어떤 변화도 없이 처음과 같은 값을 언제나 반환해야한다. composition: 두 Mapping 함수 f(x), g(x) 가 있다면 두 함수를 합성시 f(g(x)) = (f.g)(x) 의 결과를 갖는다. 이렇게 함수형 프로그래밍의 클로저, 고차함수, 커링, Functor, 모나드 총 5개의 개념을 다뤄보았습니다. 사실 클로저, 고차함수, 커링은 전혀 어려운 개념이 아닙니다. 세 개념 모두 단 한마디로 정의할 수 있을 정도로 간단합니다. 다만 익숙해지기 위해서는 실제 프로젝트에 많이 사용해봐야겠지요. Functor 와 모나드는 이제 한마디로 정의할수는 있지만 실제 구조와 개념들을 파악하는데는 꽤나 어려운 개념이었습니다. 개인적으로 Functor 가 패턴을 뜻하는건지, 데이터 구조(타입)을 뜻하는건지, 함수를 뜻하는건지 한 개념으로 잡히지 않아 애를 먹었었습니다. 범주론에서 Functor 는 함수로 표현되고 하스켈에서의 Functor 는 typeClass 라고 정의하기 때문에 이 두 간극이 하나의 개념으로 메워지지 않았었습니다. 이 글을 쓰기 위해 꽤 많은 시간을 공부한것 뿐만 아니라 글을 작성하는 중간에도 잘못된 이해와 새로운 이해들이 겹쳐서 꽤 도전적이었습니다. 위 글에 대한 질문 및 관련 논의는 언제나 환영입니다. 감사합니다. 참조 http://seorenn.blogspot.com/2014/06/swift-closures.html https://medium.com/@sjsyrek/five-minutes-to-functor-83ef9075978b https://medium.com/@jooyunghan/functor-and-monad-examples-in-plain-java-9ea4d6630c6 https://stackoverflow.com/questions/356950/what-are-c-functors-and-their-uses https://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html","link":"/2019/03/24/only-one-page-for-functional-programming/"}],"tags":[{"name":"Functional Programming","slug":"Functional-Programming","link":"/tags/Functional-Programming/"},{"name":"함수형 프로그래밍","slug":"함수형-프로그래밍","link":"/tags/함수형-프로그래밍/"},{"name":"Closure","slug":"Closure","link":"/tags/Closure/"},{"name":"클로저","slug":"클로저","link":"/tags/클로저/"},{"name":"High-order Function","slug":"High-order-Function","link":"/tags/High-order-Function/"},{"name":"고차함수","slug":"고차함수","link":"/tags/고차함수/"},{"name":"Curring","slug":"Curring","link":"/tags/Curring/"},{"name":"커링","slug":"커링","link":"/tags/커링/"},{"name":"Functor","slug":"Functor","link":"/tags/Functor/"},{"name":"펑터","slug":"펑터","link":"/tags/펑터/"},{"name":"Monad","slug":"Monad","link":"/tags/Monad/"},{"name":"모나드","slug":"모나드","link":"/tags/모나드/"}],"categories":[{"name":"Web Development","slug":"Web-Development","link":"/categories/Web-Development/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/categories/Design-Pattern/"},{"name":"Raw Thought","slug":"Raw-Thought","link":"/categories/Raw-Thought/"},{"name":"Project","slug":"Project","link":"/categories/Project/"},{"name":"Spring","slug":"Web-Development/Spring","link":"/categories/Web-Development/Spring/"},{"name":"미분류","slug":"미분류","link":"/categories/미분류/"},{"name":"Singleton","slug":"Design-Pattern/Singleton","link":"/categories/Design-Pattern/Singleton/"},{"name":"Language","slug":"Language","link":"/categories/Language/"},{"name":"Programming","slug":"Raw-Thought/Programming","link":"/categories/Raw-Thought/Programming/"},{"name":"Swift w/ Realm","slug":"Project/Swift-w-Realm","link":"/categories/Project/Swift-w-Realm/"},{"name":"Open Diary","slug":"Raw-Thought/Open-Diary","link":"/categories/Raw-Thought/Open-Diary/"},{"name":"Swift 4","slug":"Language/Swift-4","link":"/categories/Language/Swift-4/"},{"name":"Troubleshoot","slug":"Troubleshoot","link":"/categories/Troubleshoot/"},{"name":"Workplace","slug":"Workplace","link":"/categories/Workplace/"},{"name":"Observer","slug":"Design-Pattern/Observer","link":"/categories/Design-Pattern/Observer/"},{"name":"Database","slug":"Troubleshoot/Database","link":"/categories/Troubleshoot/Database/"},{"name":"Swift 4+","slug":"Language/Swift-4","link":"/categories/Language/Swift-4/"},{"name":"Adapter, Decorator","slug":"Design-Pattern/Adapter-Decorator","link":"/categories/Design-Pattern/Adapter-Decorator/"},{"name":"Factory","slug":"Design-Pattern/Factory","link":"/categories/Design-Pattern/Factory/"},{"name":"Functional Programming","slug":"Language/Functional-Programming","link":"/categories/Language/Functional-Programming/"}]}