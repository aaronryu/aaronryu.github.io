{"pages":[{"title":"","text":"\"잘 까먹어서 슬픈 붕어, 사진은 연어입니다.\" Aaron Ryu Software Developer \"Cool Heads, Warm Hearts\" aaron.ryu.dev@gmail.com | +82 10 5549 7201 Seoul, 05328, Republic of Korea Resume: Page | LinkedIn | Google Docs ( Korean, English ) Specialty Web Development: Front-end &amp; Back-end","link":"/about/index.html"},{"title":"","text":"Aaron Ryu Software Developer \"Cool Heads, Warm Hearts\" aaron.ryu.dev@gmail.com | +82 10 5549 7201 Seoul, 05328, Republic of Korea Specialty Web Development: Front-end &amp; Back-end Skills Kotlin 1.3, Java 8+ w/ Spring React.js and Angular.js w/ Typescript Swift 4+ (iOS) AWS Experience Coupang, Seoul - Software Developer 2017.08 ~ Current 쿠팡 여행 관련 상품 정보 관리 및 예약 시스템 개발에 기여 쿠팡 내 외부 여행 상품 연동을 위한 API 개발 및 연동 쿠팡 자회사의 펜션 상품 및 예약 시스템에 대한 유지보수 쿠팡 자회사의 펜션 상품 및 예약 시스템의 쿠팡 인프라로의 이관 및 전환 TF &nbsp;&nbsp;&nbsp;&nbsp;&gt; 아키텍쳐에 상응하는 새 AWS VPC 인프라 구성 및 보안 아키텍쳐 검토 커뮤니케이션/매니징 Education 한국과학기술원 전산학부 - 석사 2015.08 ~ 2017.08 HypergraphDB와 같은 그래프 데이터베이스 조사, 하이퍼그래프에 대한 질의 프로세싱 관련 연구 한국항공대학교 컴퓨터 및 정보 공학과 - 학사 2011.02 ~ 2015.02 Hadoop 및 HDFS 을 활용한 영상처리 연구 및 개발 Papers &amp; Conferences Attended 대용량 하이퍼그래프에 대한 효율적인 탐색 기법과 분석에의 응용 2017.07 컴퓨팅의 실제 분야: 정보과학회 컴퓨팅의 실제 논문지(KIISE Transactions on Computing Practices, KTCP)&gt; 류충모, 서정혁, 김명호 동형 서브그래프 검사를 이용한 향상된 하이퍼그래프 쿼리 시스템 설계 2017.06 2017 한국컴퓨터종합학술대회 (KCC 2017)&gt; 류충모, 서정혁, 김명호 대용량 하이퍼그래프에 대한 효율적인 BFS, DFS 탐색 기법 2016.12 한국정보과학회 (제43회) 2016년 동계학술대회 논문집, 205-207 + 우수발표논문상 수상&gt; 류충모, 서정혁, 김명호 하둡 분산 시스템에서의 효율적인 데이터 분할 기법 2015.06 한국정보과학회 학술발표논문집 (한국컴퓨터종합학술대회 논문집) 제42권 1호 1668~1670&gt; 장민욱, 이대철, 정재헌, 류충모, 김철기 Extensible Video Processing Framework in Apache Hadoop 2013.12 IEEE International Conference on Cloud Computing Technology and Science (CloudCom) + Demo session&gt; 류충모, 이대철, 장민욱, 김철기, 서의성 Hadoop 기반 클라우드 컴퓨팅을 이용한 영상 처리 프레임워크 구현 2013.11 제40회 한국정보처리학회 추계학술발표대회 논문집 제20권 2호 139~142&gt; 류충모, 이대철, 장민욱, 김철기 Projects 대형 바이오 네트워크 데이터 분석을 위한 도구와 하이퍼그래프 데이터베이스 시스템 개발 2016.06 ~ 2017.07 GRRC (Cloud Computing System for Next-generation Broadcast Media) 2012.07 ~ 2013.06 비디오 작업을 위한 Hadoop 기반 프레임워크 제작 Patents 동영상 파일을 하둡 분산 파일 시스템에 분산 저장하는 시스템, 동영상 맵리듀스 시스템 및 그 제공방법 2013 특허 제 10-1460062호- 출원번호: 2013-0071441 / 출원일: 2013년 06월 21일, 등록일: 2014년 11월 04일- 김철기, 장민욱, 이대철, 유충모 Extracurricular activities TEDxKAIST – 오거나이저 중 ‘스피커(연사자 모집)’ 팀 2016.11 ~ 2017.03 12th TEDxKAIST WITH 개최 동아시아 평화 인권 캠프 (서울대 팀) 2014.02 ~ 2015.06","link":"/resume/index.html"}],"posts":[{"title":"1. 디자인 패턴에 앞서","text":"디자인 패턴은 대학교에서 간단하게만 배웠던 기억이 닙니다. 대학원에서도 입사 준비 때도 주변에서는 디자인 패턴이 중요하다지만 실제로 잘 사용하는 사람은 없었고, 이게 왜 중요한지에 대해서도 체감하기 힘들었었습니다. 어렸을때는 내 코드에 대한 리뷰어나 배울만한 시니어 개발자들이 없었으니 당연하다 생각합니다. 제가 코딩과 공부를 능동적으로 안해온것이 크겠지만 패턴이 왜 쓰이는지 경험적으로 습득한것은 입사하고 나서부터 였으니까요. 디자인 패턴디자인 패턴은 짧게 “객체지향 패러다임에서 더 좋은 코드란 무엇인가에 대한 고민의 결과” 입니다. 중복의 최소화: 한 곳의 수정이 중복된 다른 코드에서의 수정을 동반해선 안됩니다 코드 변경의 용이성: 코드는 항상 완벽하지 않고, 요구사항은 상시 바뀔 수 있습니다. 재사용성: 정돈된 코드는 전혀 다른 요구사항 및 비슷한 경우에도 그대로 사용이 가능합니다. 너무나도 먼 디자인 \u001c패턴우리는 어떻게보면 디자인 패턴을 모르는것이 당연합니다. 코드 한 줄의 변경이 다른 줄의 변경을 일으킬만한 큰 프로젝트를 만들어본적이 없습니다. 교내 팀 프로젝트에서 Web Application 으로 API 서버를 만들어서 고객 폰의 앱으로 주변 AP 정보를 파싱하고, LCD 패널이 붙은 라즈베리 파이로 해당 고객 위치에 따른 재실표시기를 만들었을때도 정말 코드가 단순명료했습니다. 학생분들이라면 아시죠 환경 계획 및 구축이 60% 고 개발이 20% 입니다. 남은 20% 은 술마셔야죠. 팀 프로젝트로 만든 코드는 다신 볼일이 없습니다.요구사항 변경을 요청할 교수도 다른 프로젝트에 활용할 일도 없습니다. 팀 프로젝트 발표를 마치고 학점을 받으면 친척동생이 놀러와 롤을 깔때즘 용량문제로 소스코드를 지우는 상황에 이릅니다. 가끔 입사 준비 중 볼일이 있습니다만 예로 학부생 코드는 고쳐쓰는게 아니라했습니다. 결국엔 직접 해보아야 합니다.본 카테고리에선 직접 해보며 조금이나마 짧고 명료하게 정리해놓으려합니다.복습없인 항상 까먹기 일수거든요. 앞으로 본 카테고리에선 여러 디자인 패턴들에 대해서 살펴보려합니다. 각 패턴의 설명은 기본적으로 글을 사용하겠지만 클래스 다이어그램을 통해 이해를 도우려고 합니다. 클래스 다이어그램 화살표클래스 다이어그램은 이름 자체가 내포하고있듯 Class 간의 관계를 표로 간단하게 설명한 것으로 Class 개념이 존재하는 객체지향 프로그래밍(OOP)에서 프로젝트 구현을 위한 설계도라고 보시면 될 것 같습니다. 클래스 다이어그램 자체로 한 챕터 분량이지만, 디자인 패턴에는 Class, Interface 이 둘만 필요하므로 딱 핵심적인 화살표 세 개만 살펴보겠습니다. 앞으로 Java 기반으로 설명하겠습니다. implements (구현) 일반적으로 코드는 인터페이스를 단위로 구성됩니다. 사용하려는 구현 클래스를 코드 내에 지정하지 않고 인터페이스만을 명시하고 그 인터페이스의 위치에 원하는 구현 클래스를 연결(주입)하여 실제 작업을 수행합니다. 앞으로 설명할 모든 디자인 패턴의 주축이 되는 제 1 원칙이니 조금 더 설명드리겠습니다. 학생분들은 모든 클래스를 사용할때 아래 코드를 사용하실겁니다. 1ConcreteClass class = new ConcreteClass(); 우리가 배운 다형성을 활용하면 인터페이스와 구현 클래스를 나눠서 인터페이스에 우리가 원하는 구현 클래스들을 다음과 같이 동적으로 주입할 수 있습니다. 1Interface class = new ConcreteClass(); 1Interface class = new SuperConcreteClass(); 주입을 직접 Interface 에 하지않고 아래처럼 더 간편하게 함수를 통해 해줄 수 있습니다. 12345private Interface class;public void setClass(Interface class) { this.class = class;}setClass(new ConcreteClass(); 사용하려는 구현 클래스가 무엇인지 바로 명시하지 않고 원하는 구현 클래스를 동적으로 Interface 에 외부에서 주입하기 때문에 결정권을 갖지 않는다는 이유로 Dependency Injection, 내지는 Inversion of Control 이라 부릅니다. extends (상속) 상속은 클래스의 몇몇 함수에 대해 추가적인 기능이나 다른 로직의 함수로 대체하고 싶을때 사용합니다. 일반적으로 대학교때 객체지향 프로그램의 가장 큰 특성을 상속으로 배우고 Animal 과 같은 상위 클래스와 그를 상속하는 Cat, Dog 같은 하위 개념 클래스를 예제로 배우니 상위, 하위 클래스를 사용할때 상속을 많이 사용합니다. 하지만 상위, 하위 개념은 앞서 설명드린 implements(구현)에 해당합니다. 상위 개념을 Interface 로 두고 상위 개념에 해당하는 함수들을 하위 개념 Class 에서 명시하는것입니다. 반면 extends(상속)은 extends 가 의미하는대로 단순 확장에 해당합니다. Cat 중에서 줄무늬가 있는 Cat이 있을때 StripeCat 은 Cat 의 줄무늬를 제외한 모든 함수와 변수는 동일합니다. composite (구성, 합성) 특정 클래스가 특정 클래스를 내부 변수로 갖고있는것을 뜻합니다. 구성은 단순히 갖고있다는 의미인데 왜 패턴에서 중요하게 쓰일까요. extend 가 interface 와 composite 의 조합으로 표현될 수 있기 때문입니다. CatClass 가 줄무늬를 갖는것을 상속을 통해 Sprite 함수 및 변수를 넣어주지 않고, “종” 이라는 하나의 상위 클래스를 두고 “줄무늬종” 임을 하위 클래스로 명시해준다면 상위 개념인 “종”에 그 하위에 무슨 “종”이든 다 넣을 수 있는 확장성을 갖게됩니다. 바로 위 extends(상속)과 비교해보십시오. 좌측에 SpriteCatClass 가 갖고있던 Sprite 정보가 우측 클래스로 이동했습니다. Inversion of Control 의 의미가 조금 짐작되시는지요. CatClass 가 줄무늬뿐만 아니라 두 눈이 오드아이라고 설정해봅시다. 이 또한 상위-하위 개념인 interface 와 has 를 통해 EyesClass 에 OddEyesClass 를 명시하는것이 좋겠지요. 아까 제 1 원칙 “구현이 아닌 인터페이스에 맞춰 프로그래밍 한다.” 다음에 제 2 원칙 “상속대신 구성과 인터페이스를 사용한다” 가 되겠습니다. 이제 이 세 개의 화살표(구현, 상속, 구성)와 두 개의 원칙으로 디자인 패턴들을 살펴보겠습니다. 1: https://martinfowler.com/articles/injection.html2: http://www.nextree.co.kr/p11247/3: http://www.nextree.co.kr/p6753/","link":"/2018/12/30/a-introduction-to-design-patterns/"},{"title":"4. 데코레이터, 어댑터, 퍼사드 패턴","text":"디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다. 1. 디자인 패턴에 앞서 2. 디자인 패턴의 제 1, 2 원칙 설명에 사용할 코드는 Java-like Pseudo Code 입니다. 분장술아기돼지 삼형제를 보면 양가죽을 쓰고 하얀색 분으로 손을 칠해 양으로 변장한 늑대가 나옵니다. 물론 너무 어설픈 나머지 막내돼지한테 비웃음을 당하지만 돼지들의 집을 들어가기 위해서는 ‘변장’이 필요했던 것이죠. 이번에 얘기할 내용은 분장과 변장에 대한 이야기입니다. 여기서 잠깐 그 차이를 알아볼까요. 분장분장은 현재 나의 모습에서 조금 더 과장한 나의 모습으로 꾸민것입니다.나 자신은 그대로, 어렵게 말하면 본질은 해치지 않는 선에서 그 위에 무엇인가를 추가로 꾸민것이죠. 변장변장은 현재 나의 모습에서 완전 다른것의 모습으로 꾸민것입니다.나 자신이 아닌 완전 다른 어떤것으로 꾸민것이죠. 이번 챕터에서 배울것은 분장에 해당하는 데코레이터 패턴과 변장에 해당하는 어댑터 패턴입니다. 마지막으론 앞서 두 패턴처럼 한 클래스를 다른 클래스로 바꾸는것이 아닌 다수의 클래스를 하나의 클래스로 단순히 묶어주는 퍼사드 패턴을 다루고 마칠 예정입니다. 어댑터 패턴 - 변장앞서 늑대가 돼지삼형제 집으로 들어가기 위해 순한 양으로 변장했습니다. 무시무시한 발톱을 하얀 분칠을 통해 예뻐보이는 손으로 바꾸었고, 그르렁거리는 목소리를 순한 양처럼 메에 흉내내기도 해봅니다. 이를 클래스로 표현하면 이해가 매우 Sheep습니다. 늑대 12345678class Wolf { public String Claw() { return &quot;Sharp Claw&quot;; } public String Growl() { return &quot;Grrrrrrr&quot;; }} 늑대가 돼지삼형제 집에 들어가기 위해 양으로 ‘변장’했군요. 123456789class WolfWantsToBeSheep implements Sheep { public Wolf wolf; public String Hand() { wolf.Claw().replace(&quot;Sharp Claw&quot;, &quot;White Hand&quot;); } public String Sound() { wolf.Growl().replace(&quot;Grrrrrrr&quot;, &quot;Baaaaaaa&quot;); }} 이제 늑대는 양이 들어갈 수 있는곳이면 어디든 갈 수 있습니다. 양만 들어갈 수 있는 돼지삼형제 집에 한번 들어가보겠습니다. 돼지삼형제 집 1public void WelcomeToPigHouse(Sheep sheep); 실제 양은 돼지삼형제 집에 잘 들어갑니다. 1WelcomeToPigHouse(new Sheep()); 이런, 양으로 변한 늑대도 돼지삼형제 집에 들어갔군요. 1WelcomeToPigHouse(new WolfWantsToBeSheep(new Wolf())); 어떤 클래스나 함수를 클라이언트로 본다면 클라이언트들은 특정 타켓 인터페이스에만 맞게 구현되어있습니다. 이런 제약때문에 다른 클래스를 해당 클라이언트에서 사용하고 싶을지라도, 해당 클래스가 타겟 인터페이스의 구현체가 아니라면 사용할 수 없습니다. 위의 예처럼 태어났을때부터 늑대였지만 돼지삼형제 집에 가기위해서는 순한 양이 되어야하는 상황말이죠. 일반 비지니스에서도 이와 같이 어떤 클래스를 클라이언트 목적에 맞는 클래스로 사용해야하는 갑작스런 요구사항이 발생하곤 합니다. 객체 어댑터위 늑대와 양의 예시처럼 어댑터 패턴은 어댑터라는 타겟 인터페이스의 구현 클래스를 생성하고 그 안에 타켓 인터페이스로 변장하고자 하는 클래스를 객체로 갖습니다. 이를 어댑티라고 명명하는데요. 어댑티의 원래 함수와 프로퍼티들을 활용하여 타겟 인터페이스의 각 함수들을 구현하면 됩니다. 이걸 객체 어댑터로 부르는 이유는 어댑티를 어댑터가 객체로 갖고 있기 때문입니다. 이를 우리는 ‘구성’이라고 배웠었지요. 아래의 코드를 보면 Adapter 가 Adaptee 를 객체로 가지고 있습니다. 클래스 다이어그램이 이해를 조금 더 도와줄겁니다. 123456public void Client(TargetInterface interface);class Adapter implements TargetInterface { private Adaptee adaptee; // ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.} 1this.Client(new Adapter(new Adaptee())); 어답티는 어답터의 도움으로 TargetInterface 만을 사용하는 클라이언트에 주입가능해졌습니다. 그럼 클래스 어댑터은 무엇일까요? Adapter 가 Adaptee 를 **객체의 형태로 ‘구성’**하지 않고 **클래스의 형태로 ‘상속’**하면 됩니다. 클래스 어댑터클래스 어댑터는 되려 단순합니다. 아래 코드와 클래스 다이어그램을 보시면 객체 어댑터와 두 가지 차이점이 있습니다. Adapter 가 Adaptee 를 구성(has)하지 않고 상속(extends)하고 있습니다. Target 이 Interface 가 아니라 Class 로 존재하며, 그에 따라 구현(implements)이 아닌 상속(extends)을 하고 있습니다. 객체 어댑터1234class Adapter implements TargetInterface { private Adaptee adaptee; // ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.} 클래스 어댑터123class Adapter extends Target, Adaptee { // ... adaptee 함수를 활용해 Target 의 함수를 확장합니다.} 위 코드를 보고 흠칫하셨을것입니다. Java 에서는 다중 상속을 지원하지 않기때문에 extends A, B 와 같은 문법은 사용할 수 없습니다. 또한 이렇게 사용할 경우 Target 이 Interface 가 아닌 Class 이기 때문에 다른 클래스로 대체할 수 없을뿐더러 Adapter 와 Target 이 단단히 엮어버렸습니다. 이는 배운대로 유연성을 해치는 구조이기에 사용을 권하지 않습니다. 다중 어댑터다중 어댑터는 기존에 하나의 타겟 인터페이스만 지원하는것이 아닌 다수의 타겟 인터페이스를 모두 지원하는걸 의미합니다. 하나의 어댑티 클래스를 여기 인터페이스뿐만 아니라 저 인터페이스에서도 사용하고 싶을때 TargetOneInterface, TargetTwoInterface 를 하나의 어댑터 클래스로 연결하고 두 인터페이스의 모든 것을 구현하면 됩니다. 객체 어댑터가 아니라 클래스 어댑터라면 두 개의 클래스 TargetOne, TargetTwo 를 상속(extends) 하면 됩니다. 다중 (객체) 어댑터1234567public void ClientOne(TargetOneInterface interface1);public void ClientAnother(TargetTwoInterface interface2);class Adapter implements TargetOneInterface, TargetTwoInterface { private Adaptee adaptee; // ... adaptee 함수를 활용해 TargetOne/TwoInterface 의 함수들을 모두 구현합니다.} 데코레이터 패턴 - 분장 데코레이터 패턴은 클래스에 추가적인 기능을 무수히 많이 추가하더라도 그 클래스는 본래 클래스의 기능을 유지하는 ‘분장’에 해당합니다. 데코레이터 패턴을 어댑터 패턴 다음에 같이 다루는 이유는 사실 원리는 어댑터-어댑티 개념과 같기 때문입니다. 어댑터가 Adaptee를 TargetInterface로 변장시켰다면, 데코레이터는 Decoratee를 Decoratee 자기 자신으로 분장시키는 꼴이 됩니다. 어댑터 패턴 - 변장: Adaptee != TargetInterface123class Adapter implements TargetInterface { private Adaptee adaptee;} 데코레이터 패턴 - 분장: Decoratee == Decoratee123class Decorator extends Decoratee { private Decoratee decoratee; } 데코레이터 패턴은 한번만 분장하기 위해 사용되지 않습니다. 자기 자신을 재귀적으로 계속 분장할 수 있는데요. 아무리 다양한 DecoratorA, DecoratorB 를 만들어 꾸미더라도 결국에 Decoratee 클래스기 때문에 기존 클라이언트에서는 크게 신경쓰지 않고 쓰던 그대로 사용하면 됩니다. 데코레이터 패턴은 Decorater 클래스가 Decoratee 를 Decoratee 로 분장하는것입니다.Decorator 는 Decoratee 를 상속받기 때문에 그 자신도 Decoratee 가 될 수 있습니다.따라서 Decorator 는 재귀적으로 Decoratee 에 위치할 수 있어 무한정 분장될 수 있습니다. 데코레이티: 꾸미고 싶은 객체 123class Decoratee { // ... } 데코레이터: 꾸며주는 객체 1234class Decorator extends Decoratee { private Decoratee decoratee; // ... decoratee 함수를 활용해 더 개선된 decoratee 함수로 확장합니다.} 단순한 코드는 위와 같지만 아마 책으로 접하신 데코레이터 패턴 코드는 아래와 같은 구조를 갖고 있었을것입니다. 추상 데코레이터: 꾸며주는 추상 객체 123456abstract class Decorator extends Decoratee { protected Decoratee decoratee; Decorator(Decoratee decoratee) { this.decoratee = decoratee }} 구현 데코레이터: 꾸며주는 구현 객체 123456class DecoratorA extends Decorator { DecoratorA(Decoratee decoratee) { super(decoratee) } // ... } 정말 단순한 데코레이팅만 원하신다면 처음에 설명해드린 형태로도 충분합니다. 그렇다 하더라도 위와 같이 추상 데코레이터와 구현 데코레이터를 나누는 걸 추천드리는 이유는 다음과 같은 이점을 갖기 때문입니다. 구현 데코레이터에서 공통으로 필요로하는 로직이나 프로퍼티(특히 데코레이티)를 두고 구현 시 활용 가능합니다. 수많은 구현 데코레이터들을 추상 데코레이터 하나로 관리할 수 있습니다. 구현보다 인터페이스를 사용하라.**던 **디자인 패턴 제 1원칙 기억하시나요? 구현이 아닌 인터페이스(혹은 추상클래스)의 이점은 원하는 구현클래스를 붙였다 떼었다 할 수 있는 유용성과 재사용성이었습니다. 예를 들어 구현 데코레이터들을 하나의 리스트나 셋으로 담아 관리하고싶을때 추상 데코레이터 타입의 리스트, 셋을 생성하여 사용할 수 있겠죠. 퍼사드 패턴 - 묶음마지막으로 배울 패턴은 퍼사드 패턴입니다. 어댑터와 데코레이터 패턴은 각 하나의 어댑티나 데코레이티를 갖는다는 공통점이 있고, 차이점은 **어댑터는 다른 클래스로 ‘변장’**하고 **데코레이터는 같은 데코레이터(사실상 데코레이티)로 ‘분장’**한다는 것 이었습니다. 퍼사드 패턴을 이 챕터에서 다룬다는것은 이들과 공통점이 있다는 것일텐데요. 어떤것이 같을까요? 퍼사드 패턴은 어댑터, 데코레이터 패턴의 공통점을 그대로 갖습니다. 어댑티, 데코레이티와 같이 활용하기 위한 클래스를 내부에 갖고있습니다. 다만 어댑터, 데코레이터가 어댑티, 데코레이티를 하나씩만 가졌다면 퍼사드는 엄청 많은 수의 클래스를 갖습니다. 그리고 어댑터와 데코레이터의 차이점이 ‘변장’이나 ‘분장’이냐의 차이였다면 퍼사드는 그저 그 자체로 새로운 클래스가 됩니다. 어댑터 패턴도 클래스 자신이 아닌 다른 클래스로 ‘변장’한다고 했는데 그럼 퍼사드 패턴도 마찬가지가 아닐까요? 아닙니다. 퍼사드 패턴은 특정 클래스가 다른 특정 클래스로 변장하는것이 아닌 다수의 클래스가 다른 하나의 클래스로 단순히 묶이는 것입니다. (객체) 어댑터1234class Adapter implements TargetInterface { private Adaptee adaptee; // ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.} 퍼사드123456class Facade { private ClassA classA; private ClassB classB; private ClassC classC; // ... ClassA, B, C 를 활용한 새 함수들을 만듭니다.} 퍼사드는 뒤에 어떠한 extends, implements 도 존재하지 않습니다. 단순히 여러 클래스를 묶어주는 하나의 클래스인 셈입니다. 항상 마지막에 가면 집중력이 흐트러지곤 합니다. 중간쯤 읽다보면 세줄요약을 시급하게 찾는 자신을 발견하셨을겁니다. 그래도 꼭 한번은 다 잃고 아래 세줄요약을 읽어주시기 바랍니다. 그래야 머리속에 한번에 들어갈 수 있으니까요. 어댑터 패턴 하나의 클래스(어댑티)를 다른 하나의 클래스(타겟 인터페이스)로 **’변장’**합니다. 1234class Adapter implements TargetInterface { private Adaptee adaptee; // ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.} 데코레이터 패턴 하나의 클래스(데코레이티)를 그 하나의 클래스(데코레이티)로 **’분장’**합니다. 1234class Decorator extends Decoratee { private Decoratee decoratee; // ... decoratee 함수를 활용해 더 개선된 decoratee 함수로 확장합니다.} 위 예제 코드는 이해를 위해 간단한 데코레이터 클래스를 작성했습니다. 본문에서 설명드린바와 같이 추상/구현 데코레이터로 사용하는걸 추천드립니다. 퍼사드 패턴 다수의 클래스를 다른 하나의 클래스로 묶습니다. 123456class Facade { private ClassA classA; private ClassB classB; private ClassC classC; // ... ClassA, B, C 를 활용한 새 함수들을 만듭니다.}","link":"/2019/02/27/adapter-decorator-facade-pattern/"},{"title":"Coroutine, Thread 와의 차이와 그 특징","text":"처음 Kotlin 를 사용하던 중에 비동기 처리를 위해 Coroutine 개념을 마주했었습니다. 동기란 요청을 보낸 후 요청에 대한 반환값을 얻기 이전까지 대기하는걸 의미하고, 비동기는 그 대기시간동안 다른 일을 수행하여 효율성을 높히는걸 의미합니다. 동기와 비동기는 ‘대기’가 필요한 작업들이 빈번한 프로그래밍에 등장하는 개념이고 이를 ‘blocking’으로 명명하여 예로는 OS 시간에 배웠던 I/O 나 Network Request/Response 처리가 있습니다. 과거에는 앞서 말한 예를 처리할때에만 비동기를 사용했던것으로 기억하는데요. 현재에는 어떤 작업이든지 잘게 쪼개어 비동기로 하는 것으로 보입니다. 이런 분위기를 이끌어 온것은 사용이 간편해짐을 들 수 있는데 여기서 설명할 Coroutine 개념도 Thread 보다 비동기 사용이 쉽도록 만들어주었기 때문아닐까 생각이 듭니다. Process &amp; Thread Process: Program 이 메모리에 적재되어 실행되는 인스턴스Thread: Process 내 실행되는 여러 흐름의 단위 먼저 Thread 는 Process 보다 작은 단위의 실행 인스턴스로만 알고 있는데, 메모리 영역도 조금 다릅니다. Process 는 독립된 메모리 영역**(Heap)을 할당받고 각 **Thread도 독립된 메모리 영역**(Stack)**을 할당받습니다. Thread 는 본질적으로 Process 내에 속해있기 때문에 Head 메모리 영역은 해당 Process 에 속한 모든 Thread 들이 공유할 수 있습니다. Program 에 대한 Process 가 생성되면 Heap 영역과 하나의 Thread 와 하나의 Stack 영역을 갖게되고, Thread 가 추가될때마다 그 수만큼의 Stack 이 추가됩니다. Thread 가 100 개라면 전체 메모리에 100 개의 Stask 이 생성되는 것입니다. Concurrency &amp; ParallelismConcurrency 동시성 Interleaving, 시분할: 다수의 Task 가 있는데, 각 Task 들을 평등하게 조금씩 나누어 실행하는것 총 실행시간은 Context Switching 에 대한 비용을 제외하곤 각 Task 수행시간을 합친것과 동일합니다.예를 들어 3 개의 Task 각각이 10분씩 걸린다고 했을때, 총 30분이 소요되는것입니다. Parallelism 병렬성 Parallelizing, 병렬수행: 다수의 Task 가 있는데, 각 Task 들이 한번에 수행되는 것 Task 수 만큼 자원이 필요하며, Context Switching 은 필요없습니다.총 실행시간은 다수의 Tasks 중 가장 소요시간이 긴 Task 만큼 걸립니다.예를 들어 3 개의 Task 각각이 10, 11, 12분씩 걸린다면, 총 12분이 소요되는것입니다. Thread &amp; CoroutineThread, Coroutine 모두 Concurrency 동시성 (Interleaving) 를 보장하기 위한 기술입니다. 여러개의 작업을 동시에 수행할 때 Thread 는 각 작업에 해당하는 메모리 영역을 할당하는데, 여러 작업을 동시에 수행해야하기 때문에 OS 레벨에서 각 작업들을 얼만큼씩 분배하여 수행해야지 효율적일지 Preempting Scheduling 을 필요로 합니다. A 작업 조금 B 작업 조금을 통해 최종적으로 A 작업과 B 작업 모두를 이뤄내는 것입니다. Coroutine 은 Lightweight Thread 라고 불립니다. 이 또한 작업을 효율적으로 분배하여 조금씩 수행하여 완수하는 Concurrency 를 목표로하지만 각 작업에 대해 Thread 를 할당하는 것이 아니라 작은 Object 만을 할당해주고 이 Object 들을 자유자재로 스위칭함으로써 Switching 비용을 최대한 줄였습니다. Thread Task 단위 = Thread 다수의 작업 각각에 Thread 를 할당합니다.각 Thread 는 위에 설명했듯 자체 Stack 메모리 영역을 가지며 JVM Stack 영역을 차지합니다. Context Switching OS Kernel 에 의한 Context Switching 을 통해 Concurrency 를 보장합니다. Blocking: 작업 1(Thread) 이 작업 2(Thread) 의 결과가 나오기까지 기다려야한다면작업 1 Thread 는 Blocking 되어 그 시간동안 해당 자원을 사용하지 못합니다. * 쉬운 설명을 위해 CPU 는 Single Core 로 가정합니다. 위 그림에서 작업들은 모두 Thread 단위인것을 알 수 있습니다. Thread A 에서 작업 1을 수행중에 작업 2가 필요할때 이를 비동기로 호출하게 됩니다. 작업 1은 진행중이던 작업을 멈추고(Blocked) 작업 2는 Thread B 에서 수행되며 이때 CPU 가 연산을 위해 바라보는 메모리 영역을 Thread A 에서 Thread B 로 전환하는 Context Switching 이 일어납니다. 작업 2가 완료되었을때 해당 결과값을 작업 1에 반환하게 되고, 동시에 수행할 작업 3과 작업 4는 각각 Thread C 와 Thread D 에 할당됩니다. 싱글 코어 CPU 는 동시 연산이 불가능하므로 이때에도 OS Kernel 의 Preempting Scheduling 에 의해 각 작업 1, 3, 4 각각을 얼만큼 수행하고 멈추고 다음 작업을 수행할지 결정하여 그에 맞게 세 작업을 돌아가며 실행함으로써 Concurrency 를 보장합니다. Coroutine Task 단위 = Object (Coroutine) 다수의 작업 각각에 Object 를 할당합니다.이 Coroutine Object 는 객체를 담는 JVM Heap 에 적재됩니다. Programmer Switching = No Context Switching 프로그래머의 코딩을 통해 Switching 시점을 마음대로 정함으로써 Concurrency 를 보장합니다. Suspend (Non-Blocking): 작업 1(Object) 이 작업 2(Object) 의 결과가 나오기까지 기다려야한다면작업 1 Object 는 Suspend 되지만 작업 1 을 수행하던 Thread 는 그대로 유효하기 때문에 작업 2 도 작업 1 과 동일한 Thread 에서 실행될 수 있습니다. * 쉬운 설명을 위해 CPU 는 Single Core 로 가정합니다. 작업의 단위는 Coroutine Object 이므로 작업 1 수행중에 비동기 작업 2가 발생하더라도 작업 1을 수행하던 같은 Thread 에서 작업 2를 수행할 수 있으며, 하나의 Thread 에서 다수의 Coroutine Object 들을 수행할 수도 있습니다. 위 그림에 따라 작업 1과 작업 2의 전환에 있어 단일 Thread A 위에서 Coroutine Object 객체들만 교체함으로써 이뤄지기 때문에 OS 레벨의 Context Switching 은 필요없습니다. 한 Thread 에 다수의 Coroutine 을 수행할 수 있음과 Context Switching 이 필요없기 떄문에 Coroutine 을 Lightweight Thread 로도 부릅니다. 다만 위 그림의 Thread A 와 Thread C 의 예처럼 다수의 스레드가 동시에 수행된다면 Concurrency 보장을 위해 두 Threads 간 Context Switching 은 수행되어야합니다. 따라서 Coroutine 을 사용할때에는 No Context Switching 이라는 장점을 최대한 활용하기 위해 다수의 Thread 를 사용하는 것보다 단일 Thread 에서 여러 Coroutine Object 들을 실행하는 것이 좋습니다. 결국 Coroutine 으로 ‘작업’의 단위를 Thread 가 아닌 Object 로 축소하면서작업의 전환 및 다수 작업 수행에 굳이 다수의 Thread 를 필요로 하지 않게됩니다. Coroutine 은 Thread 의 대안이 아니라 기존의 Thread 를 더 잘게 쪼개어 사용하기위한 개념이다.하나의 Thread 가 다수의 코루틴을 수행할 수 있기 때문에 더 이상 작업의 수만큼 Thread 를 양산하며 메모리를 소비할 필요가 없다. 각 스레드마다 갖는 Stack 메모리 영역을 갖지 않기때문에, 스레드 사용시 스레드 개수만큼 Stack 메모리에 따른 메모리 사용공간이 증가하지 않아도 된다. 같은 프로세스내에 ‘공유 데이터 구조’(Heap)에 대한 locking 걱정도 없다. Thread 와 Coroutine 의 예로 보여드린 그림들을 위와 같이 축약해보았습니다. Coroutine 을 사용한다면 Task 가 바뀌어도 Thread 는 그대로 유지되는 것을 볼 수 있습니다. 그에 따라 자연스레 Context Switching 횟수도 확연히 줄어들은것을 볼 수 있습니다. Coroutine 에서 설명드린바와 같이 Task 3 과 Task 4 도 Thread C 가 아닌 Thread A 에서 수행되도록 한다면 하나의 Context Switching 도 없게 설계할 수 있습니다. 즉, Coroutine 이 수행될 Thread 도 프로그래머가 Shared Thread Pool 을 지정하여 결정한다는 의미이며, Coroutine 을 활용한 효율성은 오로지 프로그래머의 몫이라는 의미입니다. 각 언어의 Coroutine Future - Java 비동기 지원 Promise, Generators - JavaScript 비동기 지원 제너레이터는 yield 구문에 의해서만 실행을 멈춥니다. 즉 잘게잘게 쪼개어 (Iterator) 얼려놓았다 (Freeze/Yield) Deferred - Kotlin 비동기 지원 Non Blocking Cancellable ‘Future’(Java) = Coroutine Object Coroutine Builder 인 async { } 를 통해 정의된다. Coroutine 에서 설명했듯이 Deferred 객체를 수행할땐 Thread 를 Blocking 하지 않고해당 구문이 끝날때까지 awaits 하였다 끝나면 계속 이어간다. Stackful &amp; StacklessCoroutine 을 조금 더 깊게 알아보았다면 Stackful 과 Stackless 이 두 종류로 나뉘는것을 볼 수 있다. 본 글의 맨 처음에서 언급했듯이 Thread 는 자체 메모리 영역인 Stack 을 갖는다. Stack 은 함수 실행 순서를 적재하고 그를 관리할 수 있게 해준다. Lightweight Thread 인 Coroutine 의 Stackful &amp; Stackless 는 Coroutine 이 자체 Stack 을 가지는가? 갖지 않는가?**를 의미한다. **Stackful Coroutine 은 Coroutine 내부에서 다른 함수를 호출하였을때 해당 함수에서 현재 Coroutine 을 suspend 할 수 있음 (정확히는 yield 호출을 할 수 있음) 을 의미한다. Stackless Coroutine 은 함수에 대한 Stack 을 따로 갖지 않기 때문에 호출하려는 함수를 다시 한번 Coroutine 객체로 묶어서 ‘Coroutine 중첩 호출’을 해야지 이전 Coroutine 과 내부 Coroutine 을 suspend 를 통해 연결할 수 있다. Coroutine - Stackful Functions Coroutine 내부 함수에서 Yield(Suspending the Coroutine) 호출 가능 Generators - Stackless Functions Coroutine 내부 함수에서 Yield(Suspending the Coroutine) 호출 불가능 예를 들면 Coroutine 내부에 있는 Arrays.forEach() 함수 안 구문에선 forEach() 함수를 코루틴 적용이 가능하게 따로 정의하지 않는한 Yield 호출이 불가능하다. Kotlin CoroutinebuildSequence { } 순차적 Yield/Resuming Yield 를 통해 멈춥니다. Resume 을 통해 순차수행합니다. 123456fun g() = buildSequence { yield(1); yield(2);}for (v in g()) { println(v)} runBlocking { } Main Thread 를 Blocking 한 채 { } 구문 내 작업을 새 Thread 에 할당하여 수행합니다. runBlocking { } 내부에 다수의 async { } 들을 정의하였다면 해당 모든 async 들이 다 수행 완료, 반환되었을때 Main Thread 에 대한 Blocking 을 풉니다. launch { } Main Thread 를 Unblocking 한 채 { } 구문 내 작업을 수행합니다. async { } Main Thread 를 Unblocking 한 채 { } 구문 내 작업을 하고 반환값이 존재합니다. async { } 는 launch { } 와 같은 동작을 하지만 반환값이 존재하는 Deferred 입니다.즉, launch 는 끝까지 실행하면 끝나는거고 async 는 끝까지 실행하고 반환값을 가진 객체를 반환한다. Deferred, which has an await() function that returns the result of the coroutine. 출처: https://stackoverflow.com/questions/1934715/difference-between-a-coroutine-and-a-thread https://stackoverflow.com/questions/43021816/difference-between-thread-and-coroutine-in-kotlin/43232925 https://kotlinlang.org/docs/tutorials/coroutines/coroutines-basic-jvm.html https://medium.com/@jooyunghan/stackful-stackless-%EC%BD%94%EB%A3%A8%ED%8B%B4-4da83b8dd03e","link":"/2019/05/27/coroutine-and-thread/"},{"title":"3. 팩토리 메소드, 추상 팩토리 패턴","text":"디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다. 1. 디자인 패턴에 앞서 2. 디자인 패턴의 제 1, 2 원칙 설명에 사용할 코드는 Java-like Pseudo Code 입니다. 여러 상태에 따른 코드개발을 하다보면 어떤 상태에 따라 다른 플로를 작성해야할 상황이 발생합니다. 단순히 예/아니오 같은 단일 상태라면 if 문을 사용하도록 배웠고, 다중 상태라면 if-else 혹은 switch 를 사용하도록 배웠습니다. 코드는 간단하게는 로직의 나열이라고 볼 수 있는데요. 우리의 실생활에서도 이처럼 다중 상태에 따라 다양한 작업을 수행하곤 합니다. 결국 모든 실생활도 if-else/switch 로 설명이 가능하다는 의미겠지요. if-else 에 “의존한” 처리 라면 종류별 끓이기12345678910111213class RamemMaker { public void makeRamen(String type) { Water water = new Water(100); Ramen ramen; heat(water); if (type == &quot;볶음&quot;) { ramen = 볶음라면; } else if (type == &quot;국물&quot;) { ramen = 국물라면; } water.add(ramen); }} 라면 종류를 상태로 본다면 명시해준 라면 종류 String type 따라서 다른 라면을 끓입니다. 함수 makeRamen(String type) 은 아래와 같이 두 파트로 나눠볼 수 있습니다. 상태: 1.1. 라면 종류를 고르고 처리: 라면을 끓입니다. 상태와 처리라는 두 책임이 하나의 코드에 모여있군요. 1.상태와 2.처리를 한번 떼어내볼까요. if-else 를 “분리한” 처리 라면 끓이기1234567class RamemMaker { public void makeRamen(String type) { Water water = new Water(100); Ramen ramen = ramenGetter.getRamen(type); heat(water); water.add(ramen); } 라면 종류별 생성12345678 public Ramen getRamen(String type) { if (type == &quot;볶음&quot;) { return 볶음라면; } else if (type == &quot;국물&quot;) { return 국물라면; } }} 라면 종류별 생성을 책임지는 상태 함수는 재사용성을 갖게되었고, 상태 책임이 더 명확해 졌습니다. 여기서 함수 getRamen(String type)와 같이 상태에 따라 알맞은 클래스를 만들어서 주입해주는 개념을 팩토리라고 합니다. 팩토리는 if-else/switch 와 같이 상태에 따라 다른 클래스를 생성 및 주입해주는 개념를 의미합니다.즉 **어떤 상태(What)**인지에 따라 **어떻게 처리(How)**할지가 다릅니다. 팩토리 메서드 패턴상태에 따라서 처리를 하기위해 RamemMaker.getRamen 함수 내부에서 if-else 문을 이용하여 분기를 탑니다. 이를 RamemMaker 의 추상 메서드로 만든다면 볶음라면(FriedRamemMaker), 국물라면(StewRamenMaker)에 따라 각각에서 getRamen 를 알맞게 구현하면 됩니다. 기존 if-else 기반 getRamen 을 간단히 팩토리라고 한다면 구현에 따라 달라지는 getRamen 추상 함수를 팩토리 메서드라고 합니다. 라면 생성 + 라면 끓이기123456789abstract class RamemMaker { protected abstract Ramem getRamen(String type); public void makeRamen(String type) { Water water = new Water(100); Ramen ramen = getRamen(type); heat(water); water.add(ramen); }} 라면 종류별(볶음) 생성 + 라면 끓이기123456class FriedRamenMaker extends RamenMaker { @Override public Ramen getRamen(String type) { return new FriedRamen(); }} 팩토리 메서드 패턴은 팩토리 개념을 추상함수를 통해 원하는 구현 클래스를 반환하도록 하는것입니다. if-else + if-else팩토리는 단순히 한 상태에 따른 구현(결과물) 클래스를 생성합니다. 라면은 라면 종류라는 한 상태뿐만 아니라 재료라는 추가 상태로도 세분화될 수 있습니다. 두 개의 상태가 생겼군요. 이를 이차원 상태로 보면 아래와 같이 if-else 문 안에 또 하나의 if-else 문을 갖는 구조로 볼 수 있습니다. 이차원 상태: 라면 업체 + 라면 종류12345678910111213if (type == &quot;볶음&quot;) { if (ingredient == &quot;해물&quot;) { return 해물_볶음라면; } else if (ingredient == &quot;고기&quot;) { return 고기_볶음라면; }} else if (type == &quot;국물&quot;) { if (ingredient == &quot;해물&quot;) { return 해물_국물라면; } else if (ingredient == &quot;고기&quot;) { return 고기_국물라면; }} 같은 볶음라면이지만 어떤 재료를 사용했는지에 따라서도 나눌 수 있는것이죠. 일차원 상태분기는 비교적 쉬웠습니다. 이차원 상태를 고려하도록 확장하려면 아래와 같이 될텐데요. 상태: 1.1. 라면 종류를 고르고 1.2. 재료를 고르고 처리: 라면을 끓입니다. 이번에는 1.상태와 2.처리라는 두 책임뿐 아니라 **두 상태인 1.1.과 1.2.**도 나누어야겠군요. 라면 끓이기1234567class RamemMaker { public void makeRamen(String type) { Water water = new Water(100); Ramen ramen = ramenGetter.getRamen(type); heat(water); water.add(ramen); } 라면 종류별 생성123456789 IngredientFactory ingredientFactory = new MeatIngredientFactory(); public Ramen getRamen(String type) { if (type == &quot;볶음&quot;) { return new FriedRamen(ingredientFactory)); } else if (type == &quot;국물&quot;) { return new StewRamen(ingredientFactory)); } }} 라면에 들어갈 재료1234interface IngredientFactory { public Broth getBroth(); public Flakes getFlakes();} 라면에 들어갈 고기 재료12345678910class MeatIngredientFactory implements IngredientFactory { // 고기 육수 public Broth getBroth() { return new MeatBroth(); } // 고기 건더기 public Flakes getFlakes() { return new MeatFlakes(); }} 라면 종류가 함수 내 if-else 로 분기를 탔다면, 라면에 들어갈 재료는 추상 팩토리를 통해 어떤 재료든지 넣을 수 있도록 하였습니다. 전자를 팩토리 후자를 추상 팩토리라고 합니다. 1) 어떤 종류의 라면인지는 팩토리(RamenGetter.getRamen)**에서 선택하고, **추상 팩토리(IngredientFactory)**의 구상 팩토리를 통해 **2) 특정 재료를 넣어주면 최종 라면 결과물이 나옵니다. 추상 팩토리 패턴처음 팩토리를 배울때 “팩토리 메서드 패턴”과 “추상 팩토리 패턴” 두 패턴의 차이를 이해하는데 꽤나 힘들었습니다. 하지만 **팩토리(Factory)-결과물(Product)**의 개념을 잘 이해한다면 어렵지 않습니다. 1) 팩토리 메서드 패턴은 추상 팩토리 메서드를 각 종류에 따라 구현해서 결과물(Product)을 바로 반환(Return)**했다면,**2) 추상 팩토리 패턴은 추상 팩토리(Interface 혹은 Abstract)에 따라 결과물(Product)을 다르게 **생성(Make &amp; Return)**한다. 1) 팩토리 메서드 패턴: 볶음/국물 결정해서 바로 반환123456class FriedRamenMaker extends RamenMaker { ... public Ramen getRamen(String type) { return new FriedRamen(); }} 2) 추상 팩토리 패턴: 볶음/국물 생성을 위한 재료 추상 클래스를 정의1234567891011class MeatRamenMaker extends RamenMaker { ... IngredientFactory ingredientFactory = new MeatIngredientFactory(); public Ramen getRamen(String type) { if (type == &quot;볶음&quot;) { return new FriedRamen(ingredientFactory)); } else if (type == &quot;국물&quot;) { return new StewRamen(ingredientFactory)); } }} 팩토리 상태에 따라 그에 맞는 **결과물(Product)**를 반환합니다. 팩토리 메서드 패턴 추상 팩토리 메서드를 각 상태에 따라 구현하여 **결과물(Product)**을 바로 반환합니다. 추상 팩토리 패턴 추상 팩토리(Interface 혹은 Abstract)에 따라 결과물(Product)을 다르게 **생성(Make &amp; Return)**한다.","link":"/2019/02/22/factory-method-and-abstract-factory-pattern/"},{"title":"프로페셔널해 보이는 메일 주소 만드는 방법","text":"좋은 메일 주소메일은 내용 및 형식뿐만 아니라 주소에도 예절이 있습니다. 가끔 전화번호에도 외우기 쉬운 전화번호들이 있습니다. 어떤 일에 연락하기 적합한 사람을 찾을때 머릿속에서 가장 쉽고, 먼저 떠오른다면 업무에 있어서나 헤드헌터에 의해 회사와 연결될때 더 많은 성과를 가져갈 수 있겠죠. 우리의 이메일 주소는 대개 아이디에 그 뒤에 네이버나 다음같은 도메인이 붙습니다.문제는 우리가 매우 어린나이에 네이버주니어 같은 서비스를 이용하기 위해 해당 도메인에 가입을 했다는것입니다. 그러다보면 우스꽝스럽거나 어떤 캐릭터 이름 혹은 귀여운 아이디가 대다수입니다. 마치 과거 버디버디 아이디를 들췄을때 부끄러운 그것 말이죠. 부끄러운건 당사자 뿐만이 아닙니다. 그 아이디로 연락을 하는 상대분들은 어떨까요. 외국 대학, 기업뿐아니라 외국인과 같이 커뮤니케이션을 하고싶다면 위와 같은 과거의 주소는 지양하는것이 좋습니다. 계속 써왔던 메일이라 새 메일주소를 생성하는것이 불편하시다면 __메일 포워딩__을 사용하시길 권장합니다. 추천 이메일일반적으로 다음과 같은 규칙을 갖기를 추천합니다. 핵심은 기억하기 쉬운 이메일 입니다.각 규칙에 들어가는 단어들은 첫글자나 약어로 하셔도 좋습니다만 되도록이면 온전한 단어로 쓰시는것이 기억하기 좋습니다. First Name 이름 First Name 이름 + Last Name 성 Generic : 메일 수신 목적에 맞는 이름 예는 다음과 같습니다. aaron@domain.com aaronryu@domain.com contact@domain.com 만약 Gmail 을 사용하신다면 다음과 같은 좋은 기능^1을 제공해주니 활용하시는것이 좋습니다. . : 마음껏 점을 찍어서 가독성을 높힐 수 있습니다. 점을 찍지않은 본래의 메일로 자동 포워딩됩니다. aaron.ryu@domain.com + : 받을때 특정 필터를 적용한 채로 메일을 수신할 수 있습니다. 이 또한 본래의 메일로 자동 포워딩됩니다. 이력서에 명시한 메일은 aaron.ryu+recruit 이라면 recruit 필터 규칙에 걸러집니다. aaron.ryu+recruit@domain.com 중복 이메일개인적으로 지메일에서 메일을 생성하려하니 중복된 주소가 이미 생성되어있었습니다.그럴때에는 각 아이디나 메일 입력 폼에 숫자를 붙이거나 성과 이름의 방향을 바꿔 추천해줍니다만 사용하지 않는것이 좋습니다. 외국인들은 이름 내 순서를 이름 + 성 으로 사용하기때문에 그 규칙을 그대로 따르는것이 좋습니다. 그렇지 않다면 외국인이 “성” 으로 저를 부를지도 모릅니다.생년을 적는다면 특히 나이에 대해 동양만큼 민감하지 않은 외국인들에게 그 사람을 떠올렸을때 몇년에 태어났는지까지 기억해야하는 불필요한 정보를 제공하게 됩니다. 이럴땐 어떻게 하는것이 좋을까요.쉽게는 직무를 명시할 수 있겠고, 번거롭게는 하나의 도메인을 생성하는것도 좋습니다. aaron.ryu.dev@domain.com = aaronryudev@domain.com aaronryu@aaronryu.com 아이디뿐만 아니라 도메인에도 자신의 이름이 중복으로 들어가서 언프로페셔널하게 느껴질것이 걱정되신다면 걱정하지 않으셔도 될 것 같습니다. 오히려 자신만의 도메인이 있다는것과 메일 시 직접 그 사람과 이야기한다는 느낌을 줄 수 있을 것입니다.^2 1: http://consultantjournal.com/blog/professional-email-address-ideas-for-common-names2: https://yeonlab.com/check-your-email-address/3: https://workplace.stackexchange.com/questions/11731/what-should-a-professional-email-address-look-like","link":"/2019/02/17/how-do-i-make-email-address/"},{"title":"VSCode 에서 Hexo 디버깅 하는 방법","text":"Hexo 테마 커스터마이징hexo 에서 원하는 테마를 선택하더라도 수정하고 싶은 부분들이 있을 수 있습니다. 아무리 테마에서 yaml 기반의 config 를 제공한다고 하더라도, 더 세밀한 부분까지 원하는대로 바꾸고싶다면 테마 코드를 직접 수정해야합니다. Hexo 설치형 블로그를 시작하면서 제가 선택했던 Icarus 테마는 크게 두가지 타입의 코드로 나뉘어져있습니다. .styl : bulma 를 기반으로한 CSS 설정들이 있습니다. .jsx : .md 로 작성한 글들을 페이지에 어떻게 렌더링할지 정의되어있습니다. .styl 커스터마이징너비, 높이, 폰트사이즈, 색깔등의 설정은 .styl 코드에서 설정하면 되며, 브라우저에서 페이지 각 요소의 CSS 설정들을 분석하여 그에 해당하는 설정이 있다면 값을 수정하고, 없다면 bulma 의 설정을 그대로 사용하는것이므로 오버라이딩을 위해 원하는 설정을 추가해줍니다. .jsx 커스터마이징글이나 위젯을 페이지에 렌더링 하는 부분은 .jsx 코드에서 설정하면됩니다. 화면에 어떻게 렌더링되는지, 내가 수정한 코드가 제대로 동작하는지 알기위해 디버깅을 필요로합니다. hexo 블로그 운영은 VSCode 를 통해 하고있어서 VSCode 에서 hexo 를 디버깅하고 있습니다. 디버깅 설정VSCode 의 디버깅 설정은 디버깅 창에서 RUN 우측 디버깅 리스트에서 Add Configuration... 를 통해 가능합니다. Add Configuration... 선택하게되면 현재 프로젝트 디렉토리에서 .vscode 라는 디렉토리 한개와 그 안에 launch.json 파일 하나를 생성하고, 해당 파일로 이동하여 어떤 설정을 추가할지 아래와 같이 리스트를 보여줍니다. 리스트에서 Node.js: Launch Program을 선택하면 설정이 한개 추가되는데, 아래와 같이 수정 입력하면 됩니다. launch.json1234567891011121314{ &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Hexo Debugging&quot;, &quot;program&quot;: &quot;${workspaceFolder}/node_modules/hexo-cli/bin/hexo&quot;, &quot;args&quot;: [ &quot;server&quot; ] } ]} 로컬에 살행한 hexo server 에 대한 디버깅이기 때문에 타켓 프로그램은 hexo-cli 의 bin/hexo 이며, args 에 server 가 들어가는것을 보실 수 있습니다. 이제 디버깅을 하면서 즐겁게 나만의 커스텀 테마를 만드시면 됩니다. 더 나아가서 그렇게 만든 나만의 테마를 사람들과 공유할수도, 이미 있는 테마에 git contributor 로 확장된 기능을 추가할수도 있을것입니다. https://gary5496.github.io/2018/03/nodejs-debugging/ https://stackoverflow.com/questions/57125171/how-to-debug-inspect-hexo-blog","link":"/2021/02/07/how-to-debug-hexo-using-vscode/"},{"title":"Hexo, Icarus 새 버전으로 마이그레이션 및 커스터마이징","text":"21년 첫 블로그 글 발행시 오류업무를 하면서 정말 많은 것들을 경험하고, 배우지만 정작 시간을 내서 정리하여 어딘가에 작성해놓으지 않으면 기억이나지 않더군요. 사내 위키를 잘 활용했었는데, 아무래도 더 많은 분들과 정보 및 의견을 공유하고 싶어서 블로그에 다시 글을 올리려했습니다. 얼마전에 겪었던 이슈에 관련된 글을 hexo 로 작성하여 hexo g -d 를 통해 발행하려하니 갑자기 오류가 발생했습니다. 12TypeError [ERR_INVALID_ARG_TYPE]: The &quot;mode&quot; argument must be integer.Received an instance of Object at copyFile 구글링을 해보니 node 버전을 Downgrade 하여야하며, 현재 hexo 5.0.0 버전 이후로 픽스되었다는 스레드^1를 찾았습니다. 생각해보니 작년말에 개발 공부를 위해 라이브러리나 프레임워크 버전들을 일괄적으로 다 올렸었습니다. 그중에 node.js 가 15 버전으로 업데이트 되어있었습니다. node.js 최신 버전을 아무래도 글로벌로 업데이트하였어서 hexo 에서 npm 동작시 충돌이 일어나는것같습니다. Hexo 최신 버전 마이그레이션사용중이던 버전은 Hexo 3.8.0 / Icarus 2.3.0 인데 확인해본 최신 버전은 Hexo 5.3.0 / Icarus 4.1.1 이었습니다. Hexo 먼저 버전업을 위해서 package.json 에 기존 패키지들을 모두 지우고 hexo 버전을 5.3.0 버전으로 바꾸었습니다. npm install 수행 후 깨지는 패키지들을 일일히 넣어주기 귀찮아서, 새 디렉토리에서 hexo init 하여 자동 생성된 package.json 을 참조했습니다. 최신 Hexo 와 구 Icarus 충돌hexo 버전 업데이트 후 hexo server 로 로컬에 페이지를 띄워보니 icarus 테마 파일에서 계속해서 특정 변수를 찾을 수 없음 등의 오류가 발생하였습니다. 구글링하니 이 또한 버전문제로 파악되어 기존의 icarus 테마의 커스터마이징 설정 _config.yml 만을 백업한 채 모두 지우고 icarus 를 최신버전으로 (1) npm install 이 아닌 (2) git submodule 을 통해 (커스터마이징을 위해) 설치하였습니다. 다시 실행하니 jsx 코드만 덩그러니 노출되는 문제가 발생하였는데 jsx 라서 react.js 인줄알았더니 inferno.js 로 개발되어있어서 해당 라이브러리를 설치하여 해결하었습니다. Icarus JSX 커스터마이징어떤 테마든 수정을 해야하는 깐깐한 성격탓에 예전 icarus 테마는 ejs 코드를 분석해서 커스터마이징을 따로 하였었습니다. 예전엔 ejs-based 였던 icarus 가 이젠 jsx-based 로 되어서, 이전 커스터마이징 코드를 그대로 사용할 순 없고, 또 다시 분석해서 수정해야했습니다. 프론트 개발을 쭉 react.js 로 해왔었고 icarus 개발 프레임워크인 inferno.js 도 react-like 를 표방하는만큼 디버깅만 할 줄 알면 크게 어렵진 않을것같았고, 실제로도 그랬습니다. 다만, icarus 프로젝트가 jsx 로 변환되면서 과거에 난잡했던 ejs 구조에서 컴포넌트 단위로 모듈화가 잘되어졌기 때문에 페이지마다 렌더링을 다르게해야하는 부분은 공통 컴포넌트에 예외 조건을 넣는 방식으로 처리해야했습니다. 아래 커스터마이징한 코드들을 보시면 이해가 되실겁니다. VSCode 를 통한 Hexo 디버깅테마를 수정하기 위해서는 가장 먼저 hexo, icarus jsx 들이 페이지로 어떻게 렌더링 되는지 알아야합니다. 로컬에서 hexo 테스트를 위해 실행하는 hexo server 명령어는 hexo-cli 에 정의되어있는 npm 스크립트를 실행한것입니다. 테마 설정을 바꾸거나 글을 수정하면 바로 로컬 페이지에 적용이되는데 이는 npm 를 통해 동적으로 렌더링하고 있기 때문입니다. 저는 icarus 테마가 어떻게 동작하는지 이해하고, 수정한 제 코드가 제대로 동작하는지 확인하기 위해 VSCode 를 통해 디버그를 진행하였습니다. VSCode 에서 디버깅하는 방법은 해당 글 VSCode 에서 Hexo 디버깅 하는 방법에서 잘 설명해놓았으니 참고하시면 됩니다. 네비게이션바 로고제일 상단의 네비게이션바에 기본적으로는 로고 이미지를 올리도록 설정되어있지만, 해당 블로그를 표현할 수 있는 단어로 치환 및 폰트 사이즈를 설정하였습니다. _config.icarus.yml123# Path or URL to the website's logologo: text: Crucian Carp include/style/navbar.styl1234.navbar-logo img max-height: $logo-height font-size: 1.4rem 좌측 위젯 - 프로필 재설정본 블로그에서는 웹 검색에 이점을 버리더라도 글의 구성을 제일 심플하게 하고싶었기 때문에 Tag 를 모두 사용하지 않습니다. 좌측 위젯에 프로필에서 Post 개수와 Category 개수만 보여주도록 Tag 개수는 표기하지 않도록 코드를 삭제하였습니다. layout/widget/profile.jsx (아래 코드 모두 삭제)12345678&lt;div class=&quot;level-item has-text-centered is-marginless&quot;&gt; &lt;div&gt; &lt;p class=&quot;heading&quot;&gt;{counter.tag.title}&lt;/p&gt; &lt;a href={counter.tag.url}&gt; &lt;p class=&quot;title&quot;&gt;{counter.tag.count}&lt;/p&gt; &lt;/a&gt; &lt;/div&gt;&lt;/div&gt; layout/widget/profile.jsx (아래 코드 모두 삭제)12345tag: { count: tagCount, title: _p('common.tag', tagCount), url: url_for('/tags')} 포스트 상단 시간포맷 변경icarus 테마는 기본적으로 포스트 상단에 글 최초 작성 이후 얼마나 지났는지, 업데이트 후 얼마나 지났는지 표기해주는데, 개인적으로는 과거 네이버같은 WYSIWYG 블로그에서 표기해주는 포스트 최초 작성일을 날짜 형태로 보는것을 선호해서 이 또한 바꿔주었습니다. layout/common/article.jsx (time 을 div 로 변경 및 Update Date 삭제)1234567&lt;div class=&quot;level-left&quot;&gt; {/* Creation Date */} {page.date &amp;&amp; &lt;span class=&quot;level-item&quot; dangerouslySetInnerHTML={{ __html: _p(`&lt;div&gt;${date(page.date)}&lt;/div&gt;`) }}&gt;&lt;/span&gt;} {/* author */} {page.author ? &lt;span class=&quot;level-item&quot;&gt; {page.author} &lt;/span&gt; : null} 폰트 변경폰트는 hexo 블로그 처음 시작할때 글들을 모두 한글로 작성할것이라 자간 간격이 아주 조금은 벌어져있는것이 가독성이 좋다고 판단하여 hexo 사용 처음부터 사용해왔던 나눔고딕 폰트를 계속 사용하기로 했습니다. include/style/base.styl ('Nanum Gothic' 폰트 추가 및 기존 미사용 폰트 삭제)12$family-sans-serif ?= 'Ubuntu', 'Nanum Gothic', sans-serif$family-code ?= 'Source Code Pro', monospace, 'Microsoft YaHei' 위젯 &amp; 포스트 너비 재설정icarus 에서 제공하는 위젯은 (1) 우측, (2) 좌측이 있는데 이 둘을 모두 사용하면 중간에 포스트 너비가 짧아져 가독성을 떨어트릴수있다고 판단했습니다. 좌측 위젯만 사용했음에도 위젯 너비가 포스트 너비에 비해 길다고 생각하여 조율해주었습니다. 4(좌측 위젯) + 8(글) = 12 3(좌측 위젯) + 9(글) = 12 icarus 의 너비 분배는 bulma css 12 셀 규칙을 사용합니다. 기존엔 아래와 같았습니다. 4(좌측 위젯) + 8(글) = 12 8(글) + 4(우측 위젯) = 12 3(좌측 위젯) + 6(글) + 3(우측 위젯) = 12 여기서 본 블로그는 위젯을 포스트의 가독성을 위해 좌측 하나만 사용할것이기 때문에 3(좌측 위젯) + 9(글) = 12 9(글) + 3(우측 위젯) = 12 포스트의 너비는 8에서 9으로 위젯은 4에서 3으로 재정의하였습니다. layout/common/widgets.jsx (위젯 하나의 너비 4 -> 3)123456789function getColumnSizeClass(columnCount) { switch (columnCount) { case 2: return 'is-3-tablet is-3-desktop is-3-widescreen'; case 3: return 'is-3-tablet is-3-desktop is-2-widescreen'; } return '';} layout/layout.js (포스트 너비 8 -> 9)123456789101112&lt;div class=&quot;columns&quot;&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-9-tablet is-9-desktop is-9-widescreen': columnCount === 2, 'is-9-tablet is-9-desktop is-8-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'right'} /&gt;&lt;/div&gt; About 내 위젯, 플러그인 제거상단 네비게이션바에서 About 을 클릭하시면 저에 대한 개략적인 정보를 아실수있습니다. 또한 개인 Resume 페이지를 따로 만들어서 굳이 Google docs 나 Linkedin 으로 접속하지 않아도 저의 이력을 한눈에 볼 수 있도록 Resume 페이지도 따로 마련해두었습니다. 구 icarus 의 ejs 시절에는 About, Resume 페이지 모두 각각 따로 ejs 페이지가 있었기때문에 해당 페이지만 수정하면 되었었지만, 새 icarus 의 jsx 에서는 포스트에 대한 컴포넌트가 about, resume 등 모든 페이지의 기본 컴포넌트로 사용되고있었습니다. 정적 리스트를 만들어서 특정 페이지에 대해서만 위젯과 플러그인을 표시하지 않도록 필터링 하는 로직을 넣었습니다. 위젯도 위젯이지만 buy me a coffee 가 킬링포인트입니다. About 페이지는 저를 표현하는것만으로 충분합니다. layout/layout.jsx (About, Resume 여부 조건)1const isAboutPage = [ &quot;about/index.html&quot;, &quot;resume/index.html&quot; ].includes(page.path); layout/layout.jsx (좌측, 우측 위젯에 About, Resume 여부 조건 추가)12345678910111213141516&lt;Head site={site} config={config} helper={helper} page={page} /&gt;&lt;body class={`is-${columnCount}-column`}&gt; &lt;Navbar config={config} helper={helper} page={page} /&gt; &lt;section class=&quot;section&quot;&gt; &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;columns&quot;&gt; &lt;div class={classname({ column: true, 'order-2': true, 'column-main': true, 'is-12': columnCount === 1, 'is-9-tablet is-9-desktop is-9-widescreen': columnCount === 2, 'is-9-tablet is-9-desktop is-8-widescreen': columnCount === 3 })} dangerouslySetInnerHTML={{ __html: body }}&gt;&lt;/div&gt; {!isAboutPage &amp;&amp; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'left'} /&gt;} {!isAboutPage &amp;&amp; &lt;Widgets site={site} config={config} helper={helper} page={page} position={'right'} /&gt;} layout/common/article.jsx (About, Resume 여부 조건)1const isAboutPage = [ &quot;about/index.html&quot;, &quot;resume/index.html&quot; ].includes(page.path); layout/common/article.jsx (포스트 하단 모든 플러그인에 About, Resume 여부 조건 추가)1234567891011121314151617181920212223242526{/* Licensing block */}{!isAboutPage &amp;&amp; !index &amp;&amp; article &amp;&amp; article.licenses &amp;&amp; Object.keys(article.licenses) ? &lt;ArticleLicensing.Cacheable page={page} config={config} helper={helper} /&gt; : null}{/* Tags */}{!isAboutPage &amp;&amp; !index &amp;&amp; page.tags &amp;&amp; page.tags.length ? &lt;div class=&quot;article-tags is-size-7 mb-4&quot;&gt; &lt;span class=&quot;mr-2&quot;&gt;#&lt;/span&gt; {page.tags.map(tag =&gt; { return &lt;a class=&quot;link-muted mr-2&quot; rel=&quot;tag&quot; href={url_for(tag.path)}&gt;{tag.name}&lt;/a&gt;; })}&lt;/div&gt; : null}{/* &quot;Read more&quot; button */}{!isAboutPage &amp;&amp; index &amp;&amp; page.excerpt ? &lt;a class=&quot;article-more button is-small is-size-7&quot; href={`${url_for(page.link || page.path)}#more`}&gt;{__('article.more')}&lt;/a&gt; : null}{/* Share button */}{!isAboutPage &amp;&amp; !index ? &lt;Share config={config} page={page} helper={helper} /&gt; : null}{/* Donate button */}{!isAboutPage &amp;&amp; !index ? &lt;Donates config={config} helper={helper} /&gt; : null}{/* Post navigation */}{!isAboutPage &amp;&amp; !index &amp;&amp; (page.prev || page.next) ? &lt;nav class=&quot;post-navigation mt-4 level is-mobile&quot;&gt;{/* Comment */}{!isAboutPage &amp;&amp; !index ? &lt;Comment config={config} page={page} helper={helper} /&gt; : null} 지금 보고 계신 이 블로그와 본 포스트는 위 요소들을 모두 커스터마이징한 Icarus 테마로 구성된것입니다. 몇년전에 hexo 나 icarus 를 적용하셨었고, 마이그레이션을 앞두고 계시거나 커스텀하게 수정하는걸 원하시는 분께 본 글이 도움이 되셨으면 좋겠습니다. 이후로 CSS, JSX 에 자잘한 수정이 있을순 있으나 따로 다 업데이트하진 않으려합니다.","link":"/2021/02/02/how-to-migrate-hexo-and-icarus-to-the-newest-version/"},{"title":"개발 일지 - iOS 아키텍쳐 패턴 MVC, MVVM, VIPER","text":"iOS 는 어떻게 보면 웹 어플리케이션 개발과 거의 유사하다고 생각됩니다. 다만 .NET WebForm 처럼 View 와 Controller 가 강결합 되어있어서, React.js 렌더링(프론트) 로직과 View 데이터를 전달해주는 Controller 를 따로 생각할 수 없습니다. 처음 스위프트 앱을 만들때 앱도 결국 웹 페이지와 거의 유사한 모델이기 때문에 웹 어플리케이션 개발 방식 그대로 개발하려했습니다. MVC 와 MVVM 에 대한 작은 경험을 그대로 적용해보았습니다. MVC / MVVM기존 웹 어플리케이션을 만들때 서버에서는 Controller, Application, Service, Repository 순으로 분류하여 작업했습니다. HTML, Javascript 는 View 에, JPA 같은 데이터 레벨은 Model 에, Model 을 활용한 모든 비지니스 로직과 View 와 POST/GET 통신으로 이벤트를 주고받는 중간 레이어는 Controller 에 해당합니다. 웹 어플리케이션에서 MVC 의 Controller 는 사실상 View Model 에 해당합니다. View 를 그려주는것이 아니라 View 를 그릴 수 있는 View Model 을 전달해주고 이를 처리하는건 클라이언트 엔진위인 Single Page 니까요. 이름만 들어도 알만한 프론트엔드 프레임워크인 .js 류들이 이런 패턴을 사용합니다. iOS - Massive Controller ? (Actually It’s ‘View’ not a Controller)MVVM 패턴을 그대로 적용하려니 iOS 에서 에러가 발생합니다. 문제의 핵심은 View.storyboard 와 ViewController.swift 가 사실상 하나의 View 라는겁니다. 일반적으로 프론트엔드와 백엔드의 코드 베이스가 JS, Java 등으로 나뉘는것과 달리 iOS Swift 는 View 를 모두 .swift 에서 처리합니다. ViewController.swift 가 Controller 라는 이름을 갖고있지만 사실상 View 에 해당하고 View.storyboard 는 CSS/HTML 및 Router 가 포함된 개념으로 볼 수 있습니다. 스위프트는 본질적으론 MVC 패턴입니다. 다만 언어의 특성상 웹 어플리케이션의 MVC 와는 조금 구별해야하는것 처럼 보입니다. Controller 가 사실상 View 에 해당하는것이기 때문에 렌더에 해당하는 로직을 Controller 가 갖습니다. Service, Repository 모듈화를 잘한다해도 Controller 에는 View 렌더 로직뿐만 아니라, View 렌더에 필요한 데이터 조작에 대한 ‘일부’ 비지니스 로직도 포함하게 됩니다. 이 문제를 Massive Controller 라고 칭합니다. 첫 개발 - MVCMVC 를 그대로 적용해본 제 첫 Swift 코드는 아래와 같았습니다. Bar 같은 여러 Asset 에 그려줄 데이터(Model)들을 받아와서 통계 데이터를 만들고(비지니스 로직) 그걸 View 에 주입해서 그려주었죠(View). 물론 보시는것과 같이 간단한 UIView 임에도 View 를 그리는 로직뿐만 아니라 View Model 에 대한 로직을 보실 수 있습니다. 리팩토링 - MVVMController 가 커지면 무의식적으로 불안감이 발생합니다. 코드를 작성하면서 이건 정말 아닌것같은 느낌을 많이 받으며 리팩토링을 수행했습니다. 사실상 View 의 의미를 갖는 Controller 아래에 진정한 의미의(…) Controller인 View Model 을 두는 것입니다. 모양, 색깔, 크기에 해당하는건 ViewController 에 두고 이에 필요한 ViewModel 은 ViewModelController 가 제공하는것입니다. 아래 예를 보면 ViewController 에서 ViewModel 인 mockBudgets 만을 잘 사용하고 있습니다. View(Controller)와 ViewModel(Controller) 바인딩 시 Rx 를 사용한다고 하는데 아직 이것까진 적용해보지 못했습니다. 최근 - VIPER그러다 개인 프로젝트이기에 시간 날때마다 작업을 하니 제가 짠 코드도 몇일 몇주가 지나서 보면 너무 새로운 겁니다. 매번 개발을 진행할때, 더 진척이 생길때마다 코드를 다시 읽고 이해하는 시간이 길어졌고, 이건 코드들이 각 구체적이고 명확한 역할을 가지지도 않는다는걸로 이해됐습니다. 물론 Service, Repository 레벨의 코드들은 정리가 잘되어있어서 문제가 없었지만 View 는 아무리 적응하려해도 힘들더군요. 심지어 저는 Swift 를 처음 공부하면서 첫 어플리케이션을 만들고 있는것이니까요. VIPERVIPER 는 사실 View Model 의 이중화라고 보면 됩니다. 기존 비지니스 로직을 View 와 연관된 비지니스 로직, Model 데이터 레벨에 가까운 비지니스 로직 및 로깅, 네트워크 인스턴스 관리 이렇게 둘로 세분화한것으로 이해하면 쉽습니다. 전자를 Presentator 후자를 Interactor 라고 부릅니다. 그렇게 3개에서 4개의 컴포넌트가 되었습니다. 거기에 ViewController 간 화면 전환과 같은 segue 처리를 맡는 Router 가 추가되어 총 5개가 됩니다. 제 기존 코드에서 Model 은 이미 잘 정리되어있었기 때문에 이 부분은 Entity 와 Interactor 로 이미 분리되어 있었습니다. ViewModel 에도 최대한 Model 에 대한 로직은 넣지 않았으니까요. 기존 ViewController 에 몰려있던 View 에 대한 관련 비지니스 로직들을 Presentator 로 이관을 해보니 기존 View 에 View Model 로직들이 너무 많았었구나 싶었습니다. 또한 화면 전환(segue) 처리도 기존 ViewController 가 갖고있었는데 사실 이건 메타적으로 생각해보면 ViewController 간 이동을 조율하는것이므로 상위 레벨의 컴포넌트가 관리하는게 맞았습니다. segue 이동에 대해 매 ViewController 마다 중복해 갖는 보일러플레이트 코드들을 어떻게 중앙처리할까 했더니 VIPER 의 Router 를 사용하면 되는것이었습니다. 이렇게 적용을 해보았는데 컴포넌트가 5개이다 보니 기반 코드가 너무 많습니다. 귀찮았지만 앞으로의 생산성을 위해 적용해봤는데요. 효과는 아직 모르겠습니다. ReSwift(Redux on Swift) 개념도 있는듯한데 React.js 를 짧게 사용해보면서 컴포넌트들이 해봐야 고작 1, 2 레이어여서 굳이 Redux 를 적용할 필요가 없었기 때문에 배워보지 못했습니다. 이건 추후에 적용해보는걸로 해야겠습니다. 아무래도 새로운 아키텍쳐 패턴이나 요즘 핫하다는걸 적용해보면 좋겠지만 아무리 개인 개발이라도 빨리 배포를 하는게 더 중요하겠지요.","link":"/2019/06/29/ios-design-patterns/"},{"title":"5. 옵저버 패턴","text":"디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다. 1. 디자인 패턴에 앞서 2. 디자인 패턴의 제 1, 2 원칙 설명에 사용할 코드는 Java-like Pseudo Code 입니다. 변수프로그래밍을 처음 배울때 우리는 먼저 변수에 대해 배웁니다.변하지 않는 값은 Constant 상수라고 부르며, Variable 변수의 값은 수시로 변합니다.변수는 수시로 변할 수 있기 때문에 말 그대로 프로그램 내내 산전수전을 다 겪습니다. 상태변수는 위에서 언급한대로 정말 다양한 상태를 갖습니다. 이러한 변수의 상태를 알기 위해서는 두 가지 방법이 있습니다. Push 방식 자동: 변수가 자신이 상태가 바뀌었음을 우리에게 알려줍니다. Pull 방식 수동: 우리가 변수가 상태가 바뀌었는지를 직접 알아봅니다. 자동으로 우리에게 알려주는게 가장 편해보일 수도 있겠지만 굳이 알 필요가 없는데 계속해서 자신의 상태에 대해 말해준다면 매우 귀찮겠지요. 그 상태를 계속 추적하기 위한 자원도 불필요하게 낭비될것입니다. 그럴때는 우리가 필요할때만 상태를 볼 수 있는 수동의 방법도 필요합니다. 이를 조금 고지식하게 Push 와 Pull 방식으로 이야기합니다. 변수의 상태를 하나의 ‘주제’라고 본다면 주제를 중심으로 우리에게 알려주는지(Push) 아니면 **우리가 알아보는지(Pull)**에 따라 상태를 알 수 있는 방법이 나뉘는것입니다. 옵저버 패턴 옵저버 패턴은 변수의 상태를 Push 와 Pull 중 원하는 방식을 통해 알 수 있는 패턴입니다. 일반적으로 이 패턴을 설명할때 상태를 ‘주제’라 보고 Publish-Subscribe(발행-구독) 모델로 설명하곤합니다. 여기선 패턴 이름이 옵저버 패턴인 만큼 헷갈리지 않게 구독모델이 아닌 Observer와 Observable 두 가지 용어로만 설명을 드리겠습니다. 옵저버 패턴에는 앞서 말씀드린 딱 두 종류의 인터페이스만 존재합니다. 하나는 상태를 갖고있는 옵저버블, 나머지 하나는 상태를 보려하는 옵저버입니다. Observable위 옵저버 패턴 그림을 보시면 옵저버블 인터페이스는 두 가지 정보를 ‘구성’(has)합니다. 상태 (State) 옵저버 리스트 (Observers) 오해를 해서는 안되는 점이 옵저버블 인터페이스는 상태 자체가 아니라 상태를 ‘갖고 있다’**는 것입니다. 상태를 갖고있다는 의미로 옵저버블, 즉 **옵저버는 이 인터페이스를 통해 상태를 ‘볼 수 있다’**는 의미인것입니다. 그리고 옵저버블은 상태를 알려주거나/알아보려는 옵저버들을 리스트(물론 다른 자료구조형도 가능합니다)로 관리하여 **Push 방식의 경우에는 상태를 누구에게 보내줄지? 그리고 Pull 방식의 경우에는 상태를 누구만 볼 수 있는지? 결정할 수 있습니다. 옵저버블 인터페이스123456interface Observable { protected List&lt;Observer&gt; observers; public void registerObserver(Observer o); public void removeObserver(Observer o); public void notifyObserver(Object obj);} 옵저버블 구현123456class StateObservable implements Observable { private State state; public void changeState() { /* 상태가 변경됩니다. */ } public void registerObserver(Observer o) { /* 옵저버 제외 */ } public void removeObserver(Observer o) { /* 옵저버 추가 */ } notifyObserver 구현 - 1) Push 방식12 public void notifyObserver(State state) { /* 2. 옵저버 리스트의 각 옵저버들에게 1. 상태를 전송 */ }} notifyObserver 구현 - 2) Pull 방식123 public void notifyObserver() { /* 아무것도 하지 않습니다. */ null } public State getState() { /* 상태를 보고싶으면 옵저버가 이 함수를 호출하면 됩니다. */ return state; }} Observer 옵저버는 길게 설명할 것 없이 상태를 보고자 하는 인터페이스입니다. 인터페이스인 만큼 해당 정보를 보고, 활용하고싶다면 의도에 맞게 원하는 방식대로 구현하여 사용하시면 됩니다. 옵저버 인터페이스1234interface Observer { protected Observable observable; public void getStateFromObservable();} 옵저버 구현1234567891011class StateObserver implements Observer { private State state; public StateObserver(Observable observable) { this.observable = observable; this.observable.registerObserver(this); } public void update(state) { this.state = state; }} 왜 StateObserver 를 Observable.getObservers().add(new StateObserver()) 방식으로 추가하지 않고 StateObserver 객체를 생성할때 Observable 를 넣어줌으로써 생성자 안에서 추가를 해주었을까요? Observable.getObservers()를 호출하지 않음으로써 옵저버 리스트를 옵저버블 외부에 절대 노출하지 않습니다. 옵저버 패턴을 왜 굳이 패턴으로 정의했을까요? 저렇게 복잡하게 할 필요까진 없을텐데요. 옵저버블과 옵저버 두 인터페이스가 서로의 구현에 대해서 전혀 알 필요없이 데이터만을 주고 받는데 의의가 있습니다. 좀 더 풀어쓰자면 아래와 같습니다. 옵저버블이 갖는 1. 상태와 2. 옵저버 테이블 모두 외부에 노출하지 않은채 오로지 옵저버들만 알게끔하는 것이죠.**”서로 상호작용을 하는 객체 사이에는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.”**는 원칙입니다. 잘 이해가 되셨는지요. 오늘의 디자인 패턴은 여기서 마치도록 하겠습니다.","link":"/2019/02/27/observer-pattern/"},{"title":"한 장으로 보는 정규표현식","text":"중요성개인적으로 좋아했던 구글 Tech Lead 유튜버가 개발자라면 당연히 알아야할 몇가지 스킬을 업로드^1한적이 있다. Regular expressions SQL Debugging Skills (problem solving). Tooling language Anti-Social skill 이 중 오늘의 주제는 가장 첫번째에 언급된 정규표현식이다. 중간에 5번이라는 스파이가 있는듯 한데 개발자는 사실상 코딩보단 말을 많이하는 직업이라 생각해서 그리 좋은 전략은 아닌듯하다. 정규표현식은 학사때도 나중에 공부해야지 하고 메모는 많이 해놓았는데 정작 제대로 외우진 않고 매번 필요할때마다 찾아 쓴듯하다. 최근에 정리하였는데 나름 문법처럼 분류해서 외우면 쉽다. 사실 Regex 는 Tech Lead 말대로 개발하는데 너무 널리 사용된다. 텍스트 검색, 정확히는 패턴 매칭에 사용되는데 검색이라면 아래같이 수많은 유즈케이스들이 있다. grep 을 통한 로그/텍스트 분석 개발하고 있는 코드/디렉토리 검색 commit 이전 코드 체킹 웹 크롤링 URL 파싱 값/포맷 validation 개요Regex 는 처음보았을때나 공부하기 전까지는 암호내지 외계어처럼 보이긴 한다. 우리가 흔히 접하는 언어는 semantic 이 word 혹은 그 조합으로 표현되지만, semantic 들이 각각 하나의 charactor 에 매핑되어있는건 암호체계와 동일하기 때문이다. 이것도 syntax 로 분류하면 아래와 같이 나뉘어지는데, 정규표현식을 익히는데 많은 도움이 된다. 기본적으로 특정 단어를 검색하기 위해 정규표현식을 사용하는데, 단순히 찾고싶은 1. 특정 단어를 명시하는 방법도 있지만 2. 글자나 숫자 조합으로써 단어를 명시할수도 있다. 정규표현식은 이에 두 가지 방법을 제공한다. 기본단어간단하게 검색하고 싶은 특정 단어만 명시하면 된다.만약 여러 단어를 한번에 검색하고 싶다면 () 를 사용하여 | 를 통해 다수의 단어를 넣으면 된다. 글자 - 타입특정 글자를 명시하고 싶을땐 단어와 같은 방식으로 사용하면 되는데 []**를 통해 여러 글자를 찾을수도 있고, **[] 내부에서 확장 표현을 통해 A 부터 Z 까지(A-Z) 규칙을 추가하거나 특정 글자를 제외할 수도 있다. 숫자 글자를 검색하고 싶다면 위에서 배운대로 [0-9] 도 좋지만 ‘숫자’ 글자 타입을 명시하여 검색할수도 있다. 글자의 타입을 명시하기 위한것이 역슬래시(\\)며 예를 들면 ‘숫자’ 글자 타입은 \\d 로 표현할 수 있고 ‘숫자가 아닌’ 글자 타입은 \\D 와 같이 대문자로 표기할 수 있다. 확장앞/뒤특정 단어 혹은 글자를 찾더라도 글의 가장 앞쪽에 혹은 가장 뒷쪽에 존재하는 것을 찾고 싶을때 사용한다. 횟수특정 단어 혹은 글자가 몇번 반복된 것을 검색하고 싶은지 명시할 수 있다. (abc){1} = abc(abc){1,3} = abc, abcabc, abcabcabc(abc)? = (공백), abc(abc)+ = abc, abcabc … 캡쳐앞부분에서 설명하였듯 패턴으로 검색할 단어를 집합으로 묶을때 사용하거나 검색한 결과물들을 활용하려고 할때 결과값을 저장하는 역할을 한다. 정규표현식은 한번 배워두면 어떤 개발 언어에서든 모든곳에서 범용적으로 사용가능하며, 개발에서 활용할 수 있는 경우의 수가 매우 많아 유용하다. 이렇게 정리함으로써 이젠 매번 검색할일 없이 잘 사용할 수 있을듯하다.","link":"/2019/12/15/one-page-for-regular-expression/"},{"title":"ParallelStream 과 HashMap 의 Rehashing 이슈","text":"Single SQL Query -&gt; MSA APIs 전환 시 성능 저하최근 Monolithic Architecture 구조의 레가시 시스템을 MSA 구조로 바꾸는 리플랫폼을 진행하였었습니다. 기존 레가시 시스템은 여러 서브도메인에 해당하는 테이블들이 단일 쿼리에 수많은 Join 으로 연결되어있어서 “단 하나의 쿼리”를 통해 결과를 얻을 수 있어 성능은 매우 좋았지만, 재사용성 및 유지보수성에 있어서는 최악의 구조를 갖고있었습니다. 예약, 결제, 정산, 상품 등 각 서브도메인들을 서비스들로 나누어서 “다수의 API 호출”들로 요청을 처리하도록 변환하니 재사용성 및 유지보수성은 올라갔지만 SQL Join 을 사용하던 것을 API 로 바꾸다보니 수행의 파편화 및 네트워크 시간에 의해 성능이 저하되어 이 해결이 또 다른 리플랫폼의 챌린지 포인트였습니다. Java Stream -&gt; ParallelStream 을 통한 성능 개선단일 쿼리에서는 Join 하나만으로 여러 테이블에 분산된 정보를 하나의 Dto 로 모아서 반환할 수 있습니다. 하지만 각 테이블들을 도메인 기반으로 예약 서비스, 계정 서비스 등으로 나눈다면 간단했던 Join 문은 각각 테이블에 해당하는 다수의 API들을 호출한 뒤, 하나의 Dto 로 Id 기반으로 합치는 작업을 필요로 하게됩니다. 이런 작업에서 Id 기반의 Join 을 프로그램으로 구현할때 저는 개인적으로 성능을 위해 Hash Join 전략과 유사하게 작성하게 되는데 이는 각 API 결과의 HashMap 을 필요로 함을 뜻합니다. List -&gt; HashMap 변환은 간단하지만, List 결과값이 매우 비대한 경우 각 도메인에 해당하는 테이블별로 HashMap 변환만 하더라도 몇초의 시간을 소비하기 때문에 이 시간을 줄이고자 Stream 에서 ParallelStream 로 변환하는 작업을 거쳤습니다. 이실직고하자면 빠르다는 사실 하나만으로 주니어였던 제겐 왜 안써? 싶은 존재였습니다. 성능은 굉장히 빨라졌고, 긴 시간동안 잘 동작하는 듯 했지만 예상치 못했던 몇 이슈로 다가오게 됩니다. ParallelStreamParallelStream 는 Java 8 에서 도입된 멀티스레드 프로그래밍을 매우 쉽게 활용할 수 있게 해주는 도구입니다. 학부때도 멀티스레드가 제일 복잡하고 힘들었었는데, 이걸 단 하나의 코드로 쉽게 사용하게 해준다니 스레드 관리가 불편했던 저에겐 굉장히 매력적으로 다가왔습니다. 또한 타 웹페이지에서 고전적 for-each, stream, parallelStream 성능 비교를 보면 당연하겠지만 말도 안되게 빠른 성능을 제공해주는걸 알 수 있습니다. ForkJoinPool: ParallelStream 의 Thread 관리스레드 관리가 쉬워진 이유는 기존에 Java 에서 사용하던 스레드 관리 방식을 확장한 ForkJoinPool 이라는 관리 방식을 사용하기 때문입니다. 이름과 같이 Fork + Join 을 통해 어떤 복잡한 작업도 작은 단위로 세분화하여 여러 스레드들이 나누어 작업한 뒤 완료된 결과를 하나의 결과로 합치게 되는데, 그것이 ParallelStream 의 방식이기도 합니다. ExecutorService (기존) 1개의 Queue (1: Main Queue) Thread Pool 에서 쉬고있는 Thread 에게 Main Queue 의 작업(Job)을 할당 ForkJoinPool (신규, ‘Fork’ + ‘Join’) 2개의 Queue (1: Main Queue, 2: ExecutorService Queue) ForkJoinPool = Queue 가 추가된 ExecutorService 구현체 Thread Pool 에서 쉬고있는 Thread 에게 Main Queue 의 작업(Job)을 할당 후 추가 프로세스가 존재 Fork: 해당 Thread 는 할당받은 작업(Job)을 수행가능한 작은 단위의 작업들로 분할 Steal: 한 Thread 가 다수의 작업(Job) 부담을 갖게되므로 타 Thread 들이 작업을 나눠서 수행 Join: 세분화되어 여러 Thread 에서 수행완료된 작업 결과는 쪼개어졌던 Thread 에서 다시 합쳐 반환 ParallelStream 는 Spliterator 와 ForkJoinPool 기반^1으로 Fork + Join 을 통해 작업을 작은 단위로 분할한 뒤 실시간으로 어느 하나의 스레드에 작업 부담(Workload)가 몰리지 않도록 여러 Thread 들이 작은 단위의 작업들을 서로 나누어서 효율적으로 자원을 사용하게됩니다. 결과적으로는 더 빠르게 결과를 반환하게되며, ParallelStream == 성능으로 인식되는 이유입니다. HashMap &amp; ParallelStream 사용시 무한루프 이슈RehashingParallelStream 을 통해 서비스 성능 개선을 이룬 뒤 많은 시간이 지나서 갑자기 해당 서버 인스턴스 CPU 가 75% 를 넘어서서 오랜시간동안 계속 내려오지 않는 온콜이 발생하였었습니다. 점유율이 오랜시간동안 75% 에서 내려오지 않자 무한 루프에 진입한것으로 보여 쓰레드 덤프를 분석해보니 parallelStream 에서 할당된 스레드에서 block 인채 멈춰있는걸 발견하였습니다. 문제의 로직은 ParallelStream 내부에서 HashMap 의 put 함수를 사용한 부분이었습니다. 1234Map&lt;Integer, Boolean&gt; result = new HashMap&lt;&gt;();sampleList.parallelStream().forEach(each -&gt; result.put(each.getId(), isSample)); 간단하게 생각하면 List 가 아닌 Map 이기때문에 주입되는 순서도 상관없고, 값이 잘 들어갈것처럼 보입니다. 하지만 HashMap 는 Rehashing 이 있다는 정말 기초적인것을 놓친 생각이었습니다. HashMap 은 Key-Value Pair 를 주입(put)할 때 아래의 과정을 거쳐 이뤄집니다. 새로 추가하는 Key 에 대한 Hash 를 생성하고 Hash 테이블 인덱스에 for-loop 를 통해 존재여부 판단 후, 해당 Hash Key 에 포인터를 통해 Value 을 적재하게 됩니다. 특정 Hash Key 에 포인터로 연결된 Value 개수가 일정 수를 넘으면 Rehashing 을 통해 Hash 인덱스를 나누어 Value 들을 재적재하게 됩니다. Rehashing: Race Condition위 과정 중에 2. 새 Value 포인터로 연결과 3. Rehashing, 두 부분에서는 포인터를 변경하게 되는데 기본 HashMap 의 경우엔 이 포인터 변경 부분이 thread-safe 하지 않습니다. 따라서 다수의 스레드가 2번과 3번을 동시에 수행한다면 즉, 같은 Hash 인덱스의 포인터를 변경하려 하면 문제가 발생할 수 있습니다. 두 스레드가 같은 Hash Key 에 대한 포인터들을 재설정하는 과정에서 서로 꼬여 포인트간 사이클이 발생하게 됩니다. 2번, 3번 모두 put 실행시 수행되는 로직이고, 여기서 생긴 포인터 사이클에 Hash 테이블 인덱스에 대한 for-loop 존재여부 조회가 들어서면서 무한 루프에 빠진것입니다. HashMap 과 ParallelStream 를 동시에 사용시 이러한 Race Condition 으로 인한 무한 루프 문제도 있지만, 실제로 정상 수행되더라도 HashMap 에는 몇개의 Key 가 유실되는 경우도 발생합니다. 이 또한 다수의 스레드가 Hash Key 에 포인터로 Value 를 동시에 주입하면서, 몇개만 포인터가 정상할당되고 나머지는 무시되는 문제에서 발생합니다. 이로 인해 새로운 Key 를 10000 개 put으로 주입하였는데, 실제 HashMap 에 저장된 Key 는 10000 개보다 적은 황당한 경우도 발생합니다. ConclusionJava 의 ParallelStream 내부에서 thread-safe 하지 못한 어떤 작업, 본 글에서는 HashMap 의 put, 을 수행하면 Race Condition 발생으로 인해 몇개의 thread 작업들이 타 thread 에 의해 무시되게 되어서 예상치 못한 결과를 얻게됩니다. HashMap 의 경우엔 아래의 이슈가 발생합니다. Hash Key 에 연결된 Value 간 포인터 사이클이 발생 후, for-loop 존재여부 조회 시 무한루프 10000 번 put 수행하더라도, 몇 Value 포인터 주입이 무시되어 결과 HashMap 사이즈가 10000 미만 당시까지 ParallelStream 로 말미암아 생긴 이슈들이 많았기에, 온콜 해결을 위해서 서비스 전체 로직에서 ParallelStream 이 사용되는 부분을 모두 걷어내었었습니다. 위 문제를 해결하기 위해서는 HashMap 을 ConcurrentHashMap 으로만 바꾸는것으로도 해결이 가능합니다. 물론 ParallelStream 동작 원리는 Spliterator 와 ForkJoinPool 기반이기 때문에 Divide-and-Conquer 라는 기본 원칙인 분할(split) 과 합치는(merge) 작업에 메모리, CPU 자원 소요 비중이 커질 수 있습니다. 따라서 루프 횟수가 몇 십만, 몇 백만건까지의 유즈케이스가 존재한다면 꼭 스트레스 테스트가 필요할것 입니다. 참조 https://hamait.tistory.com/612 https://blog.naver.com/tmondev/220945933678 http://www.h-online.com/developer/features/The-fork-join-framework-in-Java-7-1762357.html https://medium.com/@itugs/custom-forkjoinpool-in-java-8-parallel-stream-9090882472db https://java-8-tips.readthedocs.io/en/stable/parallelization.html#conclusion","link":"/2021/01/31/problems-when-using-parallel-stream-with-hash-map/"},{"title":"오픈 소스(공개 소프트웨어)의 다양한 라이센스들","text":"GPL (General Public License, GNU GPL)공개(자유) 소프트웨어 철학의 조상에 해당하며 그만큼 보수적입니다. 일반 라이센스는 SW에 대한 공유와 수정의 자유를 제한하려는 목적을 가진 반면GPL은 공유와 수정의 자유를 보장하기 위한 규정 상업적 사용이 가능하다. 다만, 공개 및 상업적 사용시 무료 공개를 해야한다. 내부 사용시 (개인, 기관, 단체 내부) 무료 공개의 의무가 없다. GPL 코드의 일부만 사용하더라도 GPL 라이센스를 갖는다. LGPL (Lesser General Public License, GNU LGPL)GPL 은 GPL 인 라이브러리를 사용만해도 2차 저작물에 GPL 이 적용되어,상업적 사용은 가능하지만 소스 코드가 공개되어야하는 단점을 갖습니다. FSF(Free Software Foundation) 는 이런 이유로 GPL 라이브러리 사용 기피 방지 및 오픈 소스의 기여를 위해코드 자체를 수정하지 않는한 공개 조항을 강제하지 않습니다. 기본적으로는 GPL 과 동일하다. LGPL 코드를 단순 사용 시 무료 공개의 의무가 없다. 사용했음만을 명시하면 된다. LGPL 코드를 수정 사용 시 무료 공개를 해야한다. BSD (Berkeley Software Distribution) License &amp; MIT License유닉스 계열 운영체제인 BSD 가 유닉스의 원 제작자인 AT&amp;T의 벨 연구소에게 소송을 당하게 되고,그 이후 소스코드 작성자 이름 표기 외에 어떠한 저작권 내용이 없는 라이센스를 만들어 배포합니다.추가로 MIT 는 BSD 와 거의 유사하여 따로 항목을 생성하지 않았습니다. 소프트웨어계의 공공재 수정 가능, 자유로운 사용 공개의 의무가 없다. 초기 4조항 버전에서 조항이 하니씩 빠지면서 3조항, 2조항 버전이 있습니다. 4조항 - Original 광고에 원 저작권자 표기 필수 광고에 2차 저작권자 표기 불가 3조항 - BSD License 2.0 광고에 원 저작권자 표기 필수 (제거) 광고에 2차 저작권자 표기 불가 2조항 - FreeBSD License 제품에 BSD 라이센스 내용과 원, 2차 저작권자를 표기해야하는 의무 5. Apache LicenseBSD 라이센스는 공공재에 가까운 조항으로 2차 저작물에 대한 어떠한 특허도 요구할 수 없습니다. Apache License 는 이 라이센스 코드를 자신이 활용하여 2차 저작물을 만들어도 그에 대해 특허를 가질 수 있습니다.단 그렇게 하려면 해당 저작물에는 더 이상 Apache License 를 적용해선 안되겠지요. 공개의 의무가 없다. 2차 변형물의 특허출원이 가능하다. 다만, 수정 여부 및 아파치 재단 이름과 라이센스 내용을 명시해야한다. 간단한 이해를 위해서 위와같이 정리해 보았는데요. 역시나 가장 재미있는것은 각 라이센스들이 왜? 어떻게? 에 해당하는 역사겠지요. 아래 링크^1에서 약간 상세하게 풀어놓았으니 참조하시면 큰 도움이 되실겁니다. 참조 https://meetup.toast.com/posts/101 http://wiki.kldp.org/wiki.php/OpenSourceLicenseGuide https://en.wikipedia.org/wiki/BSD_licenses https://en.wikipedia.org/wiki/MIT_License","link":"/2019/08/10/software-licences/"},{"title":"Swift 4+ Keywords - &quot;open&quot;","text":"접근 제어자 (Access Modifier)프로그래밍 언어에서 Java 를 예로 들자면 public, private, protected 으로 필드, 함수, 클래스의 접근 범위를 제어할 수 있습니다. final, open, override, abstract 과 같이 상속 관련 키워드들도 ‘접근 제어자’의 범주에 함께 포함됩니다. (접근 제어자를 가시성 변경자 (Visibility Modifier)로 부르기도 합니다.) 취약 기반 클래스 (Fragile Base Class)취약 기반 클래스 문제^1**는 **상속에 의해 발생하는 문제로 기반 클래스와 그를 상속하는 하위 클래스가 있다고 가정하였을 때 기반 클래스의 변경이 발생하면 하위 클래스가 깨지는 문제를 의미합니다. 기반 클래스를 하위 클래스에서 상속할 시 어떤 메소드를 어떻게 오버라이드할 지에 대한 규칙을 명시하지 않는다면 하위 클래스에서 의도와 다른 방식으로 메소드 오버라이드를 할 수 있습니다. 또한 기반 클래스의 메소드 목적이 변경되었을 때 하위 클래스의 오버라이드 메소드는 기존 의도와 예기치 못한 채 달라지게 되기 때문에 기반 클래스의 변경은 그를 상속하는 모든 하위 클래스에 영향을 줍니다. 이를 기반 클래스가 취약하다는 의미로 취약 기반 클래스라고 부릅니다. 초기 객체지향 프로그래밍 언어에 해당하는 Java, C#, C++ 의 경우에는 객체지향의 특징인 상속이 용이하도록, 접근 제어자를 따로 명시하지 않는다면 모든 기본 클래스는 상속이 가능합니다. 하지만 취약 기반 클래스 문제를 방지하기 위하여 ‘Effective Java’ 저서에서도 “상속을 위한 설계와 문서를 갖추거나, 그럴 수 없다면 상속을 금지하라”로 언급되듯 모든 기본 클래스는 상속하지 말 것을 소프트웨어 아키텍쳐 및 디자인 패턴에서 권장하고 있습니다. 초기 객체지향 프로그래밍을 사용하면서 발견된 한계와 문제들은 언어를 꾸준히 업데이트하면서 보완되기도 하지만, 새로 나오는 언어들은 이러한 좋은 패턴들을 자신들의 특징으로 가져가기도 합니다. 현대 객체지향 프로그래밍 언어인 Kotlin 과 Swift 가 그 중 하나에 속합니다. 우스갯소리로 이런 언어들을 짬뽕이라고 얘기하기도 하지만 그만큼 패턴들을 문법으로서 강제하는 장점을 갖습니다. Swift, Kotlin - final classJava 는 취약 기반 클래스 문제를 갖는 초기 프로그래밍 언어로써 기본적으로 모든 기본 클래스는 상속이 가능합니다.Kotlin 과 Swift 는 위 문제 해결을 위하여 기본적으로 **모든 기본 클래스는 상속이 불가능(final)**합니다.따라서 Swift 의 두 타입인 class 와 struct 모두 기본적으로 상속이 불가능합니다. 추가로 Java 의 변수, 클래스, 함수 모두 기본적으로 아무 접근 제어자를 명시하지 않으면 package-private 로 선언되지만Kotlin 과 Swift 의 경우 아무 접근 제어자를 명시하지 않으면 public 으로 선언되어 어디서든지 사용할 수 있으며, public 은 기본적으로 final로 상속이 불가능합니다. public = Uninheritable, Callable open = Inheritable, Callable 12345open class User { open func login() { } public func playGame() { } public init() { }} Kotlin, Swift 모두 상속을 하기 위해서는 클래스, 함수, 변수 모두에 open 키워드를 추가해야합니다. 함수와 변수에 open 키워드를 사용하여 클래스 전체 레벨이 아닌 함수, 변수 레벨에서 ‘상속 가능한 것’과 ‘상속 불가능한 것’들을 쉽게 관리할 수 있다는 장점이 있습니다. 살펴본 바와 같이 Java 와 Kotlin, Swift 의 상속에 대한 처리는 완전히 반대입니다. Public 한 클래스와 함수들에게 기본적으로 상속 가능하게 하고 상속을 제한하기 위해서 private 나 protected 와 같은 접근 제한자를 사용하게 하는 Java 와 반대로 Kotlin, Swift 는 개발자들에게 기본적으로 모두 상속 불가능하게 하고 상속을 하기위해선 open 을 명시하게끔 제한함으로써 잘못 상속하는걸 방지합니다. 그래서 Swift 에서 얼핏 open 을 사용하다보면 함수, 변수 단위의 상속 여부를 결정하기 때문에 Java 에서 abstract 와 비슷하단 느낌을 받습니다. 참조 https://www.hackingwithswift.com/example-code/language/what-does-the-open-keyword-do","link":"/2019/03/09/swift-keyword-open/"},{"title":"Spring Security: SecurityContextHolder 의 Thread 공유 전략","text":"다수 정보를 리스트로 조회하는 페이지에서 현재 로그인한 유저가 가진 권한에 따라 일부 정보를 보여주지 않도록하는 처리가 필요했습니다. 그래서 먼저 리스트를 API 로부터 가져온 뒤, 현재 Spring Security 로그인 세션에 저장되어있는 권한을 통해 일부 정보를 필터링하여 최종적으로 조회 페이지에 렌더링하도록 작업하였었습니다. 하지만 이상하게 리스트에 노출되는 Row 가 총 10개라면 2 ~ 3개 약 1/4 에 해당하는 Row 만 해당 ‘세션 권한 필터링’ 로직이 적용되었고 나머지 3/4 에 대해서는 적용되지 않는 버그를 발견하였습니다. 심지어 1/4 에 해당하는 2 ~ 3개는 변칙적으로 계속 변경되는것이었습니다. 예를 들면 새로고침 한번에 2번째 3번째 Row 에만 ‘세션 권한 필터링’ 이 적용되었다가, 새로고침을 한번 더 하면 5번째 6번째 Row 에 ‘세션 권한 필터링’이 적용되는것입니다. 마치 슈뢰딩거의 고양이처럼요… 구현은 다음과 같았습니다. 12345678List&lt;SomeInformation&gt; list = someApi.retreive(condition);list.parallelStream() .forEach(each -&gt; { if (!SecurityHelper.hasRole(&quot;ROLE_CAN_SEE_SENSITIVE_NUMBERS&quot;)) { each.setSensitiveNumber1(null); each.setSensitiveNumber2(null); } }) 12345678910111213141516171819public class SecurityHelper { public static boolean hasRole(String role) { SecurityContext context = SecurityContextHolder.getContext(); if (Objects.isNull(context))) { return false; } Authentication authentication = context.getAuthentication(); if (Objects.isNull(auth))) { return false; } for (GrantAuthority eachAuthority : authentication.getAuthorities()) { if (role.equals(eachAuthority.getAuthority())) { return true; } } return false; }} 실제로는 테스트했던 로그인 계정에 ROLE_CAN_SEE_SENSITIVE_NUMBERS 권한이 있었기 때문에, 리스트의 모든 Row 들에 sensitiveNumber1, 2 모두 정상 노출되는것이 맞습니다. 하지만 1/4만 노출되는건 아무리 생각해도 이상하여 parallelStream.forEach 내부에 로그를 추가하였더니 아래와 같은 결과가 나왔습니다. 12345678910INFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-3] [TEST] hasRole: falseINFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-2] [TEST] hasRole: falseINFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-7] [TEST] hasRole: falseINFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-1] [TEST] hasRole: falseINFO 2021-01-01 00:00:01 [http-nio-80-exec-3] [TEST] hasRole: trueINFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-4] [TEST] hasRole: falseINFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-5] [TEST] hasRole: falseINFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-6] [TEST] hasRole: falseINFO 2021-01-01 00:00:01 [ForkJoinPool.commonPool-worker-2] [TEST] hasRole: falseINFO 2021-01-01 00:00:01 [http-nio-80-exec-3] [TEST] hasRole: true 보아하니 ForkJoinPool 즉, ParallelStream 실행을 위해 할당된 하위 Thread(ForkJoinPool.commonPool-worker-1~7) 에서는 hasRole이 비정상적으로 false값을 반환하고, 메인 Thread(http-nio-80-exec-3) 에서는 hasRole이 정상적으로 true값을 반환하는걸 알 수 있습니다. 무언가 ParallelStream 과 SecurityContextHolder 혼용이 문제인것으로 보입니다. SecurityContextHolder 의 Thread 간 공유 모드ParallelStream 의 Thread 에서 hasRole = false 가 반환됐던 1차 원인은 SecurityContext context = SecurityContextHolder.getContext(); 호출시 null이 반환되고 있었습니다. 반면 메인 Thread 에서 SecurityContextHolder.getContext() 호출시에는 정상적으로 세션 데이터를 가져올 수 있었고, hasRole 에 알맞은 비교 로직까지 수행할 수 있었습니다. 알아보니 아래와 같은 사실을 발견했습니다. SecurityContextHolder는 SecurityContext 로그인 세션 정보를 어떤 레벨의 Thread 까지 공유할지 모드를 지정하도록 되어있습니다. 기본값으로는 MODE_THREADLOCAL로써 SecurityContext 정보는 “메인 Thread” 에서만 볼 수 있습니다. 총 공유 모드는 3가지로 나뉘어져있습니다. MODE_THREADLOCAL: (Default) Local Thread 에서만 공유 가능 MODE_INHERITABLETHREADLOCAL: Local Thread 에서 생성한 하위 Thread 에까지 공유 가능 MODE_GLOCAL: 모든 Thread, 어플리케이션 전체에서 공유 가능 기본 모드는 MODE_THREADLOCAL 였기에, 아무런 설정도 하지 않았던 서버에서는 메인 Thread(http-nio-80-exec-3)에서만 SecurityContext 가 반환되었던고, 나머지 하위 Thread(ForkJoinPool.commonPool-worker-1~7)에서는 null 이 반환되었던것입니다. 결론SecurityContextHolder 의 기본 설정은 SecurityContext 정보를 Local Thread 만 공유하도록 되어있기 때문에 SecurityContextHolder 를 직접 하위 Thread 안에서 호출하여 사용하는것보다, 메인 Thread 에서 호출하여 해당 값을 하위 Thread 에서 참조하도록 하는것이, 성능적으로나 가시적으로도 더 깔끔한 코드가 될것입니다. ParallelStream 혹은 Async 관련된 기능을 사용 시 하위 Thread 에서 SecurityContextHolder 를 사용해야하는 경우가 있다면 SecurityContextHolder 의 공유 모드를 MODE_INHERITABLETHREADLOCAL 로 낮추는것을 고려해야합니다. 출처: Spring Security - SecurityContextHolder Strategy:http://ncucu.me/116","link":"/2021/03/14/thread-and-security-context-holder-mode/"},{"title":"2. 디자인 패턴의 제 1, 2 원칙","text":"설명에 사용할 코드는 Java-like Pseudo Code 입니다. 내게 대학교 시절에 객체지향 프로그램은 다형성과 상속뿐이었지만 책이 아닌 실제 프로그래밍으로 접한 객체지향 프로그램은 학문이 아니라 실전이었습니다. 왜 이걸 배웠고 이게 사실 어떤 의미를 갖는건지 그제서야 깨달을 수 있었습니다. 여기서는 짧게 우리가 생각했던 상속을 살펴보고 디자인 패턴으로 도약하기 위해 상속을 버리는 두 개의 원칙을 익히려고 합니다. 상속 = 객체지향 프로그램?처음 엔터프라이즈 객체지향 프로그램을 작성한다고 가정해봅시다. 학교에서 공부한대로라면 객체지향 프로그램은 상속이라고 배웠습니다. 그래서 우리는 과감히 상위 클래스를 만들고 이를 상속하여 하위 개념에 해당하는 클래스를 활용할 것입니다. 그리고 객체지향 프로그래밍 프로젝트 #1 이라고 이름 짓겠죠. 코드는 아래 헤드퍼스트 책의 예제와 같을 것입니다. 처음 배웠던 상속 상위 클래스 + 상위 행위12class Duck{ swim(), display(), fly(), quack() } 하위 클래스 + 상위 행위 확장1234class RedHeadDuck extends Duck { swim(), display(), fly(), quack() }class RubberDuck extends Duck { swim(), display(), fly(){ null }, quack() } 상속을 사용하였더니 상위 Duck 클래스에 있는 모든 상위 행위들을 하위 Duck 클래스들이 모두 갖게됩니다. 어떤 하위 Duck 클래스는 의지와 상관없이 갖고싶지 않지만 무조건 모든 상위 행위를 갖고 확장해야합니다. 개발에 있어 불필요한 제약을 갖게되는 것입니다. 그럼 아래와 같이 선택적으로 행위를 가져갈 수 있도록 행위를 인터페이스로 분리해 가져보겠습니다. 상속 대신 인터페이스 상위 클래스12class Duck { swim(), display() } 행위 인터페이스12interface Flyable { fly() }interface Quackable { quack() } 하위 클래스 + 행위 인터페이스 구현1234class RedHeadDuck extends Duck implements Flyable, Quackable{ swim(), display(), fly(), quack() }class RubberDuck extends Duck implements Quackable { swim(), display(), quack() } 드디어 상위 클래스에 속하던 행위를 인터페이스로 분리하여 하위 클래스에 원하는 행위들만 붙일 수 있게 되었습니다. 하지만 두 개의 오리가 같은 소리를 갖는다면 Quackable 오리 각각에 quack() 을 똑같이 구현해주어야 합니다. 두 개의 오리면 괜찮겠지만 100 중 70 종의 오리가 같은 소리를 낸다면 70 개의 같은 quack() 구현 코드를 작성해야합니다. 그 중 몇 개의 quack() 소리를 다른 타입으로 바꾸려해도 같은 반복작업이 생기게 됩니다. 그럼 행위 인터페이스 구현을 따로 만들어서 원하는 구현을 선택적으로 가져보면 더 좋지 않을까요? 인터페이스 ‘구현’이 아닌 ‘구성’ 상위 클래스1234class Duck { interface Flyable; interface Quackable; swim(), display(), doFly(){ Flyable.fly() }, doQuack(){ Quackable.quack() } } 행위 인터페이스12interface Flyable { fly() }interface Quackable { quack() } 행위 인터페이스 구현1234class NotFlyable implements Flyable { fly(){...} }class SuperFlyable implements Flyable { fly(){...} }class ShoutQuackable implements Quackable { quack(){...} }class QuiteQuackable implements Quackable { quack(){...} } 하위 클래스 + 행위 인터페이스 구현12345678class RedHeadDuck extends Duck{ interface Flyable = class SuperFlyable(); interface Quackable = class ShoutQuackable(); swim(), display(), doFly(){ Flyable.fly() }, doQuack(){ Quackable.quack() } }class RubberDuck extends Duck{ interface Flyable = class NotFlyable(); interface Quackable = class QuiteQuackable(); swim(), display(), doFly(){ Flyable.fly() }, doQuack(){ Quackable.quack() } } 인터페이스를 구현하는것이 아닌 구성을 통해 클래스 내부 변수로 갖게되면서 원하는 행위 인터페이스 구현을 마음껏 갖고 바꿀 수 있게 되었습니다. 이로써 인터페이스를 대학교때 배웠듯이 클래스의 템플릿이다.라는 이해에서 조금 더 나아가 클래스가 갖는 행위나 특성을 담을 수 있는 하나의 ‘변수’**로 생각할 수 있으면 좋을것 같습니다. 이것이 우리가 **다형성을 배운 이유이기도 합니다. 디자인 패턴의 제 1, 2 원칙위에서 배운 내용은 사실 아래 두 원칙에 해당합니다.복습 겸 한번 더 복기하고 다음 챕터로 넘어가도록 하겠습니다. 구현보다 인터페이스에 맞춰서 코딩한다. 구현은 언제나 바뀔 수 있다. 인터페이스를 통해 유연하게 구현하자 fly(), quack() 같은 행위를 클래스 내부에서 구현하지 않고 인터페이스로 대체함으로써 필요한 것과 필요하지 않은 것들을 분리할 수 있습니다. 인터페이스는 ‘상속’보다는 ‘구성’으로 사용하자 인터페이스를 ‘상속’이 아닌 ‘구성’ 시 원하는 구현을 붙였다 떼었다 할 수 있다. 인터페이스를 ‘상속’하면 인터페이스의 모든 함수들을 그를 상속하는 클래스 안에서 구현해야합니다. 구현이 클래스 안에 갖혀버림과 동시에 구현과 클래스 내부간의 강결합이 생깁니다. 반면 ‘구성’을 사용하면 인터페이스를 구현한 구현 클래스 단 하나로 어느곳에서든지 사용 가능합니다. 레고처럼 붙였다 떼었다 할 수 있어 쉽게 바꿀 수 있고, 구현 클래스 로직과 그걸 사용하는 클래스 간 결합이 풀리게 됩니다.","link":"/2019/02/21/two-principles-of-design-patterns/"},{"title":"Wrapper Class Caching: Integer(Wrapper Class) &#x3D;&#x3D; 사용시 이슈","text":"얼마전부터 서버에서 Integer 객체를 == (항등 연산자)를 사용한 코드때문에 간간히 에러 로그가 남는것을 확인했습니다. 신기한건 해당 API 가 매우 자주사용되는데, 간헐적으로 발생한다는 것이었습니다. 간단하게 설명하면 업데이트하려는 리스트 개수와, 업데이트 이전 리스트 개수가 맞는지 검사하는 Validation 로직이었는데, 에러 로그를 확인해보면 업데이트 전 리스트 개수\u001d와 업데이트 후 리스트 개수가 324 != 324 로 다릅니다.라고 찍혀있는 것이었습니다. 단순히 팀원들과 **객체 비교는 == 를 사용하면 Reference 메모리 주소값을 비교하기 때문에 당연히 equals 를 사용해야합니다.**라고 공유했지만, 실제로 해당 로직이 이상해서 값을 하나씩 1씩 증가시키며 대입해본 끈기있는 개발자분에 의해 다음과 같은 사실이 밝혀졌습니다. Integer 객체 비교는 == 를 사용했을때 127 까지는 ‘true(같음)’을 반환하는데, 그 이상 128 부터는 ‘false(다름)’으로 반환합니다. 본 글은 왜 그런지에 대한 이유에 대한 짧은 글입니다. Java 뿐만 아니라 Javascript 를 처음배운다면 Class 를 접하실테고, Primitive Type, Reference Type 을 배우실겁니다. 컴퓨터공학/과학과에서 요즘엔 Python 을 배우지않을까 싶은데 C 를 배우게 된다면 변수에 값을 저장하면 메모리에 어떻게 적재되는지 배우게 됩니다. 간단하게 아래와 같이 나뉩니다. Primitive Type 변수에 값을 할당하면 그 값 그대로 메모리에 저장 값이 그 값 자체로 사용가능한 타입 정수형: byte, short, int, long 실수형: float, double 문자형: char 논리형: boolean Reference Type 변수에 값을 가진 객체의 주소를 저장하고, 그 값은 주소가 가리키는 객체 공간에 저장되어있습니다. 값(field)과 유용한 함수(method)들을 하나의 객체로 담은 타입 Wrapper Class: 그 중 Primitive Type 값과 유용한 함수들을 하나의 객체로 담은 타입 정수형: Byte, Short, Int, Long 실수형: Float, Double 문자형: Character 논리형: Boolean 그 외: Array, Class 등 본 글에서는 Primitive Type 과 그 값들을 감싼 Wrapper Class, 이 둘만을 다룹니다. Boxing &amp; Unboxing이 두 타입이 Java 에서 혼용할 수 있기 때문에, Primitive Type 과 Wrapper Class 에 저장된 값을 사용하기 위해서 매번 연산자나 함수에서 사용하는 타입에 맞춰서 변환해줄 순 없습니다. 불필요한 코드의 양이 늘어나기에 이는 Java Compiler 가 바이트코드 생성 시 자동변환을 해주게 됩니다. 어떤 타입에서 어떤 타입으로 변환하는지에 따라 boxing, unboxing 으로 나뉘는데 Class 에서 값을 꺼낸다 = unboxing, Class 에 값을 담는다 = boxing 으로 직관적으로 이해 가능합니다. BoxingPrimitive Type 값을 Wrapper Class 객체 내부에 감싸(box) 저장하여 Wrapper Class 주소를 반환합니다. Integer a = 10; 이런식으로 선언하면 좌측은 Integer(Wrapper Class) 우측은 10(Primitive Type)이기에 우측의 10 값을 new Integer(10) 의 형태로 객체로 자동으로 감싸 반환하게 됩니다. 이를 Auto-boxing 이라고 부릅니다. 이 덕분에 함수 파라미터가 다음과 같더라도 private void pleaseGiveMeReference(Integer a) 함수 호출시에 pleaseGiveMeReference(10)으로 호출 할 수 있는것입니다. UnboxingPrimitive Type 값을 가진 Wrapper Class 객체를 int a;, Integer b = new Integer(10) 과 같은곳에 사용하려면 Primitive Type 으로 값을 꺼내어(unbox) int a = b 의 결과는 int a = 10 이 됩니다. 이를 Auto-unboxing 이라고 부릅니다. 이 또한 위에 Boxing 에서 살펴봤듯이, 이 덕분에 함수 파라미터가 다음과 같더라도 private void pleaseGiveMePrimitive(int a) 함수 호출시에 Integer wrapped = 10 객체를 다음 함수에 pleaseGiveMePrimitive(wrapped) 이렇게 호출 할 수 있는것입니다. 글의 맨 처음에 문제가 되었던 == 은 실제 값의 비교이기에 Primitive Type 비교할때만 우리의 직관대로 동작합니다 Wrapper Class 을 비교한다면 Integer a 변수에 저장된 객체에 대한 메모리 주소만을 비교하기에 아무리 같은 값을 갖고있는 두 객체를 비교하더라도 결과값은 ‘false(불일치)’일것입니다. 명심해야할 것은 == 연산자는 “절대로” Auto-boxing, Auto-unboxing 을 지원하지 않습니다. 심지어 Integer 처럼 Auto-boxing, Auto-unboxing 를 지원하더라도 말입니다. 그렇다면 왜 서버에서 Integer == Integer 는 127 까지는 제대로 동작하고 128 부터는 우리가 생각하는대로 동작하지 않는것일까요? == 연산자는 Auto-unboxing 이 안된다면서요. 설마 조건에 따라 되는걸까요? 아닙니다. Wrapper Class Caching (Java 5+)Java 5 에서는 메모리 효율을 위해 Wrapper Class Caching 을 도입했습니다. “일부” Wrapper Class(Byte, Short, Integer, Long, Character) 에 대해서 작은 값에 대해서 메모리에 캐싱하여, 작은 값에 대한 객체를 생성하면 캐싱해놓은 Wrapper Class 객체를 반환해주는 것입니다. Integer 의 예로 1, 2, 10 같은 값들은 사용 빈도수가 굉장히 크기때문에 일일히 이에 대한 Wrapper Class 객체를 생성해주면 메모리 입장에서 Integer a = 10;, Integer b = 10; … 100개를 정의한다면 100개에 대한 메모리를 다 할당해놓아야하는것입니다. 이에 따라 빈도수가 큰 객체는 미리 만들어두고 10 값에 대한 Wrapper Class 객체는 미리 만들어놓은 단 하나의 객체만을 사용하도록 하는것입니다. Integer a = 10;, Integer b = 10; … 모두 캐싱된 new Integer(10) 객체를 사용하기때문에 Integer a, Integer b 모두 같은 객체 주소값을 가지며, 메모리는 단 1개에 대해서만 할당하면 됩니다. 한 객체로 여러 변수들에 사용가능하도록 했기때문에 이를 Immutable Wrapper Object 라고도 부르는듯 합니다. Wrapper Class Caching 이란것이 “일부” Wrapper Class 에만 적용된다고 강조했던 이유는 Float 는 캐싱하지 않고, Character 는 음수값을 제외한 0 ~ 127 만 캐싱하는 등 타입별 지원되는 캐싱 스펙이 다르기 때문입니다. 상제한 스펙은 자바 공식 스펙 문서를 참조하시기 바랍니다.^1 아무래도 적은 수에 대해서만 캐싱한것은 빈도수가 적은수에 대해서만 집중함일것이고, 2^8(256)을 넘는다면 bit 개수에 따라 캐싱 메모리도 늘어나므로 어느 정도 합의점을 본것으로 느껴집니다. Wrapper Class 중 빈도수가 높은 작은 값들에 대한 객체들을 미리 선언해놓고, 코드상에서 해당 값으로 Wrapper Class 객체를 생성하려하면 이미 저장된 객체를 반환합니다. Integer 에 대한 Wrapper Class Caching 은 -128 ~ 127 값에 대한 객체를 캐싱해놓습니다. Conclusion Wrapper Class 의 동일 여부는 equals() 를 사용합시다. 그렇다면 이제 Integer == Integer 가 어떨때 동작하였고, 어떨때 동작하지 않는지 이유가 명확해졌습니다. Integer 는 -128 ~ 127 까지의 값에 대한 객체는 Java 의 Wrapper Class Caching에 의해 매번 정의할때마다 메모리에 생성하지 않고, 미리 캐싱되어있는 객체를 사용하게 됩니다. 그리하여 Integer a = 10, Integer b = 10 모두 같은 객체 주소값을 가지기때문에 a == b 는 10 == 10 값이 같다는 이유가 아닌 9ab2e1 == 9ab2e1 주소가 같다는 이유로 ‘true(같음)’을 반환하는것이었습니다. 에러 발생 빈도수가 적었던것도 해당 로직 특성상 127 이상의 값이 나올일이 없었던것일테고, 테스트시 발견 못한것은 테스트 값을 상식적인 값 범주만 했을뿐 Integer 최대, 최소 경계값에 대한 테스트케이스는 놓쳤기 때문이라 생각합니다. 다시 한번 값 비교는 equals 를 사용해야한다는 것과, 항상 경계값에 대한 테스트케이스는 필수다라는 당연한 사실을 다시 깨닫고 갑니다. Java 는 예나 지금이나 참 어려운 언어인것같습니다. 이런걸 접하다보면 예전에 1년간 맛보았던 Kotlin 으로 다시 돌아가고 싶은 마음이 듭니다(…). 그래도 이런 작은 부분들까지 메모해놓고 알아둔다면 앞으로의 지식에 큰 도움이 언젠간 되겠죠. JVM, Java Compiler 에서는 개발자 편의를 위해 지원해주는 기능이 몇가지가 있는데, 이번 캐싱 이슈뿐만 아니라 Java Generic 개념에서도 메모리 효율을 위해 컴파일 시 개발자가 개발한 Interface 구현체를 모두 Interface 로 자동 변환하여, 컴파일 타임에서 걸러지지 못한 에러가 런타임에서 에러로 발생하는 이슈도 있습니다. 이는 추후 포스팅으로 설명하도록 하겠습니다. 출처: Immutable Objects / Wrapper Class Caching:https://wiki.owasp.org/index.php/Java_gotchas#Immutable_Objects_.2F_Wrapper_Class_Caching","link":"/2021/03/14/unboxing-when-use-equal-operator-on-wrapper-class/"},{"title":"Spring MVC, Security 동작 원리와 처리 흐름","text":"Web Server (static 페이지)웹 초기에는 서버에 정적인 문서(html)를 저장해서 유저가 요청하면 해당 파일을 유저의 브라우저에서 다운받아 보여주는 방식이었습니다. 예를 들면 특정 서버 aaron.com 에 있는 hello.html 문서를 보고싶다면 브라우저에 aaron.com/hello.html 을 호출하면 되는것입니다. 아주 예전에 대학교에서 교수가 자신의 연구실 서버를 이용해서 강의자료를 배포할때 아래와 같은 페이지에 들어가서 다운받았던 기억이 납니다. 서버에 있는 페이지를 유저들에게 보여줍니다. 서버에서 제공하고자 하는 파일들을 실제 서버 내부에 일일히 적재를 해야했으며, 서버에 존재하지 않는 파일에 접근한다면 404 Not Found Error 오류를 보게 됩니다. 이렇게 유저에게 정적인 페이지를 제공하는 서버를 Web Server(웹 서버)라고 부르며 많이 접해봤을 Apache, Nginx 가 이에 해당합니다. Nginx 의 요청/처리 흐름요청 처리시웹 서버의 예로 nginx 에서는 유저 요청을 아래의 과정으로 처리합니다. 요청 처리시 유저는 웹 서버에게 특정 페이지(index.html)를 요청합니다. 웹 서버는 index.html 검색 후, 있다면 유저에게 반환합니다. Web Application (dynamic 페이지)Javascript 의 등장으로 초기 웹 서버처럼 유저에게 단순한 문서를 공유하는 일방적인 서비스를 제공하는것에서 그치지 않고, 유저와의 인터렉션을 통해 회원가입도 가능하고, 글도 쓸 수 있고, 작성한 글들을 서로 볼 수 있는 등의 양방향의 서비스에 대한 요구사항이 생겨나게 되었습니다. 이를 위해서는 일반적인 어플리케이션처럼 데이터베이스와의 연결도 필요하고, 회원의 상태에 따른 동적 페이지 렌더링 등이 필요해졌습니다. 서버는 서버에 있는 자원만 반환하는것이 아니라 유저가 요청한 정보를 요청받은 시점에 알맞은 자원(페이지)를 만들어서 반환하게 됩니다. 서버에 없는 페이지를 유저들에게 매 요청때마다 동적으로 만들어서 보여줍니다. 웹으로 어플리케이션과 같은 요구사항을 처리하기 위해서는 웹 서버와 여러 언어로 개발된 프로그램을 연결하여 유저의 요청을 서버를 통해 프로그램으로 전달해야합니다. 이렇게 웹 서버와 프로그램 사이를 연결해주는 방식을 CGI(Common Gateway Interface)라고하며 여러 언어로 개발되어있습니다. 그 중 Java 에서는 Web Server 요청/반환과 Java Application 사이를 연결해주는 Servlet 객체가 등장합니다. Servlet 은 유저 요청 하나마다 하나씩 생성되기 때문에 여러 요청에 따른 Servlet 자원 관리가 필요합니다. 이 역할을 하는것이 Web Container 이며 Servlet 입장에선 Servlet Container 로 부르기도 합니다. 유저의 요청/반환을 관할하는 Web Server + 요청에 따른 적합한 Java Application 구동을 위한 Servlet 관리자 Web Container 이 둘을 합쳐 Web Application(웹 어플리케이션) 이라고 부릅니다. Web Application = Web Server + Web Container(= Servlet Container) Web Container 는 유저의 요청에 따라 Servlet 자원에 대한 생명주기를 관리합니다 생성(init) -&gt; 처리(service) -&gt; 파기(destory) Tomcat 의 요청/처리 흐름요청 처리시웹 어플리케이션의 예로 tomcat 에서는 유저 요청을 아래의 과정으로 처리합니다. 웹 서버 그림과 비교했을때 웹 서버 아래에 추가된것은 모두 웹 컨테이너에 관련된 것입니다. Web Container 를 시작으로 아래서 위로 역순으로 살펴보겠습니다. 옆에 회색으로 표시한 명칭은 실제 클래스/인터페이스명입니다. ServletContext (Web Container)‘Servlet 객체 주기 관리를 위한 웹 컨테이너’에 해당합니다. 관리라는 의미로 Context 를 사용했습니다.모든 요청에 대한 Servlet 생명주기는 이 ServletContext가 모두 관리합니다. ServletContextListener‘Servlet 객체 주기 관리를 위한 웹 컨테이너’ ServletContext 최초 구동시(Listener) 수행할 작업을 정의합니다. web.xml (Deployment Description)Deployment Description 이라는 명칭에서 알 수 있듯이 웹 컨테이너 구동시, Servlet 을 위한 2가지 설정을 합니다. B) ServletContextListener 인터페이스 구현체 (어떤것을 실행할지) A) ‘어떤 요청’에 ‘어떤 타입’의 Servlet 객체를 생성할지 추가된 요소들을 살펴보았으니 위 웹 어플리케이션 그림의 유저 요청 처리 방식을 따라가보겠습니다. 최초 구동시 tomcat 웹 어플리케이션이 최초 구동시 가장 먼저 웹 컨테이너(ServletContext)를 구동합니다. B) ServletContext 구동 시 web.xml 에 설정한 ServletContextListener 를 같이 수행합니다. 요청 처리시 유저는 웹 서버에게 특정 페이지(index.html)를 요청합니다. 웹 서버는 index.html 검색 후, 존재하지 않기 때문에 웹 컨테이너(ServletContext)에게 요청을 이관합니다. A) ServletContext 는 web.xml 에서 index.html 요청에 맞는 타입의 Servlet 를 생성합니다. 생성된 Servlet 은 유저가 요청한 페이지를 동적으로 생성하여 유저에게 반환 후 파기(destory)됩니다. Spring MVC FrameworkJava Servlet 을 활용한 웹 어플리케이션 개발이 활성화되면서 여러 디자인 패턴들을 적용하여 Java 웹 개발을 더 쉽게 도와주는 Spring Framework 가 등장하게됩니다. 초기 웹 어플리케이션이 페이지를 동적으로 렌더링하기 위해 각 요청마다 Servlet 을 할당하여 요청을 처리하였다면, Spring 은 각 요청마다 Servlet 보다 작은 단위인 Bean 을 할당하여 요청을 처리합니다. 요청을 처리하는 단위가 Servlet 이라면 Servlet 관리를 위한 Servlet Container요청을 처리하는 단위가 Bean 이라면 Bean 관리를 위한 Bean Container 가 필요합니다.이 Bean Container 를 Spring Container 로 부릅니다. Servlet Container 는 각 URL 요청들을 Serlvet 을 단위로 처리하지만Spring Container 는 각 URL 요청들을 Bean 을 단위로 처리합니다. Spring 은 기본적으로 MVC 모델로 Model, View, Controller 세 그룹의 역할로 분리 개발을 돕는 프레임워크이기에 아무리 디자인 패턴에 대한 지식이 전무한 개발자일지라도 유지보수성, 재사용성이 뛰어난 웹 어플리케이션을 만들 수 있습니다. 또한 데이터베이스 접근을 위한 JPA, 트랜잭션, 보안 등 웹 어플리케이션에서 필요로하는 모든것을 Bean 설정으로 제공하기 때문에 어떤 초보자라도 탄탄한 이해만 바탕이 된다면 웹 어플리케이션을 손쉽게 만들 수 있습니다. 디자인 패턴이 실무적으로 어떻게 적용되었는지 공부하는데엔 Spring 만한것이 없는것같다는 어느 시니어의 말씀이 기억에 남습니다. Spring + Web ApplicationSpring MVC 동작 과정을 쉽게 이해하기 위해서는 MVC 와 Front Controller 패턴 (2-레벨 Controller) 만 알면 됩니다. MVCModel, View, Controller 로써 유저의 요청을 효율적으로 처리하기 위한 모델입니다. 유저가 어떤 페이지를 요청하면 요청에 적합한 Controller 가 요청을 받아서 요청 페이지에 필요로 하는 정보인 Model 을 조회/생성하고 조회/생성한 Model 을 통해 최종 페이지인 View 를 생성하여 유저에게 반환하는 모델입니다. Front Controller 패턴요청을 받는 부분을 Controller 라고 하였는데 tomcat 은 요청을 Servlet 이라는 Controller 에서 처리하고, Spring 은 요청을 Bean 이라는 Controller 에서 처리합니다. 2-레벨 Controller 의 의미는 (1) 맨 앞의 tomcat 이 모든 요청을 단일 Servlet으로 먼저 받아, 요청 URL 이 무엇인지에 따라서 (2) Spring 의 Controller Bean 에 재할당해주게 됩니다. 가장 앞의 (1) tomcat 단일 Servlet 을 ‘요청을 가장 앞에서 먼저 받는다’는 의미에서 Front Controller 라 부르고, 그 뒤에 (2) Spring Controller Bean 을 실제 페이지 생성에 사용된다는 의미에서 Page Controller 라고 부릅니다. Spring MVC 의 요청/처리 흐름최초 구동시Spring + tomcat 에서는 유저 요청을 어떻게 처리하는지 알아보기에 앞서, tomcat 과 Spring 이 처음 구동될때 어떤 객체들이 생성되어 준비되는지 먼저 알아보겠습니다. Web Container 아래에 Spring Container 가 새로 추가된것을 볼 수 있습니다. 위 그림과 같이 tomcat 에 Spring 을 연결하여 사용하려면 tomcat 설정파일인 web.xml 에 2 가지 설정이 필요합니다. web.xml (Deployment Description) B) ServletContextListener 인터페이스 구현체 - Root WebApplicationContext-&gt; Spring 공용 Bean (@Service, @Repository, @Component…) 객체들을 미리 생성해놓기 위함 A) ‘모든 요청’은 Front Controller 에 해당하는 단일 Servlet 객체(DispatcherServlet)가 처리한다. 최초 구동시 tomcat 웹 어플리케이션이 최초 구동시 가장 먼저 웹 컨테이너(ServletContext)를 구동합니다. B) ServletContext 구동 시 web.xml 에 설정한 Spring Root WebApplicationContext가 동시에 구동됩니다. 요청 처리시위 최초 구동 후 tomcat 은 모든 요청을 단일 Servlet(명칭은 DispatcherServlet) 으로 받을 준비가 완료되었고, Spring 도 Controller Bean 이 결과를 반환하기 위해 필요로하는 모든 Bean 들이 Root WebApplicationContext 로 준비가 완료되었습니다. 이제 유저가 요청을 보내면 tomcat 과 Spring 이 어떻게 처리하여 결과를 반환하는지 아래 그림으로 살펴보겠습니다. Spring 의 키워드는 IoC, DI 라고 할 수 있는데, 간단하게 설명하자면 기존에는 개발자가 new 를 통해 객체를 직접 생성하고, 직접 주입해줬다면 Spring 에서는 어떤 인터페이스, 클래스를 사용할것인지만 표기해놓으면 ApplicationContext(BeanFactory 상속) 라고 불리는 Spring Container 가 객체를 Bean 이라는 단위로 알아서 생성하고 알아서 주입해주는 개념입니다. 이렇게 Spring 에서는 Java 의 모든 객체를 Bean 으로 부르며 사용합니다. Spring Container = ApplicationContext Spring 에서 Bean 은 웹 어플리케이션 관점에서 크게 2 개의 타입으로 구분될 수 있습니다.그에 따라 Bean 의 생명주기를 관리하는 Spring Container 도 2 개의 타입으로 나뉘어집니다. 요청이 들어왔을때 적합한 처리를 위해 요청과 상관없이 모든 Servlet 들이 공유하는 공용 Bean 예: @ComponentScan 으로 등록된 @Service, @Repository, @Component 등 생명주기 관리: Spring Container 1 (Root WebApplicationContext) 요청이 들어왔을때 할당되는 Servlet 처럼, 요청이 들어왔을때만 생성하면 되는 Bean 예: @ComponentScan 으로 등록된 @Controller, @Interceptor 등 생명주기 관리: Spring Container 2 (Servlet WebApplicationContext) 위 그림을 보면 최초 구동시에 생성된 Spring Container 1 아래에 또 하나의 Spring Container 2 가 생겨난걸 볼 수 있습니다. parent 와 child 라고 써져있는것은 두 컨테이너 간 계층이 있다는 의미이며, 단순히 child 인 Servlet WebApplicationContext 의 Bean 들은 부모인 Root WebApplicationContext 의 Bean 들을 참조할 수 있지만 그 반대로는 참조할 수 없음을 의미합니다. Root WebApplicationContext 이 모든 Servlet 들이 공유하는 Bean 생명주기를 관리하는것이라 생각하면 당연한것입니다. 요청 처리시 유저는 웹 서버에게 특정 페이지(index.html)를 요청합니다. 웹 서버는 index.html 검색 후, 존재하지 않기 때문에 웹 컨테이너(ServletContext)에게 요청을 이관합니다. A) ServletContext 는 web.xml 에서 어떤 요청이든 / 단일 DispatcherServlet 을 생성합니다. DispatcherServlet 은 유저가 요청한 페이지에 해당하는 Spring Controller가 있는지 HandlerMapping 을 탐색합니다. Spring Controller 를 Handler 라고 부릅니다 DispatcherServlet 은 찾은 Spring Controller Bean를 HandlerAdapter를 통해 호출합니다. HandlerAdapter은 HelloController Bean를 호출합니다. HelloController는 Root WebApplicationContext 의 여러 Bean 들을 활용하여 결과를 DispatcherServlet에 반환합니다. DispatcherServlet는 Controller 로부터 받은 결과로 ViewResolver, View에서 결과 페이지(index.html)를 생성합니다. DispatcherServlet는 ViewResolver, View가 만든 결과 페이지(index.html)를 유저에게 반환합니다. 위 과정의 코드레벨에서의 흐름은 다음 블로그 링크^1에 잘 정리되어있어 참고하시면 상세히 알 수 있습니다. 이렇게 Spring MVC 에서 어떻게 유저의 요청을 받아서 처리하고 반환하는지를 그림으로 알아보았습니다. 요청 URL 에 따라 Controller Bean 이 할당된다는것은 알았지만, 이렇게 상세하게 알아보니 컨트롤러나 서비스에서 Exception 이 발생하였을때 로그에 남는 Stacktrace 의 메서드와 클래스들의(invoke, DispatcherServlet, preHandle, postHandle 등) 의미를 좀 더 알 수 있었습니다. Spring Interceptor 와 Filter 의 차이점Spring 을 활용하여 개발한 웹 어플리케이션들은 일부 혹은 모든 사용자에게 오픈되어 서비스를 제공하기때문에 보안이 필요합니다. Spring Security 는 기본적으로 로그인과 세션에 관련된 모듈 및 설정을 손쉽게 사용가능하도록 제공하지만, 웹 어플리케이션에 인입되는 모든 요청에 따로 개발한 인증 모듈을 적용하거나, 요청 URL 에 따라 다른 처리 등이 필요하다면, 개발자가 해당 로직들을 직접 만들어 유저 요청이 실제 Spring Controller 에게 전달되기 전에 수행되도록 해당 로직을 추가해야합니다. 이때 사용되는것이 Interceptor 와 Filter 입니다. 우리는 앞서 Spring 을 사용한 웹 어플리케이션은 크게 Tomcat (Web Container) 와 Spring (Spring Container) 의 2개로 구성된다는것을 배웠습니다. Interceptor 와 Filter 도 Spring Controller 에 요청이 도달하기 이전에 원하는 중간 작업을 위해 사용된다는 목적에선 동일하지만, 관리주체 및 실행시간이 Tomcat 과 Spring 으로 나뉘어집니다. Filter 는 Servlet 스펙의 일부이고 Servlet(Tomcat)에 의해 호출되지만Interceptor 는 Spring 에 의해 호출됩니다.(It’s perfectly fine as Filter’s are part of Servlet specification. Filters are called by your Server(tomcat). while Interceptors are called by Spring^2) 아래는 Interceptor 와 Filter 의 관리주체 및 실행시간을 이해하기 쉽게 표현한 그림입니다. Filter (Tomcat) Servlet (J2EE 7 표준)스펙에 정의 웹 어플리케이션(tomcat) Deployment Descriptor(web.xml)에 설정 이 부분에 대한것도 최신 Spring 에서 설정 가능 1개의 함수로 DispatcherServlet 이전/이후에 호출 함수명: doFilter() 요청이 DispatcherServlet.service() 에 진입하기 직전(init() 후)에 호출 결과를 DispatcherServlet.service() 가 반환하는 직후(destroy() 전)에 호출 doFilter 함수가 요청 진입시 &amp; 결과 반환시, 2번 호출되기 때문에, 암/복호화같은 요청 전 &amp; 반환 후 두 곳에 전역적으로 처리해야하는 로직에 적합합니다. Interceptor (Spring) Spring Framework 스펙에 정의 Spring WebApplicationContext에 설정 3개의 함수로 Controller 이전/이후에 호출 함수명: preHandle() 요청이 Controller 에 진입하기 직전에 호출 함수명: postHandle() 결과를 Controller 가 반환하는 직후에 호출 함수명: afterCompletion() Controller 결과에 따라 View 를 생성한 직후에 호출 컨트롤러 진입 혹은 결과 반환 시점에 디테일하게 처리해야하는 로직에 적합합니다. 예를 들어 특정 URL 로 진입되는 요청에 대해서는 컨트롤러 진입 직전에 해당 URL 에 특화된 정보들을 미리 세션에 설정하여 컨트롤러 내부 로직에서 활용할 수 있게 할 수 있습니다. 다른 URL 이라면 본 로직을 수행하지 않도록 조건을 추가할 수도 있습니다. 필터와 인터셉터는 관리주체가 다르기 때문에 다음과 같은 상황이 발생합니다. 필터는 Spring Container 관리주체가 아니기 때문에 필터 로직 내부에서 Spring 의 Bean 을 사용하려면 @Autowired 같은 빈 주입이 아닌, 먼저 Spring WebApplicationContext 객체를 가져와서 그 안에 설정된 Bean 을 하드코딩을 통해 직접 가져와서 사용해야합니다. 다수 Interceptor 와 Filter 의 호출 순서필터와 인터셉터는 상황에 따라 여러개를 지정하여 사용할 수 있습니다. 다수의 필터 혹은 인터셉터 사용시 각각의 호출 순서는 설정에 따라 바꿀 수 있는데, 필터도 사실은 DispatcherServlet 호출 전/후에 호출되는 Servlet 설정이기 때문에 tomcat 에서 관리하는것이라 하더라도 인터셉터와 마찬가지로 Spring 설정을 통해 설정할 수 있습니다. 2개의 필터와 2개의 인터셉터를 사용할때 어떻게 동작하는지 순서를 살펴보기 위해 DispatcherServlet 과 HandlerAdaptor 를 중점적으로 살펴보면 아래와 같습니다. 정확한 순서는 아래 간략하게 요약한 그림으로 알 수 있습니다. doFilter (F1) doFilter (F2) preHandler (I1) preHandler (I2) Controller 요청 처리 postHandler (I2) postHandler (I1) View 렌더링 afterCompletion (I2) afterCompletion (I1) doFilter (F2) doFilter (F1) 웹 서버에서 웹 어플리케이션, 웹 서버와 웹 어플리케이션을 연결하기 위한 CGI 의 예로 Servlet 그리고 Container 를 알아보고, Spring Container 와 Filter, Interceptor 의 차이 그리고 실행 순서에 대해 알아보았습니다. Spring 을 공부하시거나 사용하시는 다른 개발자 분들에게 본 글이 도움이 되었길 바랍니다. 참조한 글들도 좋은 글들이니 시간이 되시면 한번씩 훑어보시는걸 추천드립니다. 출처: Spring 동작 원리 #1:https://asfirstalways.tistory.com/334 Spring 동작 원리 #2:https://devpad.tistory.com/24 Spring 동작 원리 #3:https://taes-k.github.io/2020/02/16/servlet-container-spring-container/ Tomcat 이 Spring 호출하는 방법:http://www.deroneriksson.com/tutorial-categories/java/spring/introduction-to-the-spring-framework Java Servlet:https://mangkyu.tistory.com/14 Web Server, Web Application 차이:https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html Spring DispatcherServlet 동작 원리 #1:https://jess-m.tistory.com/15 Spring DispatcherServlet 동작 원리 #2:https://dynaticy.tistory.com/entry/Spring-MVC-Dispatcher-Servlet-%EB%82%B4%EB%B6%80-%EC%B2%98%EB%A6%AC-%EA%B3%BC%EC%A0%95-%EB%B6%84%EC%84%9D Spring web.xml 설명 #1:https://sphere-sryn.tistory.com/entry/%EC%8A%A4%ED%94%84%EB%A7%81%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8%EC%9D%98-%EA%B0%80%EC%9E%A5-%EA%B8%B0%EB%B3%B8%EC%84%A4%EC%A0%95-%EB%B6%80%EB%B6%84%EC%9D%B8-webxml%EC%97%90-%EB%8C%80%ED%95%98%EC%97%AC-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90 Spring web.xml 설명 #2:https://gmlwjd9405.github.io/2018/10/29/web-application-structure.html Spring 2개 타입의 ApplicationContext:https://jaehun2841.github.io/2018/10/21/2018-10-21-spring-context/#web-application-context Servlet Container &amp; Spring Container:https://velog.io/@16616516/%EC%84%9C%EB%B8%94%EB%A6%BF-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81-%EC%BB%A8%ED%85%8C%EC%9D%B4%EB%84%88 Spring MVC 코드 기반 동작 원리:https://galid1.tistory.com/526","link":"/2021/02/14/a-tutorial-for-spring-mvc-and-security/"},{"title":"Docker 간단하게 살펴보는 기본 개념","text":"왜 Docker 를 사용하는가?하나의 서버에 다양한 Application 들을 구동시키려면 여러 VM 들을 올려놓고 각 Application 마다 VM 을 할당해주는 방법도 있지만, Docker 는 각 Application 을 VM 보다 가벼운 Container 단위로 패키징 및 관리를 가능하게 합니다. Container 는 무엇인가?VM vs ‘Container’VM 개념은 단일 Host OS 위에 다수의 Guest OS 를 갖고 각각 Application 을 단일 Guest OS 에 매핑한것인 반면 [ Host OS - [ VM: Guest OS - Libs - App ] ] Container 는 단일 Host OS 위에 다수의 Application 을 바로 구동할 수 있는 VM 보다 가벼운 단위입니다. Host OS 와 Container 사이 포트 포워딩이나 파일시스템(디렉토리) 연동 등은 후술할 Image 설정으로 가능합니다. [ Host OS - [ Container: Libs - App ] ] VM 은 Hypervisor 에 의해 물리적 자원 관리가 된다면 Container 는 Docker 에 의해 논리적으로 자원 분배가 됩니다. VM 은 Hypervisor 에 의한 하드웨어 가상화 Container 는 Docker 에 의한 Host OS 가상화 과거 학부때 데모 실행을 위해 멀티 노드 하둡구성시 사용 경험이 있는 LXC(Linux Container) 개념이 Docker 의 초기 버전의 구현이었다고 합니다만 이후 Docker 는 자체 컨테이너를 사용한다고 합니다. Image and ‘Container’Docker 를 처음 접하며 명확히 구별하지 못했던 개념이 있습니다. ‘Image’와 ‘Container’입니다. Image 는 VM 에서의 개념과 동일하기에 쉽게 이해하실 수 있습니다. Image 는 Container 구동을 위한 파일시스템과 구동에 필요한 설정들이 모여있는 정적 설정이며, Container 는 위 Image 를 기반으로 실제 구동(Runtime)된 동적 인스턴스라고 보면 됩나다. 왜 Container 를 사용하는가?Application 단위 관리Application 단위로 패키징을 가능하게 함으로써 개발 시 역할/책임(R&amp;R)을 분리할 수 있습니다. 웹 서비스를 개발하면 하나의 서버 인스턴스에 다양한 역할들이 들어있는데, 각각 독립된 Container 로 분리할 수 있습니다. nginx: 정적 페이지 제공 및 SPA 프론트엔드 tomcat: 프론트엔드에 제공될 API 서버 logstash: nginx, tomcat 에서 발생하는 log 들을 log 적재 서버에 전송 온콜(서비스 상태 추적): nginx, tomcat 에서 발생하는 오류 로그 및 CPU, memory 등 자원 상태를 상태 관리 서버에 전송 성능 측정(예, pinpoint): tomcat 에서 타 서버들의 API 콜에 대한 횟수, 지연시간 등을 성능 관리 서버에 전송 즉, 위 예시와 같이 하나의 서버 인스턴스에 총 5개의 Container 가 작동될 수 있습니다. 만약 프론트엔드에 제공할 API 서버뿐만 아니라 외부에서 직접 호출할 수 있는 API 서버를 추가하고싶다면 tomcat 컨테이너를 하나 더 추가하여 총 2개의 tomcat 을 하나의 서버 인스턴스에 두고 사용할 수 있습니다. Java 기반 tomcat 을 Python 기반 django 로 교체할 수 도 있습니다. 프론트엔드를 제공하는 nginx 서버는 그대로 있으면서 API 서버만 교체된것이죠. 각 Application 을 레고 블럭처럼 관리하는건 배포에도 큰 이점이 있습니다. 단지 하나의 컨테이너 버전만 업데이트하고싶다면 해당 컨테이너의 이미지만 다시 받아서 재배포를 진행하면 됩니다. 각 컨테이너마다 버전 관리를 따로 할 수 있는것이죠. 레고 블럭처럼 Application 들을 관리할 수 있다는 장점은 VM 도 갖고있지만, 그보다 더 Container 를 선호하는 이유는 가상화의 레벨이 상위 레벨인 만큼 가볍고(Container = lightweight VM), 위에 설명했듯이 버전 및 배포관리가 이미지로 관리되므로 (1) 이미지 설정과 (2) 배포가 구분되어있어 과정의 자동화가 쉽기 때문입니다. 성능 측면에서도 Container 간 IO 및 네트워크 처리에 있어서 빠르기도 합니다.^1 가상화의 레벨이 로우 레벨인 VM 은 보안 측면에서의 캡슐화가 Container 보다 더 뛰어나다고 하지만, 현재 기술에서는 둘간 얼마나 큰 차이가 있을지 궁금하군요. 이처럼 Docker 로는 Application 이 구동될 환경과 구동할 이미지를 설정합니다. Application 각각의 자체 설정은 docker 와 별개로 프로젝트 내부에 설정해놓으면 됩니다. 책임 분리인 셈입니다. Docker 용어(구성요소) Registry = Images storage Image 들을 저장헤놓는 중앙 저장소 일반적으로 배포 파이프라인을 구성하면 최신 소스를 통해 Docker Engine 으로 생성한 tomcat/nginx 이미지를 Registry 에 올린뒤, 해당 이미지로 최종 서버 배포를 진행합니다. 기본 Docker Hub 서버 혹은 회사/개인용 Docker Hub 서버를 만들어서 사용하거나 Amazon AWS 에서 제공하는 ECR(AWS EC2 Continaer Registry)를 사용할 수도 있습니다. Image 전에 설명했듯 Container 동작을 위한 파일시스템과 구동에 필요한 설정들이 모여있는 정적 설정입니다. Image 는 RO(Read-Only) 파일시스템의 집합^2입니다. 좀 더 상세한 파일시스템 구조는 다음을 참조^3하세요. Container 위 Image 기반으로 실제 구동(Runtime)된 동적 인스턴스 Application/Service = Containers on One host 이를 위해 Docker Compose 를 사용하여 하나의 호스트 머신에서 Containers 를 관리할 수 있습니다. Orchestration = Containers on Multiple hosts(Systems, MSA) 이를 위해 Docker Swarm 를 사용하여 다수의 호스트 머신에서 Containers 를 관리할 수 있습니다. Docker Engine(1) Image 생성 및 (2) Container 구동 모두를 담당하는 엔진^4이며 구성은 아래와 같습니다. 컨테이너 및 이미지 생성을 위한 유저의 입력을 받는 Docker CLI 컨테이너 구동을 위한 Docker Daemon Image 생성Container 는 Image 기반으로 구동되기때문에 원하는 Container 구동에 앞서 원하는 Image 를 먼저 만들어야합니다. 이미지 생성에서 최종 컨테이너 구동까지는 세 절차로 이뤄집니다. Dockerfile - Dockerfile 작성 Dockerfile 로 원하는 Image 생성에 대한 설정(생성 규칙)을 여러 명령어로 작성합니다. 본 설정을 기반으로 이미지를 생성하고 생성된 이미지를 갖고 추후 컨테이너로 구동하게됩니다. 아래는 간단한 명령어 모음입니다. FROM: 기본 베이스 이미지를 정의합니다. 가져올 해당 이미지 URL 을 적으면 됩니다.ENV: 이미지 내 환경변수를 설정합니다. 리눅스 터미널에서 SET_VALUE=3 &amp; echo $SET_VALUE 를 생각하면됩니다. RUN: 실행할 Shell 명령어를 명시하면 이미지 빌드 시점에서 해당 명령어를 수행합니다.CMD: 실행할 Shell 명령어를 명시하면 이미지 빌드 완료 뒤 컨테이너가 정상 실행되었을때 해당 명령어를 수행합니다. EXPOSE: 외부에 열고싶은 Port 를 설정합니다. Container 포트와 실제 Host 에서 노출할 포트를 연결합니다.WORKDIF, ENTRYPOINT: RUN/CMD 로 명시한 Shell 을 실행할 디렉토리 위치를 지정합니다.ADD, COPY: 호스트의 디렉토리나 파일을 이미지에 커밋합니다.VOLUME: 호스트의 디렉토리나 파일을 이미지에 커밋하지 않고 컨테이너 디렉토리에 연결합니다. … 더 많은 명령어 및 상세 설명은 공식 Docker 문서를 참조하세요. Build (docker build) - 이미지 생성 docker build 명령어를 실행하면 가장 먼저, 작성되어있는 Dockerfile 를 Docker Daemon 에게 전달합니다. 그 후 Dockerfile 스크립트 내 매 명령어마다 실행하기 위한 컨테이너를 구동하고, 명령어가 성공적으로 수행된다면 해당 스냡샷으로 이미지를 생성합니다. 아래에서 예시로 살펴볼 docker build 수행 로그를 보면 Docker 는 Dockerfile 내 각 명령어가 실행되는 컨테이너의 ID와 실행이 끝난다면 실행완료된 컨테이너의 스냅샷으로 생성한 이미지 ID 이 둘을 반환하는걸 알 수 있습니다. 만약에 명령어 수행중에 실패하게 된다면 해당 명령어가 실행되는 컨테이너 ID에 쉘을 통해 접근하여 로그를 확인할 수 있습니다. 이처럼 중간에 반환되는 컨테이너 ID 를 통해 docker build 디버깅이 가능합니다. 그렇다면 Dockerfile 스크립트의 마지막 라인이 실행 완료된 컨테이너의 스냅샷이 최종적으로 우리가 생성할 이미지가 되는것입니다. 2.1. 빌드의 시작은 Dockerfile 를 Docker Daemon 에 전달하면서 시작됩니다. Docker Daemon 은 Dockerfile 에서 FROM 명령어에 명시된 새로 생성할 이미지의 기반이 될 베이스 이미지를 가져옵니다. 1234567$ docker build .Sending build context to Docker daemon 10240 bytesStep 1/3 : FROM base-image:1.7.2Pulling repository base-image:1.7.2 ---&gt; e9aa60c60128/1.000 MB (100%) endpoint: https://my-own.docker-registry.com/v1/ 개인 Docker Registry 인 https://my-own.docker-registry.com/v1 에서 base-image:1.7.2 이미지를 가져왔습니다. 마지막 라인에 e9aa60c60128는 다운받은 베이스 이미지에 Docker 가 할당한 ID 입니다. 다음으로 수행될 명령어는 이 이미지 기반으로 중간 이미지를 만듭니다. 2.2. 그 다음 명령어는 이전에 생성된 중간 이미지를 다시 컨테이너로 구동하여, 명령어들을 수행한 뒤 스냅샷을 이미지로 반환합니다. 1234Step 2/3 : WORKDIR /instance ---&gt; Running in 9c9e81692ae9Removing intermediate container 9c9e81692ae9 ---&gt; b35f4035db3f 바로 이전에 수행한 FROM 명령어의 결과로 e9aa60c60128 중간 이미지가 생성되었습니다. 본 이미지로 새 컨테이너 9c9e81692ae9 를 구동하였고, 그 내부에서 WORKDIR /instance 명령어를 수행한뒤, 수행 완료된 컨테이너를 내리고 그 스냅샷을 b35f4035db3f 이미지로 반환한것을 볼 수 있습니다. 2.3. 2.2.와 동일합니다. 단, Dockerfile 내 모든 Step 을 마쳤으므로 마지막으로 생성한 스냅샷 이미지가 우리가 최종적으로 얻는 이미지가 됩니다. 123456Step 3/3 : CMD echo Hello world ---&gt; Running in 02071fceb21bRemoving intermediate container 02071fceb21b ---&gt; f52f38b7823eSuccessfully built f52f38b7823e 우리가 얻는 최종 이미지명(ID)을 f52f38b7823e가 아닌 원하는 이름을 붙여주고 싶다면 tag 옵션을 통해 이름을 붙여줄 수 있습니다. 예를 들면 base-image:1.7.2 로 새 이미지를 만들었으니 custom-image:1.7.2 로 이름지어볼 수 있습니다. 2.4. Push (docker push) - 이렇게 만든 이미지를 Docker Registry 에 저장합니다. Container 구동생성된 최종 Image 로 Docker Daemon 위에서 Container 구동합니다. 1. Pull (docker pull) - 컨테이너를 구동하기 위해 저정된 이미지를 가져옵니다. 2. Execute (docker run) - 가져온 이미지로 컨테이너를 구동합니다. Docker 이미지 설정 예시상품 정보를 저장/조회하는 서비스를 제공하기 위해 프론트엔드 서버는 nginx(react.js) 로 백엔드 서버는 tomcat(java) 으로 서비스를 제공하려고합니다. 두 Application 들을 각각 Container 로 총 두 개의 Container 를 하나의 AWS EC2 서버 인스턴스에서 구동하려합니다. nginx먼저 nginx image 설정을 보겠습니다. nginx 구동은 쉘 스크립트를 실행하게되는데 직접 만든 replace-hosts-and-run.sh 쉘을 이미지에 주입해서 알맞은 환경변수와 함께 수행하여 최종적으로 nginx 서버를 띄우는것을 목표로 하겠습니다. 1234567891011121314151617181920# 1. 기본 베이스 이미지를 가져옵니다. 프론트엔드 서버용 nginx 기본 이미지를 받습니다.FROM http://docker-hub.aaronryu.com/nginx:1.8.0# 2. nginx 웹 서버에서 다국어 지원을 위한 gettext 를 설치합니다.RUN apk --no-cache add gettext# 3. 현재 프로젝트 디렉토리 중 files/, build/, 쉘 스크립트를 이미지 내 지정한 디렉토리에 추가/붙여넣습니다.ADD files/ /instance/program/nginx/confADD build/ /instance/service/webroot/uiADD replace-hosts-and-run.sh /instance/program/nginx/replace-hosts-and-run.sh# 4. 위 쉘 스크립트(replace-hosts-and-run.sh)에서 사용할 호스트 명 환경변수를 설정합니다.ENV NGINX_HOST aaronryu.frontend.com# 5. 로깅 등을 위해 nginx 컨테이너 내 아래 디렉토리를 호스트의 디렉토리에 연결합니다.# (Container 가 아래 디렉토리에 하는 작업은 실제 호스트의 디렉토리에 반영됩니다.)VOLUME [&quot;/instance/logs/nginx&quot;]# 6. '이미지 완료 뒤'에 아까 복사해둔 아래 쉘 스크립트를 위 환경변수와 함께 실행(CMD)합니다.CMD /instance/program/nginx/replace-hosts-and-run.sh tomcatnginx 서버의 SPA 정적 페이지에서 조회 및 저장을 위해서는 그에 맞는 API 가 필요합니다. 이 API 들을 제공하기위한 tomcat 서버를 구동하겠습니다. Java 서버이기에 JVM 에 대한 설정을 추가하고, 외부에서 본 서버의 상태를 조회하기 위해 12345 포트를 열어두겠습니다. 123456789101112131415161718192021# 1. 기본 베이스 이미지를 가져옵니다. 백엔드 서버용 tomcat 기본 이미지를 받습니다.FROM http://docker-hub.aaronryu.com/tomcat:8.0.0-jdk8# 2. tomcat 의 구현은 spring boot 로 되어있습니다. 구동 시 production 프로파일 옵션을 주겠습니다.ENV SPRING_PROFILE production# 3. tomcat 은 Java 기반 서버이기에 JVM 메모리 옵션을 추가합니다.ENV JVM_MEMORY -Xms2g -Xmx2g -XX:PermSize=512m -XX:MAxPermSize=512m# 4. 현재 프로젝트 디렉토리내 저장되어있는 setenv.sh 을 이미지 내 tomcat 실행 쉘 파일에 추가/붙여넣습니다.ADD setenv.sh ${CATALINA_HOME}/bin/setenv.sh# 5. 현재 프로젝트 빌드가 완료된 뒤 생성된 war 파일을 모두 tomcat 실행 webapps 에 추가/붙여넣습니다.COPY build/libs/*.war &quot;${CATALINA_HOME}&quot; /webapps/ROOT.war# 6. 설정한 tomcat 서버 포트 8080 을 호스트의 12345 포트에 연결하여 외부에 노출합니다.EXPOSE 8080 12345# 7. 로깅 등을 위해 tomcat 컨테이너 내 아래 디렉토리들을 호스트의 디렉토리에 연결합니다.# (Container 가 아래 디렉토리에 하는 작업은 실제 호스트의 디렉토리에 반영됩니다.)VOLUME [&quot;/instance/logs/tomcat&quot;, &quot;/instance/logs/tomcat/catalina_log&quot;, &quot;/instance/logs/tomcat/gc&quot;] 위 예시로 살펴본 각각의 Dockerfile 은 각각 nginx 와 tomcat 프로젝트 내에 위치하게 됩니다. 이 두 컨테이너를 하나의 인스턴스에 동시에 띄우기 위해서는 Docker Compose 설정으로(예, .yml) 설정으로 각 컨테이너의 이미지를 묶어서 명시하면 됩니다. https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd https://docs.docker.com/storage/storagedriver/#images-and-layers https://rampart81.github.io/post/docker_image/ https://www.quora.com/What-is-the-difference-between-the-Docker-Engine-and-Docker-Daemon https://www.joyfulbikeshedding.com/blog/2019-08-27-debugging-docker-builds.html","link":"/2020/08/20/an-introduction-to-docker/"},{"title":"Javascript 엔진 개요 및 실행 과정으로 살펴보는 Hoisting 과 Closure","text":"자바스크립트자바스크립트는 웹 페이지의 세 요소중 하나입니다. HTML: 웹 페이지(문서) 포맷을 정의하는 마크업 언어 CSS: 웹 페이지(문서)의 디자인 요소에 대한 언어 Javascript: 웹 페이지(문서)와 사용자 사이의 interaction 이벤트에 대한 모든 처리 자바스크립트는 일반 프로그래밍 언어와 동일하게 함수 선언 및 호출를 통해 바로 동기적(Synchronous)으로 실행할수도 있고, 콜백을 통해 특정 이벤트 시점에 비동기적(Synchronous)으로 수행하게 만들수도 있습니다. 실행을 위해서는 개발자가 작성한 자바스크립트 언어를 실행 가능한 언어로 변형하여 실행, 실행 순서 및 메모리를 관리하는 엔진이 필요합니다. 하나의 브라우저는 HTML/CSS 엔진과 자바스크립트 엔진으로 구성되어있습니다. 흔히 알고 있는 Chrome, Internet Exploerer, Safari 등 다양한 웹 브라우저마다 각자 자신들만의 HTML/CSS/Javascript 엔진를 갖고 있습니다. 자바스크립트 엔진 중 유명한것이라면 Chrome 브라우저와 node.js 에서 사용되고있는 V8 가 있습니다. 앞으로 설명할 자바스크립트 엔진 및 런타임^9은 이 V8 기준으로 설명할것입니다. 잠깐 앞으로 계속 언급될 자바스크립트 엔진과 자바스크립트 런타임 용어를 확실히 짚고 넘어가겠습니다. 더 상세한 설명은 소제목 자바스크립트 엔진 및 런타임 에서 하겠습니다. 자바스크립트 런타임은 자바스크립트 동작을 위해 필요로 하는 자바스크립트 엔진을 포함한 API 및 기능의 집합입니다.자바스크립트 엔진은 좁은 의미로 자바스크립트 인터프리팅 역할을 전담하는것으로 Java 의 JVM 으로 이해하면 됩니다. 예를 들면 V8 자바스크립트 엔진기반의 자바스크립트 런타임으로 우리가 사용하는 Chrome 이 동작되는것입니다. 자바스크립트 = 인터프리트 언어 자바스크립트는 스크립트 언어이자 엔진을 통해 처리되는 인터프리트 언어입니다. 다만, 컴파일 과정을 갖고 있습니다. 자바스크립트 엔진은 일반적인 쉘 스크립트가 한 라인씩 바로 실행되는 인터프리트 언어와는 조금 다른 실행 구조를 갖고있습니다. 먼저, 실행할 전체 함수를 실행 직전에 간단히 변수 및 함수 선언들만 스캔하는 (A) JIT 컴파일 과정을 거쳐, 그 후 (B) 수행 과정의 사이클로 실행^5됩니다. 여기서 (1) JIT 컴파일 과정은 실제 우리들이 흔히 알고있는 C++, Java 와 같은 컴파일 언어에서 중간코드를 만드는 AOT(Ahead-of-Time) 컴파일 과정과는 다릅니다.^7 자바스크립트를 인터프리트 언어라고 알고있었는데 좀 놀랍죠. 이렇게 자바스크립트 엔진에 단순히 컴파일 과정이 있다는 사실만으로 자바스크립트를 컴파일 언어로 언급하기도 합니다만 엄연히 기존 컴파일 언어의 정의와 다르고^8, 자바스크립트 엔진은 함수 실행 시점에 컴파일을 진행하므로 인터프리트 언어입니다.^7 자바스크립트 엔진은 (A) JIT 컴파일 과정과 (B) 수행 과정 이렇게 두 개로 나뉩니다.결론적으로 자바스크립트는 컴파일 과정을 가진 인터프리트 언어로 요약할 수 있지 않을까합니다. 자바스크립트 엔진 및 런타임자바스크립트 런타임은 크게 2 개의 구성요소로 나눠질 수 있고, 개별적으로는 5 개로 나누어 볼 수 있습니다. 자바스크립트 엔진 = (1) Heap, (2) Stack(Call stack) (3) Web APIs, (4) Callback queue, (5) Event loop 자바스크립트 엔진은 (1) Heap 그리고 (2) Stack 만을 의미하며 싱글 스레드로 모든 코드를 수행합니다.. 자바스크립트의 비동기를 학습할때 배우는 (3) Web APIs, (4) Callback queue, (5) Event loop들은 정확히는 자바스크립트 엔진의 구성요소가 아닙니다. 자바스크립트 엔진이 싱글 스레드로 모든 코드를 수행한다면 동기적 실행밖에 안될텐데 어떻게 비동기를 지원한다는 것일까요? 비동기 지원을 위해 바로 자바스크립트 런타임에서 (3), (4), (5) 세 요소를 추가한것입니다. 자바스크립트 엔진의 (2) Stack 은 일반 프로그램 언어들의 Stack 과는 다른데요. 타 프로그램 언어들은 함수 실행에 따라 Call stack 에 각 로컬 함수들의 변수 등의 Context 정보들을 다 같이 쌓습니다. 로컬 함수에만 국한된 정보들을 갖는다는 이유로 Context 를 Scope 라고도 부릅니다. 반면, 자바스크립트 엔진도 Call stack 에 함수 호출 순서를 적재합니다만, 변수 및 함수 선언과 할당 정보는 Heap 에 따로 저장히여 Call Stack 에는 본 Heap 에 대한 포인터만 갖고 있습니다. 구체적으로 정리하면 아래와 같습니다. 자바스크립트 엔진 (1) Heap: 각 함수 별 선언 및 할당되는 모든 변수 및 함수를 적재하는 메모리 영역 (2) Stack(Call Stack): 함수 실행 순서에 맞게 위 Heap 에 대한 포인터 적재 및 실행 비동기 지원 (3) Web APIs: 기본 자바스크립트에 없는 DOM, ajax, setTimeout 등의 라이브러리 함수들^10. 브라우저나 OS 등에서 C++ 처럼 다양한 언어로 구현되어 제공 (4) Callback Queue: 위 Web APIs 에서 발생한 콜백 함수들이 차곡차곡 여기에 적재 (5) Event Loop: 위 Callback Queue에 적재된 함수를 Stack 로 하나씩 옮겨서 실행되도록 하는 스레드 자바스크립트 엔진 실행 과정 자바스크립트 엔진은 (A) JIT 컴파일 과정과 (B) 수행 과정 이렇게 두 개로 나뉩니다. (A) Compilation Phase매 함수 실행 시 (자바스크립트 첫 실행 함수는 main() 입니다.) ASTs 생성 및 바이트코드로 변경하고 JIT 컴파일 기법(바이트코드 캐싱을 통해 불필요한 컴파일 시간을 줄이는것)을 위해 프로파일러로 함수 호출 횟수를 저장/추적합니다. 우리가 기억하면 될 것은 본 과정에서 변수의 ‘선언’(선언과 할당 중) 그리고 함수의 ‘선언’**을 **Heap 에 적재한다는것입니다. 자바스크립트 변수의 ‘선언’**은 **var a 입니다. (a = 5 는 ‘할당(Assignment)’입니다.) 자바스크립트 함수의 ‘선언’**은 **function a() 입니다. Compilation Phase에선 변수 및 함수의 ‘선언(Declaration)’**만 추출하여 **Heap 에 적재합니다.변수와 함수의 선언을 자바스크립트 실행 이전에 컴파일로 저장하여 실제 실행 시 변수와 함수 선언 여부를 검색합니다. 예를 들어 아래 자바스크립트 파일을 처음 실행하게 되면 파일 전체에 컴파일 과정을 수행하게됩니다. 1234567891011121314151617181920var a = 2;b = 1;function f(z) { b = 3; c = 4; var d = 6; e = 1; function g() { var e = 0; d = 3*d; return d; } return g(); var e;}f(1); 자바스크립트 첫 실행을 위한 main() 함수의 Global Scope (window) 영역을 Heap 에 생성합니다.123# Global Scope (window)- - 변수 선언 var a을 찾아서 Global Scope (window) 영역에 a 를 적재합니다. 변수 할당 b = 1은 할당이므로 본 영역에 b 를 적재하지 않습니다.123# Global Scope (window)- a =- 함수 선언 function f(z)**을 찾아서 **Global Scope (window) 영역에 f 를 적재합니다. 함수 적재시엔 f 함수의 바이트코드(blob)에 대한 포인터값을 함께 적재합니다.123# Global Scope (window)- a =- f = a pointer for f functions bytecode 자바스크립트 코드를 첫번째 라인에서 20번째 라인까지 컴파일 과정을 마치면 Heap 구성은 마지막과 같습니다. (B) Execution Phase변수의 ‘할당(Assignment)’**과 실제 **함수를 호출 및 실행합니다. 자바스크립트 변수의 ‘할당’**은 **a = 1 입니다.a = 1 할당 시 이전 컴파일 과정에서 선언된 변수 a 가 있는지 확인합니다.만약 존재하지 않는다면 a 변수 ‘선언’과 동시에 ‘할당’하여 적재합니다. 자바스크립트 함수의 ‘호출 및 실행’**은 **a() 입니다.a() 실행 시 첫번째로, 이전 컴파일 과정에서 선언된 함수 a() 가 있는지 확인합니다.a() 실행 시 두번째로, Heap 에는 새 함수를 위한 Local Execution Scope 영역을 생성하고, Call Stack 에는 생성된 Heap 에 대한 포인터를 갖는 함수 a() 정보를 적재합니다.a() 실행 시 마지막으로, 컴파일을 수행하여 본 함수 내 변수 및 함수를 위 Local Execution Scope 영역에 적재합니다. Execution Phase에선 변수의 ‘할당(Assignment)’**값들을 **Heap 에 적재하고 함수는 호출 및 실행합니다. 매 함수 호출때마다 스택에 함수 내 변수 및 함수를 같이 적재하는 스택 베이스 언어과 달리 자바스크립트는 스택에는 함수 호출 순서와 실제 변수 및 함수 정보들은 Heap 에 대한 포인터를 갖습니다. Heap 에 함수 a() 를 위한 Local Execution Scope 는 a() 함수가 호출되기 이전에 Heap 에 존재했던 **Global Scope (window)**에 대한 포인터를 갖고있어서, 엔진 내에서 아래와 같은 처리가 가능합니다. a() 함수 내에서 a = 1 변수 할당 시 먼저 Local Execution Scope 에 a 변수의 선언을 찾고,존재하지 않는다면 이전 Global Scope 로 돌아가 검색할 수 있습니다. a() 함수 실행이 끝나게 되면 Call Stack 을 통해 현재 Heap 영역을 Global Scope 로 다시 되돌립니다. 위에서 예시로 살펴본 자바스크립트 파일에 컴파일 과정을 마친 뒤 수행 과정은 아래와 같이 진행됩니다. 컴파일 이후 아래의 Heap 을 갖고 다시 자바스크립트 파일 코드의 맨 첫번째 라인에서 실행이 시작됩니다.123# Global Scope (window)- a =- f = a pointer for f functions bytecode 변수 할당 a = 2을 찾아서 Global Scope (window) 영역에 변수 a 존재 여부를 확인합니다. 변수 a 가 존재하므로 해당 a 에 2 를 할당합니다.123# Global Scope (window)- a = 2- f = a pointer for f functions bytecode 변수 할당 b = 1을 찾아서 Global Scope (window) 영역에 변수 b 존재 여부를 확인합니다. 변수 b 가 선언되어있지 않아 b 선언 및 1 을 할당합니다.1234# Global Scope (window)- a = 2- f = a pointer for f functions bytecode- b = 1 함수 호출 f(1)**을 찾아서 **Global Scope (window)**영역에서 **f() 선언 여부를 확인합니다. 함수 f() blob 컴파일 및 수행을 위해 Heap 에 새 Local Execution Scope 영역을 생성합니다.123456789# Global Scope (window)- a = 2- f = a pointer for f functions bytecode- b = 1# Local Execution Scope for f()- (hidden) A pointer for previous scope (= Global Scope (window))- - f(1) 함수 실행 시 새로이 생성된 Local Execution Scope에 다시 Compilation Phase 과정을 통해 변수와 함수를 적재하게 되고 Execution Phase 과정을 수행하게 됩니다. 또 f(1) 함수 내부에 또 다른 함수가 있다면 이 과정을 계속해서 재귀적으로 반복합니다. 함수 f() 의 Compilation Phase 과정을 마치면 아래와 같이 됩니다.12345678910# Global Scope (window)- a = 2- f = a pointer for f functions bytecode- b = 1# Local Execution Scope for function f()- (hidden) a pointer for previous scope (= Global Scope (window))- z = - d = - e = 함수 f() 의 Execution Phase 과정을 마치면 함수 f() 내 변수 할당 및 함수 g() 의 Scope 가 생성되게 됩니다.123456789101112131415# Global Scope (window)- a = 2- f = a pointer for f functions bytecode- b = 3# Local Execution Scope for function f()- (hidden) a pointer for previous scope (= Global Scope (window))- z = 1- d = 6- e = 1- c = 4# Local Execution Scope for function g()- (hidden) a pointer for previous scope (= Local Execution Scope for function f())- e = 자바스크립트 엔진 특성 Function-level scope: var자바스크립트 실행은 결국 함수에 따라 (A) 컴파일, (B) 수행이 재귀적으로 이뤄집니다. 처음 자바스크립트 실행 시 main() 함수에 대한 (A), (B) 처리를 시작으로 내부에 새로운 함수 호출이 일어나면 새 함수에 대한 (A), (B) 처리 그리고 또 내부 함수 호출이 있다면 그 함수에 대한 (A), (B) … 이런식으로 처리를 반복하게 됩니다. 특정 함수 내 변수 var 의 선언은 본 함수 (A) 컴파일에 정의되기 때문에 변수 var 의 scope는 function-level이 됩니다. if, for 문과 같은 block-level({}) 단위 변수를 위해 ES6 스펙에선 Block-level scope: const, let이 새로 소개되었습니다. Scope Chain자바스크립트 엔진 실행 과정에서 살펴보았듯 특정 함수에 대한 (B) 수행 단계에서 변수 할당 시 본 함수의 Heap 영역에 변수 선언이 되어있는지 먼저 검사하게 됩니다. 만약 본 함수 내 변수가 선언되어있지 않았다면 해당 함수의 Heap 에서는 변수 선언을 찾을 수 없게됩니다. 이때 해당 함수가 호출되기 이전의 함수로 (hidden) A pointer for previous scope 를 통해 올라가면서 해당 함수 Heap Scope 에 변수가 선언되었는지 확인합니다. 어떠한 함수에서도 변수 선언이 되어있지 않다면 가장 처음에 호출된 main() 함수까지 올라가면서 검색하게 됩니다. 함수 호출 스택에 따라 가장 처음의 main() 함수까지 각 함수 Heap Scope 에 변수 선언 존재여부를 연쇄적으로 Chaining 하며 찾기때문에 이를 Scope Chain 이라고 부릅니다. Variable Hoisting(A) 컴파일 단계에서 변수를 선언을 먼저하고, 그 다음 (B) 수행 단계에서 변수를 할당하기 때문에 같은 function-level 이라면 아래와 같이 변수 선언과 할당을 나누어서 하더라도 자바스크립트 엔진에서는 변수 선언이 먼저 된 것으로 처리됩니다. 12a = 10var a; 12# Global Scope (window)- a = 10 위 예시처럼 var a 선언이 같은 function-level 내에서 최상단에 ‘말려올라간것’처럼 수행되기도 하지만, 만약 함수 내 변수가 선언되어있지 않았다면 Scope Chain 을 통해 main() 함수까지 올라가면서 변수 선언을 찾습니다. 최종적으로 main() 함수 Heap Scope 에도 선언되어있지 않다면 main() 함수 영역에 변수를 선언해주게 됩니다. main() 에서 호출한 어떤 함수이든 Scope Chain 을 통해 방금 선언해준 변수를 바라볼테니 이는 전역 변수인것입니다. (main() 의 Heap Scope 영역 명칭은 Global Scope (window)**이기도 합니다.) 특정 함수내에 변수를 할당하였지만 본 변수는 어느 함수에도 존재하지 않는 변수이기에 **main() 함수까지 ‘말려올라가서’ 전역 변수를 선언한것이 됩니다. 변수 선언이 ‘말려올라갔다’는 의미에서 이 모든 경우를 Variable Hoisting 이라고 표현합니다. Variable Shadowing특정 함수의 Heap Scope 에 변수 선언이 되어있다면 해당 변수에 대한 변수 할당은 현재 함수 Heap Scope 에 선언되어있는 변수에 대입됩니다. 만약에 해당 함수를 호출하는 이전 함수에 해당 변수와 똑같은 명칭의 변수가 선언되어있다고 할지라도 현재 함수 Heap Scope 에 이미 존재하기때문에 이전 함수의 Heap Scope 까지 Scope Chain 할 필요가 없습니다. 이전 함수에 같은 명칭의 변수가 있다고하더라도 현재 함수는 그 존재를 알 수도 알 필요도 없기 때문에 이를 Variable Shadowing 이라 부릅니다. Garbage Collection함수 직접 수행이 끝나면 Stack 에서 수행 완료된 함수의 정보를 없애면서 Heap 메모리 내 수행 완료된 함수의 Heap Scope 도 없애게 됩니다. 메모리 청소의 의미로 Garbage Collection 이라고 부릅니다. 전체 자바스크립트 파일 실행이 끝나게되면 가장 마지막으로 main() 함수의 Global Scope(Window) 도 사라지게 됩니다. Reference Count 를 통한 Garbage Collection 를 하는 스위프트 언어도 있지만 자바스크립트는 단순히 함수(포인터)의 Reachability 를 기반으로 Garbage Collection 를 수행합니다. 함수 직접 수행이 아닌 함수 수행을 변수에 할당한 경우엔 함수 수행이 끝났다고 하더라도 할당된 변수로 또 함수 수행이 가능하기 때문에 본 함수에 대한 Garbage Collection 를 안하는 경우가 존재하는데 바로 아래서 설명할 Closure 개념입니다. Closure자바스크립트 엔진 실행 설명시 다뤘던 예제에서 function f 를 바로 실행하지 않고 var myFunction 를 선언하여 그에 할당해보았습니다. 123456789101112131415161718192021var a = 2;b = 1;function f(z) { b = 3; c = 4; var d = 6; e = 1; function g() { var e = 0; d = 3*d; return d; } return g; var e;}var myFunction = f(1); // 새로 추가된 코드myFunction(); 함수 호출을 변수에 할당하게 되면 함수의 호출은 일회성으로 호출이 끝나면 사라지는것이 아니라 myFunction 이란 변수를 통해서 계속해서 반복 호출이 가능하기 때문에 f 함수 호출을 위해 생성된 f 함수의 Heap Scope 는 지워질 수 없습니다. 조금 쉽게 생각하자면 f 함수 Heap Scope 에는 f 함수 수행을 위해 넘긴 파라미터 값 1 도 들고있기 때문에 Heap Scope 를 Garbage Collection 할 수 없는것입니다. 이처럼 함수 호출을 변수에 할당하게 되면 f 함수의 Heap Scope 와 f 를 호출한 함수의 Heap Scope 가 파라미터 1 을 기준으로 강하게 묶여있기 때문에 f 함수 실행이 끝났음에도 불구하고 f 함수의 Heap Scope 가 Garbage Collection 되지 않습니다. Closure 는 함수의 Heap Scope 와 해당 함수를 호출하는 함수의 Heap Scope 를 연결하는것으로, 함수 호출이 끝나더라도 Scope 는 여전히 해당 함수를 호출한 함수의 Scope 에 ‘갇혀있는’ 개념입니다. 1: https://youtu.be/QyUFheng6J02: https://www.quora.com/Is-JavaScript-a-compiled-or-interpreted-programming-language3: https://medium.com/@almog4130/javascript-is-it-compiled-or-interpreted-9779278468fc4: https://blog.usejournal.com/is-javascript-an-interpreted-language-3300afbaf6b85: https://youtu.be/QyUFheng6J0?t=4356: https://dev.to/genta/is-javascript-a-compiled-language-20mf7: https://dev.to/deanchalk/comment/8h328: https://gist.github.com/kad3nce/9230211#compiler-theory9: https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf10: https://developer.mozilla.org/ko/docs/Web/%EC%B0%B8%EC%A1%B0/API11: https://medium.com/@antwan29/browser-and-web-apis-d48c3fd8739","link":"/2020/08/27/how-does-a-javascript-engine-work/"},{"title":"한 장으로 보는 함수형 프로그래밍 - 클로저, 커링, Functor, 모나드","text":"‘함수’형 프로그래밍‘함수’형 프로그래밍은 한 마디로 요약할 수 있습니다. ‘함수’를 1. 변수에 2. 파라미터에 3. 반환값에 사용할 수 있으며, 4. 순수 함수 특성을 갖습니다. ‘함수’는 일급함수(first-class function) 입니다. ‘함수’를 변수에 대입할 수 있습니다. ‘함수’를 파라미터로 넘길 수 있습니다. ‘함수’를 반환할 수 있습니다 ‘함수’는 순수 함수 특성을 갖습니다. 참조 투명성 (No Side-Effects): 외부 상태나 변수, 환경의 영향을 받지 않고,같은 파라미터로 함수를 호출하면 매 항상 같은 결과를 반환합니다. 함수 포인터함수는 값이 아닌 참조인 만큼 함수를 일급함수로 사용하기 위해서는 함수 포인터를 이용해야 합니다. 함수 포인터를 통해 함수를 변수로 사용할 수 있습니다. 함수를 파라미터로 넘기고 싶다면 함수 포인터를 전달하면 가능합니다. 함수를 반환하고 싶으면 반환하려는 함수에 대한 포인터를 반환하면 가능합니다. 1void qsort (void* base, size_t n, size_t size, int (*compare)(const void*,const void*)); 위 C 언어 예를 보면 퀵소트 알고리즘의 마지막 파라미터로 compare 함수 포인터를 넘겨주는걸 볼 수 있습니다. 다만 C 언어에서의 함수는 런타임에 정의된 함수가 아니라 미리 컴파일된 함수는 이유로 일급함수(first-class function)가 아닌 이급함수(second-class function)로 부르자는 의견^3도 있는듯 합니다. 람다 (익명함수)람다는 컴퓨터과학 및 수리논리학에 사용되는 개념으로 현 프로그래밍 함수의 원형에 해당하는 개념입니다. 입력값을 받고 함수 외부에 정의된 자유변수를 활용하여 결과를 반환하는 함수 추상표현법 입니다. 함수를 정의만 할 뿐 수행하지 않는다는 점이 프로그래밍 내에서 함수를 정의를 먼저하는 것^8과 같습니다. 수리논리 개념이자 함수의 원형인만큼 람다는 함수명이 존재하지 않습니다. 이런 이유로 람다를 프로그래밍에서는 익명함수로 부르기도 합니다. 개념이라는 것은 알겠는데 그럼 람다는 언제 왜 사용되는것일까요? 프로그래밍에서는 값을 사용하는 두 가지 방법이 있습니다. 재사용성을 위해 값을 정의 후 변수에 할당하여 변수로 사용하는 방법12let defined: Int = 10print(defined) 일회성 사용을 위해 값을 바로 inline 으로 사용하는 방법1print(10) 함수를 사용하는 방법도 값과 같이 두 가지 방법이 있습니다. 재사용성을 위해 함수를 정의 후 참조로 사용하는 방법1234func defined() -&gt; (Int) { return 10}print(defined) 일회성 사용을 위해 함수를 바로 inline 으로 사용하는 방법1print({ return 10 }) 람다는 변수, 파라미터, 반환값에 함수 포인터를 넘겨준다는 것은 일반 함수 사용과 동일하지만, 함수 정의 시점이 다르기 때문에 함수 이름이 필요없으며 함수의 유효범위가 일회성이라는 장점이 있습니다. 일반 함수는 정의 시 정의 구역 내 전역으로 존재합니다.(어려운 말로 전역 네임스페이스에 소속되는 정적인 구현체^1) 람다는 정의 시 정의 블럭 내 일회성으로 존재합니다. 람다를 통해 함수를 일급함수로 사용 시 미리 정의할 필요없이 inline 으로 함수를 정의하여 바로 사용이 가능해졌습니다. 함수객체객체지향 프로그래밍에서는 함수가 단일 함수로는 존재할 수 없으며 꼭 클래스안에 속해야하는 한계가 있습니다. 함수를 람다로 사용하고싶다면 함수객체를 만들어 객체레벨로 사용해야합니다. 객체지향 프로그래밍에서 람다는 겉으로 보기에는 단일 함수로 존재하는것 같지만, 실제론 이름없는 객체가 단일 함수를 감싸고 있는 ‘함수객체’의 Syntactic Sugar 라고 보시면됩니다. 클로저람다와 클로저 이 둘은 같아보이지만 엄연히 다른 개념^4입니다. 각 정의를 살펴보면 람다는 익명함수를 뜻합니다.함수를 변수, 파라미터, 반환값에 일회성으로 바로 사용하고싶을때 쓰입니다. 클로저는 함수가 정의될 때의 환경(상태)**을 갖는 **함수를 뜻합니다.^5여기서 환경은 클로저가 정의되는 범위(Scope)에 있는 지역변수을 의미합니다. 일반적으로 클로저는 함수 A 내부에서 함수(클로저) C 를 정의하는 방식으로 많이 사용합니다. 함수 A 내에 클로저 C 가 정의된다면 C 는 A 의 변수들을 파라미터로 넘기지 않았음에도 자연적으로 참조하여 사용할 수 있습니다. 이것이 **환경(상태)**입니다. 함수 A 의 변수 와 클로저 C 의 관계를 클래스 A 내 필드와 메서드 C의 관계로 생각하시면 이해가 쉽습니다. 클로저를 함수를 객체처럼 사용하기 위한 방법으로 본다면, 클로저를 사용하는 이유는 객체를 사용하는 이유와 비슷합니다. 클로저 C 가 참조하는 외부 변수를 상태처럼 계속 갖기 때문에 반복 호출하더라도 해당 상태를 계속 활용할 수 있습니다. 외부 변수는 함수 A 범위 내에만 정의되었기 때문에 외부 접근이 불가능합니다. 1234567func query(dbName: String) -&gt; (String) -&gt; (Person) { let instance: DBInstance = DBConfig.getInstance(dbName) // * 클로저 내부 { } 에서 클로저가 정의된 함수 내 존재하는 instance 변수를 사용하였습니다. return { (tableName: String) -&gt; (Person) in return instance.getTable(tableName).getFirst() }} Swift 클로저위에서 살펴보았듯 클로저의 정의가 익명함수는 아니지만, Swift 에서는 클로저가 이름 없이 사용되기 때문에 익명함수이기도 합니다. Swift 의 클로저는 ‘파라미터’와 ‘반환에 해당하는 구문’을 in 으로 구별합니다. Swift 의 클로저는 아래와 같이 원하는 만큼 축약할 수 있습니다. 기본형: 파라미터 타입, 반환 타입을 명시하고 in 이후 함수 구문을 작성합니다.1{ (parameters) -&gt; (return_type) in return /* statements using parameters */ } 축약형: 반환 타입을 암시적으로 결정합니다1{ parameters in return /* statesments using parameters */ } 축약성애자: 반환 타입뿐만 아니라 반환 식의 return 도 없앴습니다.1{ parameters in /* statesments using parameters */ } 변태: 파라미터 타입을 암시적으로 결정합니다. 사용은 파라미터 순으로 $0, $1 로 사용합니다.1{ /* statesments using parameters with $0, $1 ... */ } Trailing Closure: 클로저가 마지막 파라미터로 사용된다면 파라미터에 넣지않고 함수 뒤 클로저 { } 로 바로 명시합니다.12var sorted = sort(names, { $0 &lt; $1 })var sorted = sort(names) { $0 &lt; $1 } 고차함수**’고차함수’**는 일급함수 세 조건 중 두번째 혹은 세번째에 해당하는 함수를 뜻합니다. ‘함수’를 변수에 대입할 수 있습니다. ‘함수’를 파라미터로 받거나 ‘함수’를 반환하는 함수 ‘고차함수’**는 **’함수’를 파라미터로 혹은 반환값으로 사용하는 것을 의미합니다. 함수를 사용하는 함수다보니 **메타적 ‘함수’**라는 의미에서 한 차원 높은 함수, 고차함수라고 명명합니다. 커링**’커링’**은 일급함수 세 조건 중 세번째에 해당하는 함수를 뜻합니다. ‘함수’를 변수에 대입할 수 있습니다. ‘함수’를 파라미터로 넘길 수 있습니다. ‘함수’를 반환하는 함수 커링(Curring)**은 **’함수’가 ‘함수’를 반환하는 것을 의미합니다. 일반적으로 Swift 에서 커링은 함수가 ‘클로저’를 반환하는 방식으로 많이 사용됩니다. 1func curringExample: (a: Int, b: Int, c: Int) -&gt; (Int, Int) -&gt; (Bool) { ... } 위 curringExample 예를 보면 a, b, c 파라미터를 받아 (Int, Int) 두 파라미터를 받아 -&gt; (Bool) 을 반환하는 함수를 반환합니다 Swift 에서 ‘클래스의 객체’**가 **’클래스 객체의 함수’**를 호출하는 방법도 **커링을 사용합니다.^2 12let someInstance = SomeClass()someInstance.someFunction(params: /* parameters */) 위 클래스 객체의 함수는 실제로 아래와 같이 클래스 함수에 객체를 넘겨 수행합니다. 1SomeClass.someFunction(self: someInstance)(params: /* parameters */) 사담으로 Kotlin 의 확장함수도 수신객체타입(클래스)에 대한 함수에 수신객체를 파라미터로 넘기는 형태로 사용됩니다. FunctorFunctor 는 데이터 구조입니다. Functor 개념에 앞서 함수에 대해서 짧게 살펴보겠습니다. 함수 = Mapping함수는 Input A 를 넣으면 Output B 라는 결과가 나오는 것입니다.달리보자면 함수는 Input A -&gt; Output B, 이 둘에 대한 매핑입니다. 데이터 구조 Mapping어떤 데이터 구조 전체에 대해 매핑을 적용한다면, 데이터 구조 내 원소 각각에 대해 매핑을 적용해야합니다.예를 들어 데이터 구조가 리스트라면 0, 1 .. 이터레이팅을 통해 Pull: 각 원소를 꺼내어 Mapping: 매핑을 적용한 후 Push: 결과 원소를 반환하려는 데이터 구조에 넣습니다. 각 원소에 대한 매핑 함수를 적용할 수 있음을 Mappable 로 정의한다면, 예로 살펴본 리스트는 Mappable 데이터 구조라고 정의할 수 있습니다. 위 그림 예는 Int 데이터 구조에서 String 데이터 구조로 각 원소에 대해 stringify 한 Functor 의 예입니다. Functor 정의 Functor 는 Mappable (Mapping 함수를 갖는) 데이터 구조^9입니다.각 원소에 대한 매핑 함수를 적용할 수 있는 데이터 구조라면 Functor 로 부를 수 있습니다. ‘단위 원소’들로 구성된 데이터 구조 각 ‘단위 원소’에서 ‘단위 윈소’로의 Mapping 함수 어떤 1. 데이터 구조든 원하는 연산을 적용하고싶다면 데이터 구조안의 단위 원소가 어떤 타입(T)이고, 2. 단위 원소(T)에 대한 Mapping만 정의하면 됩니다. 1.을 클래스의 프로퍼티, 2.를 클래스의 메서드로 본다면 Functor 를 Function Object, 함수객체로 부르기도 합니다.^10 Functor 는 범주론(Category Theory)**에서 **카테고리에서 동일 카테고리로 사상되는 개념에서 유래했습니다. 데이터 구조에서 동일 데이터 구조로 각 단위 원소들에 대해 Mapping하는것과 개념적으로 동일한 것을 알 수 있습니다. 이처럼 데이터 구조(카테고리)는 바뀌지 않은 채 값만 Mapping 되는 것을 범주론에서는 natural transformation^6 라고 정의합니다. Haskell’s FunctorFunctor 를 찾다보면 하스켈의 Functor 개념을 먼저 접하실텐데 하스켈의 Functor 는 typeclass 로 아래와 같이 정의하며, 데이터 구조 타입을 명시해서 원하는대로 인스턴스화 하여 사용합니다. Swift-like 문법으로 표현해보면 아래로 볼 수 있습니다. Functor (typeclass) Operation(T) -&gt; (R) S (Any Data Structure) Functor 구현 (instantiation) Operation(Int) -&gt; (String) { +1 and Stringfy } List 하스켈에서 Functor 는 데이터 구조 타입(S)**과 **원소(T)에서 원소(R)로의 Mapping 추상 함수를 가진 제네릭(S, T, R) 추상 클래스로 볼 수 있습니다. 하스켈에서 fmap() 이나 map() 함수를 정의할때 Mapping 추상 함수를 정의하고 변환하고자하는 데이터 구조를 주입하면 내부 값만 바뀐 동일한 데이터 구조가 반환됩니다. Java 유저라면 Stream 의 map() 함수를 떠올리시면 이해가 쉽습니다. Stream 이 Mapping 함수를 가질 수 있는, Mappable 데이터 구조에 해당하므로 Functor 라고 부를 수 있고, 그 Mapping 함수는 Stream.map() 에 람다(익명함수) 형태로 정의하여 파라미터로 넘겨주면 됩니다. Java 의 Stream 은 정확히는 모나드입니다. 이유는 Mapping 함수가 Operation(T) -&gt; (R): **원소(T)에서 원소(T)**로 **’매핑’**하는 것이 아니라 Operation(T) -&gt; (S): 원소(T)에서 아예 **새 Functor(S)**로 **’반환’**한다는 것입니다. Functor 에서는 연산 전 데이터 구조에서 단위 원소를 꺼내 ‘매핑’**을 적용 후 **결과 원소를 데이터 구조에 넣었습니다. 반면 모나드에서는 연산 전 데이터 구조에서 단위 원소를 꺼내 ‘매핑’**을 적용 후 해당 원소를 **데이터 구조에 넣어서 결과 데이터 구조를 ‘반환’**합니다. 함수 자체가 데이터 구조를 반환하기 때문에 매핑 함수 결과에 **Stream.map().map().map()… 과 같이 계속해서 Chaining 으로 연결할 수 있습니다. 왜 ‘원소 - 원소 매핑’**이 아닌 **’원소 - 데이터 구조 매핑’**을 하는지 아래 **모나드에서 살펴보겠습니다. Monad모나드가 무엇인지 한 마디로 정리하기에 앞서, 왜 모나드가 필요한지에 대해 알아보겠습니다. 프로그래밍 언어의 ‘프로그래밍 함수’와 학문에서의 ‘함수’의 차이점이 무엇인지 아시는지요? 함수 함수 실행 시 내부에 어떤 상황이 발생하더라도 최종적으로 값을 반환하는걸 보장합니다. 프로그래밍 함수 함수 실행 시 내부에 어떤 처리할 수 없는 상황이 발생하면 값을 반환하지 못한채 중간에 Exception을 발생시킵니다. 고등, 대학 수학에서 그 어떠한 함수도 f(x) 중간에 실행하다가 입력해준 값이 잘못되어있으면 중간에 Exception을 내지(…) 않았습니다. 하지만 프로그래밍 함수는 작동 중 상태가 잘못되었을 경우 Exception 을 발생시킵니다. Exception 을 발생시키는 것을 순수함수 관점에서는 Side-Effect 로 정의하기 때문에 Exception 이 발생하는 함수를 **’비순수 함수’**로 정의합니다.^7 만약 ‘프로그래밍 함수’에서 Exception 발생시 중간에 멈추는것이 아니라 해당 ‘상태’가 발생했음을 ‘상태’값으로써 결과에 함께 반환한다면 Side-Effect 는 없어지게 됩니다. 프로그래밍 함수의 순수함수화인 셈입니다. 이렇게 ‘상태’값과 함수 본연의 ‘결과’값을 함께 반환하기 위해서는 이 둘을 묶는 데이터 구조가 필요할 것 같습니다. Functor 의 Mapping 함수를 순수함수로 만들기위해 함수의 결과에 Exception 이 발생할 수 있는 ‘상태’ 및 ‘결과’**를 **모두 포함하는 데이터 구조를 반환해보았습니다. Functor 의 Mapping 함수가 데이터 구조를 반환하도록 만들었지만 반환되는 데이터 구조가 한번 더 Functor 의 데이터 구조로 감싸져서 반환되는 문제가 발생했습니다. Exception ‘상태’를 갖는 데이터 구조가 Mapping 함수를 수행한 Functor 의 데이터 구조에 한번 더 감싸진채로 반환되었습니다. Functor 는 자신의 데이터 구조의 내부 원소에서 그에 대한 연산을 수행하고 결과 원소를 데이터 구조에 Mapping 하여 반환하기 때문입니다. 불필요하게 두 번 감싸지 않고 Exception 상태만을 포함한 데이터 구조를 반환하기 위하여 Mapping 함수의 결과를 그대로 반환하고, Mapping 함수 수행 전에 갖고있는 데이터 구조에서 값을 추출하는 Unwrap 함수를 명시합니다. 이를 flatMap 함수라고 부르며 이 flatMap 으로 얻어진 ‘데이터 구조의 내부 원소’**에 대한 **Mapping 결과인 ‘데이터 구조’를 바로 반환하도록 하는것이 모나드 패턴입니다. Monad 정의 Monad는 Unwrap(flatMap) 함수를 포함하는 Mappable 데이터 구조입니다.Monad의 Mapping 함수는 ‘결과’와 ‘상태’ 모두를 갖는 데이터 구조를 반환합니다. ‘단위 원소’로 구성된 (1) 데이터 구조 ‘단위 원소’에서 ‘Exception 상태를 포함한 (2) 데이터 구조’로의 Mapping 함수 (1) 데이터 구조에서 ‘단위 원소’을 꺼내는 Unwrap(flatMap) 함수 모나드에 대한 설명을 보면 Context 와 Content 이 둘을 가진 데이터 타입으로 설명하는 글들이 많습니다. Context 를 값이 있음/없음에 대한 ‘상태’값으로, Content 는 우리가 연산하려는 ‘값’ 내지 ‘결과’값으로 설명합니다. Monad 의 Context 가 꼭 값이 있음/없음의 상태를 가져야하는것은 아니지만 일반적으로 함수 수행 중에 Exception 이 발생할 수 있는 경우들은 값이 null 인 경우가 대부분이기 때문에 많은 설명들에서 nullable 로 설명하는것 같습니다. Function Composition모나드는 결과 데이터 구조가 ‘상태’를 갖는다는것 뿐만 아니라 함수의 합성이 가능하다는 성질도 갖습니다. composition with associative:두 Mapping 함수 f(x), g(x) 가 있다면 두 함수를 합성시 f(g(x)) = (f.g)(x) 의 결과를 갖는다.또한 associative 성질에 의해 f(g(x)) = (f.g)(x) = (g.f)(x) = g(f(x)) 도 만족한다. 이렇게 함수형 프로그래밍의 클로저, 고차함수, 커링, Functor, 모나드 총 5개의 개념을 다뤄보았습니다. 질문이나 논의할 사항이 있으면 댓글이나 개인적으로 알려주시면 감사하겠습니다. 특히 이번 글은 시니어 개발자분의 도움으로 틀린 내용들을 가다듬고 다시 보완할 수 있었습니다. 다음 글에서는 Swift 의 클로저가 외부 변수를 참조하면서 생기는 참조 순환 문제와 그걸 해결하기 위한 기법들을 설명하겠습니다. 참조 https://medium.com/@sjsyrek/five-minutes-to-functor-83ef9075978b https://medium.com/@jooyunghan/functor-and-monad-examples-in-plain-java-9ea4d6630c6 http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html http://seorenn.blogspot.com/2014/06/swift-closures.html https://stackoverflow.com/questions/356950/what-are-c-functors-and-their-uses https://stackoverflow.com/questions/2030863/in-functional-programming-what-is-a-functor","link":"/2019/03/24/only-one-page-for-functional-programming/"},{"title":"6. 싱글턴 패턴","text":"디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다. 1. 디자인 패턴에 앞서 2. 디자인 패턴의 제 1, 2 원칙 설명에 사용할 코드는 Java-like Pseudo Code 입니다. ‘정적 변수’ 및 ‘정적 메서드’코드를 작성하다보면 변수나 메서드를 단 하나만 생성하여 모든 곳에서 공유하여 사용할 때가 있습니다. 정적 변수와 정적 메서드에 해당하는 개념입니다. Java 와 같이 객체지향 프로그램에서는 변수, 메서드 모두 클래스 내 존재해야하는 제약사항 때문에 공유하려는 전역 변수, 메서드를 클래스에 담아서 공유해야합니다. 재미있는 점은 정적 클래스라는 개념은 없기 때문에 클래스 안의 정적 변수나 메서드는 따로 객체 초기화 할 필요없이 바로 접근이 가능함과 동시에 원한다면 이 클래스를 객체로 초기화해서도 사용가능하다는 것입니다. 객체 초기화 없이 해당 클래스의 정적 변수와 정적 메서드를 사용한다니 이게 어떻게 가능한걸까요? Java, JVM 메모리Java 는 JVM 위에서 프로그램을 동작시키는데요. JVM 의 M, Machine 이 뜻하는대로 작은 OS 라고 보시면 됩니다. JVM 에서 돌리는 모든 프로그램의 자원을 JVM 이 관리합니다. 이런 이유로 Java 에 대한 이해는 JVM 메모리 관리에 대한 이해와 1:1의 관계에 놓여있습니다. 싱글턴 패턴을 배우기에 앞서 정적 변수, 메서드를 이해하기 위해 클래스, 변수, 메서드가 메모리에 어떤 JVM 메모리 영역에 할당이 되고 어떻게 정리가 되는지 간단하게 살펴보겠습니다. JVM 메모리 영역은 다음 세 영역으로 나뉩니다. 변하지 않는 값을 담는 Static 영역 (이를 칭하는 용어는 아래 총 3가지가 있습니다) 변하지 않는 값을 담는다는 의미에서 Static 영역이라 부르기도 하고 객체화 되기 전 Class 그 자체를 담는다는 의미에서 Class 영역이라 부르기도 하고 (Class Loading) 객체화 되기 전 Class 의 함수를 담는다는 의미에서 Method 영역이라 부르기도 합니다. 변하는 값을 담는 Heap 영역과 Stack 영역으로 나뉩니다. Stack 영역: 함수 내 ‘파라미터’나 ‘로컬변수’와 같이 그 함수 블록 내에만 생존하는 변수들을 저장 Heap 영역: 객체들을 저장 객체 생성의 가장 근간이 되는 Class 는 바이트코드 형태로 Static 영역에 적재됩니다. 그 Class 를 객체화할때마다 그 객체와 객체의 변수, 메서드는 위 클래스 바이트코드를 참조하여 생성된 뒤에 Heap 영역에 적재됩니다. 정적 변수, 메서드는 객체없이 Class 에 존재하는것이므로 Static 영역에 저장되겠군요. Static 영역에 Class 적재 및 객체 생성을 담당하는 것을 Classloader(클래스로더)**라고 부르며 이 로더는 커스텀하게 바꾸지 않았다면 일반적으로 JVM 위에 하나만 존재합니다. 만약 두 개의 클래스로더가 있다면 같은 정적 변수라 할지라도 각자 다른 Static 영역에 적재됩니다. **정적 변수, 메서드와 일반 객체의 변수, 메서드는 적재된 영역이 다르기 때문에 서로 참조하지 못하는 특징을 갖습니다. 싱글턴 패턴정적 변수, 메소드정적 변수, 메서드는 ‘클래스로더’ 내 단 하나만 존재하는 **유일무이한 “클래스”**의 변수, 메서드입니다.(클래스로더는 한 프로그램에 다수 개일 수 있습니다.) Static 영역에 생성되는 클래스 변수, 메서드입니다. 프로그램의 시작과 동시에 클래스로더 에 의해 바이트코드형태로 Static 영역 메모리에 바로 적재됩니다. 12345678class Calculator { // * Public: Can be initialized from outer public Caculator() {} // * Static: sum(a, b) public static sum(Integer a, Integer a) { return a + b; }} 싱글턴 변수, 메소드싱글턴 패턴의 정의는 ‘클래스로더’ 내 단 하나만 존재하는 **유일무이한 “객체”**의 변수, 메서드입니다.(클래스로더는 한 프로그램에 다수 개일 수 있습니다.) Heap 영역에 생성되는 객체 변수, 메서드입니다. 프로그램 실행 도중 필요한 그 시점에 객체로 Heap 영역에 적재됩니다. 그리곤 오랜기간 사용되지 않는다면 GC 됩니다.(필요한 시점에 객체 생성하는것을 Lazy Loading 이라고 합니다. 싱글턴 패턴의 존재 의의기도 합니다.) 1234567891011121314151617class Calculator { // * Priavte: Cannot be initialized from outer private Caculator() {} // * Non-Static: sum(a, b) public sum(Integer a, Integer a) { return a + b; } // * Singleton: Can be initialized only once using getInstance() private static Calculator uniqueInstance; public static Calculator getInstance() { if (uniqueInstance == null) { uniqueInstance = new Calculator(); } return uniqueInstance; }} 차이를 아시겠나요? 하지만 유일한 클래스의 정적 변수, 메서드든 유일한 객체인 싱글턴 패턴이든 진입점이 한 곳인 만큼 다중 스레드가 한번에 진입점에 들어올 때 서로를 어떻게 독립적으로 수행할 수 있게 보장할지가 문제가 됩니다. 이를 유식한 말로는 다수의 스레드가 모두 이 클래스 내지는 객체에 접근을 하려 경쟁한다는 의미로 **Race Condition(경쟁 상태)**라고 합니다. Race ConditionJava 에서 다중 스레드를 사용할지라도 JVM 메모리에서는 따로 스레드별로 영역들을 지정해주지 않기 때문에 프로그래머가 접근제어를 해주지 않는다면 하나의 클래스 혹은 객체를 두 스레드에서 접근할 수 있습니다. Java 의 객체, 변수, 메서드 모두 기본적으로 non-blocking 이므로 여러 스레드에서 하나의 클래스 혹은 객체 접근을 동시에 할 경우 함수, 변수를 중복 호출/사용하는 문제가 발생합니다. 이를 해결하기 위해 가장 단순하게 생각할 수 있는것은 함수 단위로 blocking 하는것입니다. 위 싱글턴 패턴의 예로 사용한 Caculator 클래스의 getInstance() 함수를 두 개의 스레드에서 동시에 진입했다고 가정합시다. 동시에 if (uniqueInstance == null) 구문에 진입했을때 어느 스레드도 그 다음 라인인 new Caculator() 를 수행하지 않았다고 가정한다면 두 스레드 모두 uniqueInstance 가 null 인것으로 판단할것입니다. 그리고 그 다음 라인에 두 스레드 각각 새 객체를 생성하게 되고, 이렇게 된다면 두 스레드는 하나의 객체 함수가 아닌 각자의 객체 함수를 보게됩니다. 단순 계산 객체라면 큰 영향은 없겠지만 만약 하나의 상태를 공유하려는 객체라면 두 스레드가 서로 다른 상태를 보고있는 끔찍한 상황이 연출됩니다. 123Thread1: getInstance() if (uniqueInstance == null) { // 2019-03-03 00:00:01 uniqueInstance = new Calculator(); // 2019-03-03 00:00:03 - Calculator 객체 1 생성 (Thread1) 123Thread2: getInstance() if (uniqueInstance == null) { // 2019-03-03 00:00:02 uniqueInstance = new Calculator(); // 2019-03-03 00:00:04 - Calculator 객체 2 생성 (Thread2) 함수 단위 Blocking - Synchronized다수의 스레드가 한 함수에 접근하려 한다면, 하나의 스레드가 해당 함수를 수행하는 동안에는 기다리도록 blocking 합니다. Java 가 제공하는 synchronized 키워드를 사용하면 손쉽게 해당 함수 호출을 blocking 할 수 있습니다. 이젠 Thread 1 이 해당 함수를 호출하고 끝날때까지 Thread 2 는 해당 함수 호출을 계속 기다려야합니다. 두 스레드가 한 함수를 동시에 호출할일은 없어졌습니다. 12345678910class Calculator { ... public static synchronized Calculator getInstance() { if (uniqueInstance == null) { uniqueInstance = new Calculator(); } return uniqueInstance; }} 하지만 싱글턴 함수가 위에 로직보다 더 복잡하고 수행시간이 길다면 다른 스레드들은 한 스레드가 해당 함수 호출을 완료하는 그 긴 시간동안 멈춰있어야하는 성능의 이슈가 있습니다. 이런 경우에는 함수 단위의 blocking 이 아니라 함수 내 blocking 해야하는 딱 그 변수만 집어서 blocking 하는게 좋겠지요. 변수 생성 단위 Blocking - DCL (Double Checked Locking)우리의 원래 목적은 “변수”의 스레드간 공유인데, 굳이 함수 단위의 blocking 을 해서 변수 외 나머지 로직 수행의 시간까지 손만 빨며 성능 이슈까지 발생시킬 이유는 없습니다. 똑똑한 프로그래머들의 고민 결과 “함수”가 아닌 “변수” 단위의 Blocking 을 고안해내었고 이를 **DCL (Double Checked Locking)**이라고 명명합니다. 왜 Double Checked 일까요? 아래 코드를 보시면 객체 생성 로직 진입 전과 진입 후 생성하기전에 한번 더 null 여부를 검사하기 때문인것으로 알 수 있습니다. 함수 단위 Blocking - 함수에 synchronized 추가1234567private static Calculator uniqueInstance;public static synchronized Calculator getInstance() { if (uniqueInstance == null) { uniqueInstance = new Calculator(); } return uniqueInstance;} 변수 생성 단위 Blocking - 변수에 volatile 추가, 함수 내 해당 변수에 synchronized 추가1234567891011private volatile static Calculator uniqueInstance;public static Calculator getInstance() { if (uniqueInstance == null) { synchronized (Calculator.class) { if (uniqueInstance == null) { uniqueInstance = new Calculator(); } } } return uniqueInstance;} 기존 방식은 getInstance() 함수에 synchronized 가 붙어있는 반면, 변수 생성 단위 Blocking 에서는 변수에 volatile 이 추가되었고, 해당 함수 내 아까 volatile 을 추가한 변수에 대해서 synchronized 붙여준걸 알 수 있습니다. 여기서 유념히 보셔야할것은 변수를 사용하는 부분이 아닌 변수를 생성하는 부분에 synchronized 를 붙여줬음을 꼭 기억하시기 바랍니다. DCL (Double Checked Locking) 의 의미모든 프로그램 및 스레드는 CPU 을 통해 연산들을 수행하고, 연산을 위한 변수값들은 “메인 메모리”로부터 CPU 바로 옆 “캐시”로 가져와 사용하게 됩니다. 만약 두 스레드가 각자 다른 CPU (멀티코어 환경) 에서 하나의 싱글턴 혹은 정적 변수를 공유하여 작동한다면 어떤 일이 발생할까요? 두 스레드가 공유하는 하나의 변수는 기본적으로 “메인 메모리”에 적재되어 있습니다. 각 스레드가 각 CPU 에서 값을 변경하는 경우 1) 먼저 메인 메모리로부터 캐시로 변수값을 가져오고, 2) CPU 가 해당 캐시의 값을 변경하고, 3) 캐시에 변경된 값을 메인 메모리에 작성(동기화)하는 과정을 거칩니다. 두 스레드가 동시에 변수의 값에 접근할 경우, 첫번째 스레드가 자신이 할당된 CPU 내 캐시의 변수값을 먼저 바꿨음에도 불구하고 아직 메인 메모리에 쓰지 않아 두번째 스레드는 변경된 값을 모른채 자신의 CPU 에서 독립적으로 값 변경을 수행하는 문제가 발생합니다. 그렇다고 다수 스레드가 하나의 CPU 에서 수행된다고 하더라도 아예 문제가 없는것은 아닙니다. JIT 컴파일러에 의해 어셈블리 레벨 코드 재배열(Reorder)이 발생하여 스레드 간 참조하는 변수값이 달라질 수 있기 때문입니다. 위에서 설명한 스레드간 변수 동기화 내지는 불일치 문제를 한 스레드의 값 업데이트를 다른 스레드에서는 볼 수 없다는 의미의 가시성(Visibility) 문제라고 일컫습니다. 볼 수 있다면 Visible 하다. 라고 표현합니다. 가시성 문제를 해결하기 위해 “캐시”와 “메인 메모리” 간 읽은(READ) 값이 일치하도록 강제하는 것이 volatile 키워드 입니다. 변수에 volatile 키워드를 추가하면 해당 변수는 CPU 에서 “캐시”의 값을 읽을때 동시에 “메인 메모리”의 값을 Read 함을 보장합니다. 한 스레드에서 값을 변경한다면 바로 메인 메모리에 적용되고 다른 스레드가 값을 읽을 때 최신의 값을 읽을 수 있습니다. 하지만 두 스레드가 같은 메인 메모리 값을 가져다가 변경할 경우는 여전히 문제입니다. 값을 쓰는것은 어쩔 수 없이 blocking 을 걸어두어야합니다. 한 스레드가 작성하고있다면 다른 스레드는 기다렸다가 앞 스레드가 작성을 마치면 바로 메인 메모리로부터 값을 읽어서 그 다음 쓰기를 진행하면 됩니다. 이를 위해 값을 변경(WRITE)할때는 해당 클래스에 blocking 을 거는 synchronized 키워드를 함께 사용하면 됩니다. 변수 사용 단위 Blocking - Lazy Holder애석하게도 변수 생성 단위의 Blocking 으로 단일 생성이 완벽히 보장되진 않았습니다. 세상에, CPU 캐시까지 고려했는데 무엇을 또 놓쳤다는걸까요? 트랜지스터 레벨이라도 봐야하는 것일까요? DCL 을 통해 변수의 단일 생성 자체는 보장되었습니다. 다만 단일 생성 바로 직후에 다른 스레드에서 해당 변수를 바로 사용하려 한다면, 아직 채 완전히 생성되지 못한 변수를 사용하게 될 수 있다는 것입니다. 단일 생성을 시작하면 해당 클래스의 new ..를 통해 생성자를 수행하게 될 것입니다. 생성자가 조금이라도 복잡하다면 온전한 객체가 만들어지기 까지는 조금의 시간이 걸릴 것입니다. 하지만 해당 객체를 접근하는 다른 스레드는 그 라인의 끝마침을 기다려주지 않습니다. 이때 미처 다 온전하게 생성되지 않은 불완전한 객체를 다른 스레드에서 가져다가 사용하게 되는것입니다. 이를 out-of-order write 문제라고 명명합니다. 해결은 해당 객체가 단순히 생성되었다 여부가 아닌 완벽히 생성되었다는걸 보장하면 됩니다. 이를 보장하는 방식은 더 똑똑한 프로그래머들에 의해 정말 다양하게 제시되었는데요. 기발한것들도 있지만 그 중에 가장 이해가 쉬운것은 아래와 같습니다. 123456789public class Calculator { ... private static class LazyHolder { private static final Calculator UNIQUE_INSTANCE = new Calculator(); } public static Calculator getInstance() { return LazyHolder.UNIQUE_INSTANCE; }} static final 로 정의된 UNIQUE_INSTANCE는 클래스로더에 의해 프로그램 시작 시 가장 먼저 Static 영역에 바로 적재됩니다. 이를 통해 getInstance() 호출되기 이전에 UNIQUE_INSTANCE = new Calculator(); 가 무조건 존재함을 보장합니다. 사실상 위에서 배운 모든 것을 활용한 해결책에 해당합니다. 개인적으로 이 해결책이 기억에 남는 이유가 C# 에서 LazyHolder 형식을 기본적으로 제공해주기 때문에 싱글턴 패턴 사용이 아래와 같이 매우 쉽게 해결했던 기억이 있습니다. 123456public sealed class Singleton{ private static readonly Lazy&lt;Singleton&gt; lazy = new Lazy&lt;Singleton&gt;(() =&gt; new Singleton()); public static Singleton Instance { get { return lazy.Value; } } private Singleton() {}} https://gampol.tistory.com/entry/Double-checked-locking%EA%B3%BC-Singleton-%ED%8C%A8%ED%84%B4 http://thswave.github.io/java/2015/03/08/java-volatile.html","link":"/2019/03/02/singleton-pattern/"},{"title":"신입 개발자였던 내게 해주고싶은 조언들","text":"부족했던 나의 신입시절개발자로 살아온지 3년반이 되었습니다. 물리학자의 삶을 꿈꿨었지만, 중학교때 게임을 만들자고 배웠던 C 언어와 고등학교때 hamachi 로 VPN 과 네트워크에 흥미를 가진것을 시작으로 학석사를 지난 뒤 시대 기술 흐름에 타고싶다는 욕심으로 첫 직장으로 쿠팡에 들어갔었습니다. 신입때는 너무 어렸었습니다. 튀는걸 너무 좋아해서 옷도 행실도 너무 자유분방했던것같고, 개발을 잘하면 모르겠는데 제대로 할줄아는것도 없으면서 열정만 높았어서 이것저것 손대는것들만 많았으니 팀적으로도 개인적으로도 남는것이 그리 많진 않았었습니다. 개발적으로는 Spring, Java 와 React 에 좀 더 집중했었으면 어떨까 아쉬움은 있지만, 나름 큰 회사에 비지니스에서 개발까지 풀스택에 가까운 다양한 경험들을 통해 배운것들은 많아서 큰 후회는 없습니다. 그래도 제가 과거의 제 신입시절로 돌아간다면 해주고 싶은 몇가지 조언들이 있습니다. 주변에서의 조언 요청쉬는날엔 개발에 흥미를 가진 학생과 Spring 나 머신러닝 스터디를 진행하며 몇 조언도 주었었는데, 얼마전에 한명으로부터 자기 주변의 신입 개발자분들한테 해줄 조언에 대해 질문받았습니다. 짧게 답변해주려다가 내 부족했던 신입시절을 회고할겸, 블로그로 작성해놓으면 다른 스터디에서도 본 글을 추천해주면 되겠다 싶어서 이렇게 글을 작성하게 되었습니다. 워낙 다양한 스택의 신입 개발자분들이 많아서 각 분야에 맞게 학습하시는게 좋을것같아 따로 본 글에 기술적인것들은 제외하였습니다. 개발자, 한번 더 생각해보세요 최근 산업구조의 변화때문에 개발직군에 대한 수요가 폭증하기 시작했고, 현재의 취업난은 구직하는 분들에게 개발자가 매력적인 대안으로 다가오면서 직군을 개발자로 바꿔 이직하시거나 학생들은 전과를 하는 경우가 주변에서 종종 보이기 시작합니다. 유능한 개발자가 돈을 많이 벌기도하고, 회사의 대우도 좋은 편이고, 창의적 직군이다보니 흔히말하는 꼰대가 생존할 수 없는 분야라 개발자 문화가 선진화되어있어서 좋아보일 수 있습니다. 하지만 이는 나 자신이 유능한 개발자일때 한하여 얻을 수 있는 장점들입니다. 어떤 분야와도 마찬가지로 그 사이에는 무수히 많은 인고의 시간들이 있습니다. 대체 가능한 인력개발자는 유능하지 않으면 사실 해당 인력을 대체하기가 굉장히 쉬운 직군이기도 합니다. 제 주변의 시니어 개발자분들은 모두 SI 업체에서 혹독한 개발경험을 거쳐 오셔서 관련 이야기를 많이 들어왔었는데, 개발자들의 실력 분포는 승자독식이라고 보면 됩니다. 상위 적은 % 의 유능한 개발자들만 주도적으로 프로젝트를 운영할 수 있고 그 외의 개발자들은 수동적으로 할당 받은 개발만 할 수 있습니다. 이 능동성과 수동성의 차이가 내가 있을 기업, 내가 받을 연봉, 주변에 능력있는 개발자들의 유무를 크게 가른다고 생각하시면 됩니다. 제 주변의 모든 존경스러운 시니어분들은 SI 에서 끊임없는 공부와 노력을 끝으로 올라오신 분들입니다. 이 말을 즉슨 내가 어디에 속하는지가 중요한것이 아니라 나의 태도가 중요하다는 것입니다. 유능한 개발자의 특성유능한 개발자와 무능한 개발자의 분포가 굉장히 편파적인 이유는 유능해지기 그만큼이나 어렵다고 생각하셔야합니다. 경쟁은 상대적인데다가 노력하는 개발자들도 많기때문에 조금만 부족하더라도 장기적으로는 도태될 수 있습니다. 그렇다면 개발자는 어떤 사람들이 잘할 수 있을까요? 업무 외 시간에도 코딩 및 공부를 순수하게 즐길 줄 알아야합니다. 직장에서 업무를 마치고 집 돌아와서 혼자 쉬는시간에도, 직장에서 있었던 여러 이슈나 내가 주고받았던 코드리뷰들을 한번 더 복습하고 이유와 원인을 분석할 수 있어야합니다. 예를 들면, 오늘 처음으로 docker 를 이용한 배포 프로세스를 경험해봤다면 docker 에 대한 궁금한 점들을 공부하는식이죠. 개인 프로젝트가 있다면 좋습니다. 아니라면 다른 오픈소스를 하나, 둘 개선해보거나 잘 짜여진 오픈소스 코드를 뜯어보거나 디버깅을 통해 한라인씩 실행시켜보는것도 코드 역량을 올릴 수 있는 좋은 방법이기도 합니다. 평생 공부할 수 있어야합니다. 즐기는것도 필요하지만 개발자는 그만두기 이전까지 계속해서 공부해야하는 직군입니다. Spring 만하더라도 과거에는 .xml 기반으로 Bean 인젝션을 처리했었지만 이젠 @Annotaion 기반으로 처리합니다. React.js 도 과거에는 class 기반의 component 를 사용했지만 이제는 함수형 Hook 을 사용합니다. JVM 과 ES 표준은 항상 끊임없이 변화하고 매 개발 컨퍼런스에서는 자신들의 새 개념을 발표합니다. 세상을 빠르게 돌아가도록 하는건 기술이고 최근 그 기술의 선봉에 개발자들이 있습니다. 이 빠른 흐름에 뒤쳐지지 않기 위해서는 매 새로운 개념을 ‘과거의 탄탄한 개발지식을 바탕’으로 흡수하여 그 다음을 준비할 줄 아는 인재가 되어야합니다. 개발은 어떤 유저가 하나의 웹/앱에 수행한 클릭이 프론트 UI -&gt; 네트워크 -&gt; 보안 -&gt; 백엔드 서버 -&gt; 서버 인프라 -&gt; DB 모든 기술 스택의 사이클을 한바퀴 돌아 원하는 결과를 볼 수 있게하는것입니다. 각 분야는 의사로 치면 전문의들이 있을 정도로 그 깊이가 매우 깊습니다. 내가 어떤 분야의 전문의가 되더라도 모든 사이클에 대한 적당한 깊이의 이해가 있어야지 개발하는데 있어서 다양한 상황을 동시에 고려하여 신뢰성 높은 결과를 만들/조언할 수 있고 문제가 생겼을때 빠른 원인 파악 및 대처를 할 수 있습니다. 개발자는 사실 분석가입니다.개발자를 꿈꿀때 흔히 생각하는 모습은 키보드를 통해 코드를 끊임없이 쳐서 새로운걸 생산해내는것일 것입니다. 개발의 절반만 보안, 성능, 안정성, 확장성을 고려하여 새로운 코드를 생성하는것이고, 그조차도 내가 만들었던 혹은 타인이나 스택오버플로의 코드의 많은 부분을 참조하여 재생산하게됩니다. 나머지 절반은 테스팅과 디버깅입니다. 회사에서 업무를 수행하게 되면 하나의 프로젝트를 한 사람이 모든 역할과 책임을 갖고 만들지 않습니다. 만약 그렇다하더라도 해당 코드는 다음 세대에 새 개발자가 물려받게됩니다. 개발은 다수 개발자와의 협업입니다. 즉, 다수 개발자들의 코드더미에 내 작은 코드를 넣는 과정의 반복입니다. 비대면, 비동기적 협업인 셈입니다. 그렇기때문에 하나의 피쳐를 개발한다 하더라도 타 개발자가 개발한 코드를 온전히 이해할수 있어야지 원치않는 에러를 내지 않게됩니다. 테스트를 진행하다보면 분명히 의도적인 결과가 도출되지 않을때가 있는데, 내가 만든 코드뿐만 아니라 타 개발자의 코드도 같이 디버깅 할 줄 알아야합니다. 라인별로 의도를 파악하고, 코드의 흐름을 파악하는건 직접 개발능력보다 더 중요합니다. 아무리 좋은 침을 쓴다한들 한의사가 맥을 잘짚지 않으면 소용없는것과 마찬가집니다. 코드의 유지보수성은 한때 엄청 큰 이슈였고, 이를 위해 Spring 의 IoC, 책임분리 개념들이 이를 돕기위해 나왔었던것입니다. 남들이 어떤 문서없이도 코드를 이해할 수 있도록 만드는것이 가장 좋지만, 문서와 커멘터리는 개발자와 협업에 있어서 그 못지않게 중요합니다. 개발은 협업이란걸 잊으면 안됩니다. 좋은 시니어 개발자가 되기생각했던것과 조금은 다른 개발자의 역량에 대해 알아봤습니다. 그럼에도 개발자가 되고싶은 마음이 크다면 이제는 신입때부터 어떻게해야 몇년뒤에 동료들이 같이 일하고싶어하는 시니어로 성장할 수 있을지에 대해 말해보겠습니다. 짧게 요약하자면 내가 작성한 코드에 대한 근거/이유를 어느 누구에게도 명료히 이야기할 수 있어야하고, 주력인 언어나 프레임워크에 대한 깊은 이해가 있어야합니다. 이슈와 리뷰는 꼭 메모/복습개발중에 발생하는 이슈, 코드리뷰는 꼭 ‘왜’에 대해 꼼꼼히 메모해놓고 복습하는것이 필요합니다. 앞서 말씀드렸듯이 개발자는 평생 공부해야하는 직업일 정도로 익혀야할 정보가 많기 때문에 따로 메모/복습이 없다면 매번 똑같은 실수를 반복하게됩니다. 기억을 잘하기 위해서는 스터디같은것을 통해 누군가에게 가르치는게 좋은 방법입니다. 코드 작성 이유 설명내가 어떤 작업을 왜 이렇게 했는지 누군가에게 제대로 설명할 수 있어야합니다. 신입이나 경력 개발자를 뽑을때 인터뷰로 유심히 보는 부분이기도 합니다. 누가 이렇게 하라던데요? 스택오버플로에서 이렇게 쓰더라구요.의 근거는 당연하지만 좋지 않습니다. 이유없이, 그냥 되니까 사용하는 코드는 거의 없어야합니다. 물론 시간의 한계 때문에 모든 이유를 다 알 순 없습니다만 적어도 내 주력 분야에 대해서는 설득할 수 있어야합니다. 언어/프레임워크 선택과 집중신입때는 주력 언어, 프레임워크, DB 가 적고 깊을수록 좋습니다. 특히나 최신 기술을 사용하고 각 팀마다 개발스택이 다양한 (좋은) 회사를 처음 가게된다면 뷔페에 온듯양 두 눈이 휘둥그레져서 이것저것 다 먹어보고싶은 마음은 백번천번 이해합니다. 하지만 주니어라면 내 주력 기술이 단 하나라도 있어야 그를 통해 다른 기술들과의 차이점을 알고, 특징들을 더 잘 이해할 수 있습니다. 타 기술을 이해하는데에 뿐만 아니라 커리어적으로도 3년~5년의 긴 시간이 흘렀을때 그 주력 기술이 나의 강점이 되어 후배들을 이끌 수 있게됩니다. 모든것을 다 익히고싶은 마음은 당장은 안타깝지만 정보량이 정말 방대하기 때문에 하나라도 제대로할 줄 아는 선택과 집중의 지혜가 필요합니다. 풀스택은 내 분야에 대한 제대로 된 이해가 꼿꼿히 바로서야 그 위에 ㅡ 자를 그려서 T 자형 인재가 될 수 있는것입니다. ㅣ만 제대로 세운다면 그 이후 ㅡ 는 더 넓고 방대하게 뻗어나갈 수 있으니 당장의 욕심을 내려놓고 내 분야에 집중합시다. 언어/프레임워크 선택은 내가 가고싶어하는 분야에서 많이 선호되고 보편적으로 사용하는것을 선택해야합니다. 웹 서비스 개발이라면 Java, Spring 그리고 SQL 은 MySQL 만 제대로 공부해놓는다면 NoSQL 의 개념과 MVCC 등을 이해하는데 큰 도움이 됩니다. 게임 개발이라면 유니티를 위해 C# 을 배운다거나 머신러닝을 위해서는 tensorflow 를 위한 python 을 공부할 수 있을것입니다. 틈틈히 시간날때마다 공부신입분들은 새 회사에서 크게 세가지를 배우실겁니다. 내외부 팀 구성 및 본인의 팀 내 팀원들, 비지니스, 개발 기술스택. 쿠팡처럼 비지니스가 방대한 회사를 가셨다면 당장 그것만 이해하는데 1여년을 다 사용해야할수도 있지만, 틈틈히 개인의 주력 언어, 프레임워크를 좀 더 끈질기게 공부하신다면 좋은 기회가 왔을때 더 잘 캐치하여 성과를 올릴 수 있으실겁니다. 혹자는 2~3년 세상에 난 없는 사람이라고 생각하면서 끈기있게 공부에 전력을 쏟으면 더 빠른 시간안에 시니어가 될 수 있다곤 하지만, 그렇게 추천드리긴 인간적으로 어렵다고 생각됩니다. 이러한 이유로 오타쿠 혹은 코딩/공부를 미친듯이 좋아하는 분들이 천재 개발자가 되는것이라 생각합니다. 결국엔 공부의 총량이 결정하는 셈입니다. 코드리뷰는 필수코드리뷰가 매우 활성화되어있는 회사로 가는것을 추천드립니다. 적어도 한명의 사수가 꾸준히 코드리뷰를 해줄 수 있는 기업에서 일하는것이 좋습니다. 멘토-멘티 문화가 바로잡혀있다면 정말 최고입니다. 한줄의 코드에는 그렇게 작성한 수많은 이유들이 있습니다. 주니어 개발자들은 이걸 왜 이렇게 개발하였는지 알기위해서 몇달을 공부해야하지만, 대로 된 멘토가 있다면 일주일에 모든 이유를 배울 수 있습니다. 물론 그 지혜는 꼭 메모해놓는것이 필요합니다. 그런 문화가 없다면 동기들과 혹은 스터디를 통해 서로의 코드와 지식을 나누고 리뷰하는 모임을 만드는것이 좋습니다. 회사 동기들은 대외비인 회사 내부 코드들을 리뷰해줄수있다는 장점이 있고, 스터디를 통해서는 지정한 언어/프레임워크를 다양한 시각에서 토론해볼 수 있다는 장점이 있습니다. 비슷한 이유로 개발자 모임같은 대외 활동을 늘리는것도 시니어 분들에 의해 많이 추천됩니다. 커뮤니케이션 능력사람들을 대하지 않는다는 비대면의 특성때문에 전 개발자를 선택하였었지만, 흔히 아싸의 이미지를 갖는 개발자의 이미지와는 달리 결국 개발자는 사람을 대하는 직업입니다. 실제로 매체에서 접하는 비사회적인 nerd 들은 본인의 역량은 굉장히 뛰어날지 모르겠지만, 회사는 팀별로 설정된 목표를 가지고 함께 나아가는 곳이기에 협업과 커뮤니케이션 능력이 없다면 활용불가능한 자원에 불가합니다. 신입 개발자로써 두 분야의 사람을 접하게 될텐데 비지니스 분야, 디자인 분야입니다. 이들과는 (1) 요구사항과 (2) 개발 한계에 대해 이야기할일이 많을것입니다. 또한 같은 분야의 개발자들과도 (1) 코드에 대한 리뷰/이유 설명과 (2) 정보 교환을 위해서도 커뮤니케이션은 필수입니다. 타인의 의견을 항상 경청, 존중해야할줄 알아야하며 내 근거에 대해서 조리있게 설명할 줄 알아야합니다. 사실 처음에는 풀스택 개발자가 되기위해서 알아야할 기본적인 프론트엔드, 백엔드, 보안, 네트워크, 인프라에 대한 기술적인 내용들을 이야기하고 싶었습니다. 하지만 워낙 양이 방대하기 때문에 이건 앞으로 블로그글이나 오프라인으로 스터디를 통해 전달해야할거같습니다. 벌써 3년 반이란 세월이 지났지만 아직도 항상 부족함을 느끼며 공부하고 있기 때문에 이런 조언글을 쓰는게 적합한가 싶기도합니다. 신입때 내게 아쉬웠던 점들을 풀어쓴 글이 이제 막 신입으로 들어오는 후배나 개발직을 준비하는 분들에게 도움이 될것이라 생각합니다. 짧은 시간에 작성한것이라 부족함이 많을 수 있음에도 끝까지 읽어주셔서 감사합니다. :) 모든 개발자 분들 화이팅하셨으면 좋겠고 언젠간 좋은 위치에서 만나뵈면 좋을것같습니다.","link":"/2021/02/07/things-that-i-should-have-known-when-i-was-a-junior-developer/"}],"tags":[],"categories":[{"name":"Language","slug":"Language","link":"/categories/Language/"},{"name":"Design Pattern","slug":"Design-Pattern","link":"/categories/Design-Pattern/"},{"name":"Javascript","slug":"Language/Javascript","link":"/categories/Language/Javascript/"},{"name":"Singleton","slug":"Design-Pattern/Singleton","link":"/categories/Design-Pattern/Singleton/"},{"name":"Adapter, Decorator","slug":"Design-Pattern/Adapter-Decorator","link":"/categories/Design-Pattern/Adapter-Decorator/"},{"name":"Kotlin","slug":"Language/Kotlin","link":"/categories/Language/Kotlin/"},{"name":"Factory","slug":"Design-Pattern/Factory","link":"/categories/Design-Pattern/Factory/"},{"name":"Workplace","slug":"Workplace","link":"/categories/Workplace/"},{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Observer","slug":"Design-Pattern/Observer","link":"/categories/Design-Pattern/Observer/"},{"name":"Troubleshooting","slug":"Troubleshooting","link":"/categories/Troubleshooting/"},{"name":"Swift 4+ &#x2F; iOS","slug":"Language/Swift-4-iOS","link":"/categories/Language/Swift-4-iOS/"},{"name":"Develop","slug":"Programming/Develop","link":"/categories/Programming/Develop/"},{"name":"Java 8","slug":"Troubleshooting/Java-8","link":"/categories/Troubleshooting/Java-8/"},{"name":"Licenses","slug":"Programming/Licenses","link":"/categories/Programming/Licenses/"},{"name":"Framework","slug":"Framework","link":"/categories/Framework/"},{"name":"Deployment","slug":"Deployment","link":"/categories/Deployment/"},{"name":"Functional Programming","slug":"Language/Functional-Programming","link":"/categories/Language/Functional-Programming/"},{"name":"Spring","slug":"Framework/Spring","link":"/categories/Framework/Spring/"},{"name":"Docker","slug":"Deployment/Docker","link":"/categories/Deployment/Docker/"}]}