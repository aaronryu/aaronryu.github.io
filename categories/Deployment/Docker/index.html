<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Category: Docker - Crucian Carp</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crucian Carp"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crucian Carp"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Cool heads but warm hearts"><meta property="og:type" content="blog"><meta property="og:title" content="Crucian Carp"><meta property="og:url" content="https://aaronryu.github.io/"><meta property="og:site_name" content="Crucian Carp"><meta property="og:description" content="Cool heads but warm hearts"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://aaronryu.github.io/img/og_image.png"><meta property="article:author" content="Aaron Ryu"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://aaronryu.github.io"},"headline":"Crucian Carp","image":["https://aaronryu.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Aaron Ryu"},"description":"Cool heads but warm hearts"}</script><link rel="alternate" href="/atom.xml" title="Crucian Carp" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/androidstudio.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-134840627-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-134840627-1');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Crucian Carp</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li><a href="/categories/Deployment/">Deployment</a></li><li class="is-active"><a href="#" aria-current="page">Docker</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2020-08-20</div></span><span class="level-item"><a class="link-muted" href="/categories/Deployment/">Deployment</a><span> / </span><a class="link-muted" href="/categories/Deployment/Docker/">Docker</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/08/20/an-introduction-to-docker/">Docker 간단하게 살펴보는 기본 개념</a></h1><div class="content"><html><head></head><body><h1 id="왜-Docker-를-사용하는가"><a href="#왜-Docker-를-사용하는가" class="headerlink" title="왜 Docker 를 사용하는가?"></a>왜 Docker 를 사용하는가?</h1><p>하나의 서버에 다양한 Application 들을 구동시키려면 여러 VM 들을 올려놓고 각 Application 마다 VM 을 할당해주는 방법도 있지만, Docker 는 각 Application 을 VM 보다 가벼운 Container 단위로 패키징 및 관리를 가능하게 합니다.</p>
<h1 id="Container-는-무엇인가"><a href="#Container-는-무엇인가" class="headerlink" title="Container 는 무엇인가?"></a>Container 는 무엇인가?</h1><h2 id="VM-vs-‘Container’"><a href="#VM-vs-‘Container’" class="headerlink" title="VM vs ‘Container’"></a>VM vs ‘Container’</h2><p><strong>VM</strong> 개념은 <strong>단일 Host OS</strong> 위에 <strong>다수의 Guest OS</strong> 를 갖고 각각 Application 을 단일 Guest OS 에 매핑한것인 반면</p>
<blockquote>
<p>[ Host OS - [ <strong>VM</strong>: Guest OS - Libs - App ] ]</p>
</blockquote>
<p><strong>Container</strong> 는 <strong>단일 Host OS</strong> 위에 <strong>다수의 Application 을 바로 구동</strong>할 수 있는 VM 보다 가벼운 단위입니다. <strong>Host</strong> OS 와 <strong>Container</strong> 사이 포트 포워딩이나 파일시스템(디렉토리) 연동 등은 후술할 Image 설정으로 가능합니다.</p>
<blockquote>
<p>[ Host OS - [ <strong>Container</strong>: Libs - App ] ]</p>
</blockquote>
<p>VM 은 Hypervisor 에 의해 물리적 자원 관리가 된다면 Container 는 Docker 에 의해 논리적으로 자원 분배가 됩니다. </p>
<ul>
<li>VM 은 Hypervisor 에 의한 하드웨어 가상화</li>
<li>Container 는 Docker 에 의한 Host OS 가상화</li>
</ul>
<p>과거 학부때 데모 실행을 위해 멀티 노드 하둡구성시 사용 경험이 있는 LXC(Linux Container) 개념이 Docker 의 초기 버전의 구현이었다고 합니다만 이후 Docker 는 자체 컨테이너를 사용한다고 합니다.</p>
<h2 id="Image-and-‘Container’"><a href="#Image-and-‘Container’" class="headerlink" title="Image and ‘Container’"></a>Image and ‘Container’</h2><p>Docker 를 처음 접하며 명확히 구별하지 못했던 개념이 있습니다. ‘Image’와 ‘Container’입니다. Image 는 VM 에서의 개념과 동일하기에 쉽게 이해하실 수 있습니다.</p>
<ul>
<li><strong>Image</strong> 는 Container 구동을 위한 파일시스템과 구동에 필요한 설정들이 모여있는 <strong>정적 설정</strong>이며,</li>
<li><strong>Container</strong> 는 위 Image 를 기반으로 실제 구동(Runtime)된 <strong>동적 인스턴스</strong>라고 보면 됩나다.</li>
</ul>
<h1 id="왜-Container-를-사용하는가"><a href="#왜-Container-를-사용하는가" class="headerlink" title="왜 Container 를 사용하는가?"></a>왜 Container 를 사용하는가?</h1><h2 id="Application-단위-관리"><a href="#Application-단위-관리" class="headerlink" title="Application 단위 관리"></a>Application 단위 관리</h2><p>Application 단위로 패키징을 가능하게 함으로써 개발 시 역할/책임(R&amp;R)을 분리할 수 있습니다. 웹 서비스를 개발하면 하나의 서버 인스턴스에 다양한 역할들이 들어있는데, 각각 독립된 Container 로 분리할 수 있습니다.</p>
<ul>
<li><strong>nginx</strong>: 정적 페이지 제공 및 SPA 프론트엔드</li>
<li><strong>tomcat</strong>: 프론트엔드에 제공될 API 서버</li>
<li><strong>logstash</strong>: nginx, tomcat 에서 발생하는 log 들을 log 적재 서버에 전송</li>
<li><strong>온콜(서비스 상태 추적)</strong>: nginx, tomcat 에서 발생하는 오류 로그 및 CPU, memory 등 자원 상태를 상태 관리 서버에 전송</li>
<li><strong>성능 측정(예, pinpoint)</strong>: tomcat 에서 타 서버들의 API 콜에 대한 횟수, 지연시간 등을 성능 관리 서버에 전송</li>
</ul>
<p>즉, 위 예시와 같이 하나의 서버 인스턴스에 총 5개의 Container 가 작동될 수 있습니다.</p>
<p>만약 프론트엔드에 제공할 API 서버뿐만 아니라 외부에서 직접 호출할 수 있는 API 서버를 추가하고싶다면 tomcat 컨테이너를 하나 더 추가하여 총 2개의 tomcat 을 하나의 서버 인스턴스에 두고 사용할 수 있습니다. Java 기반 tomcat 을 Python 기반 django 로 교체할 수 도 있습니다. 프론트엔드를 제공하는 nginx 서버는 그대로 있으면서 API 서버만 교체된것이죠. </p>
<p>각 Application 을 레고 블럭처럼 관리하는건 배포에도 큰 이점이 있습니다. 단지 하나의 컨테이너 버전만 업데이트하고싶다면 해당 컨테이너의 이미지만 다시 받아서 재배포를 진행하면 됩니다. 각 컨테이너마다 버전 관리를 따로 할 수 있는것이죠.</p>
<blockquote>
<p>레고 블럭처럼 Application 들을 관리할 수 있다는 장점은 VM 도 갖고있지만, 그보다 더 Container 를 선호하는 이유는 <strong>가상화의 레벨이 상위 레벨인 만큼 가볍고(Container = lightweight VM), 위에 설명했듯이 버전 및 배포관리가 이미지로 관리되므로 (1) 이미지 설정과 (2) 배포가 구분되어있어 과정의 자동화가 쉽기 때문입니다. 성능 측면에서도 Container 간 IO 및 네트워크 처리에 있어서 빠르기도 합니다.</strong><a target="_blank" rel="noopener" href="https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd">^1</a> 가상화의 레벨이 로우 레벨인 VM 은 보안 측면에서의 캡슐화가 Container 보다 더 뛰어나다고 하지만, 현재 기술에서는 둘간 얼마나 큰 차이가 있을지 궁금하군요.</p>
</blockquote>
<p>이처럼 Docker 로는 <strong>Application 이 구동될 환경</strong>과 <strong>구동할 이미지</strong>를 설정합니다. <strong>Application 각각의 자체 설정</strong>은 docker 와 별개로 프로젝트 내부에 설정해놓으면 됩니다. 책임 분리인 셈입니다.</p>
<h1 id="Docker-용어-구성요소"><a href="#Docker-용어-구성요소" class="headerlink" title="Docker 용어(구성요소)"></a>Docker 용어(구성요소)</h1><ul>
<li><strong>Registry</strong> = Images storage<ul>
<li>Image 들을 저장헤놓는 중앙 저장소</li>
<li>일반적으로 배포 파이프라인을 구성하면 최신 소스를 통해 Docker Engine 으로 생성한 tomcat/nginx 이미지를 Registry 에 올린뒤, 해당 이미지로 최종 서버 배포를 진행합니다.</li>
<li>기본 Docker Hub 서버 혹은 회사/개인용 Docker Hub 서버를 만들어서 사용하거나</li>
<li>Amazon AWS 에서 제공하는 ECR(AWS EC2 Continaer Registry)를 사용할 수도 있습니다.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Image</strong><ul>
<li>전에 설명했듯 Container 동작을 위한 파일시스템과 구동에 필요한 설정들이 모여있는 <strong>정적 설정</strong>입니다.</li>
<li>Image 는 RO(Read-Only) 파일시스템의 집합<a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/#images-and-layers">^2</a>입니다. 좀 더 상세한 파일시스템 구조는 다음을 참조<a target="_blank" rel="noopener" href="https://rampart81.github.io/post/docker_image/">^3</a>하세요.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Container</strong><ul>
<li>위 Image 기반으로 실제 구동(Runtime)된 <strong>동적 인스턴스</strong></li>
</ul>
</li>
</ul>
<ul>
<li><strong>Application/Service</strong> = Containers on <strong>One host</strong><ul>
<li>이를 위해 <strong>Docker Compose</strong> 를 사용하여 <strong>하나의 호스트 머신에서 Containers 를 관리</strong>할 수 있습니다.</li>
</ul>
</li>
</ul>
<ul>
<li><strong>Orchestration</strong> = Containers on <strong>Multiple hosts</strong>(Systems, MSA)<ul>
<li>이를 위해 <strong>Docker Swarm</strong> 를 사용하여 <strong>다수의 호스트 머신에서 Containers 를 관리</strong>할 수 있습니다.</li>
</ul>
</li>
</ul>
<h1 id="Docker-Engine"><a href="#Docker-Engine" class="headerlink" title="Docker Engine"></a>Docker Engine</h1><p><strong>(1) Image 생성</strong> 및 <strong>(2) Container 구동</strong> 모두를 담당하는 엔진<a target="_blank" rel="noopener" href="https://www.quora.com/What-is-the-difference-between-the-Docker-Engine-and-Docker-Daemon">^4</a>이며 구성은 아래와 같습니다.</p>
<ol>
<li>컨테이너 및 이미지 생성을 위한 유저의 입력을 받는 <strong>Docker CLI</strong></li>
<li>컨테이너 구동을 위한 <strong>Docker Daemon</strong></li>
</ol>
<h2 id="Image-생성"><a href="#Image-생성" class="headerlink" title="Image 생성"></a>Image 생성</h2><p>Container 는 Image 기반으로 구동되기때문에 원하는 Container 구동에 앞서 원하는 Image 를 먼저 만들어야합니다. 이미지 생성에서 최종 컨테이너 구동까지는 세 절차로 이뤄집니다.</p>
<ol>
<li><strong>Dockerfile</strong> - Dockerfile 작성</li>
</ol>
<p>Dockerfile 로 원하는 Image 생성에 대한 설정(생성 규칙)을 여러 명령어로 작성합니다. 본 설정을 기반으로 이미지를 생성하고 생성된 이미지를 갖고 추후 컨테이너로 구동하게됩니다. 아래는 간단한 명령어 모음입니다.</p>
<blockquote>
<p><strong>FROM</strong>: 기본 베이스 이미지를 정의합니다. 가져올 해당 이미지 URL 을 적으면 됩니다.<br><strong>ENV</strong>: 이미지 내 환경변수를 설정합니다. 리눅스 터미널에서 <code>SET_VALUE=3</code> &amp; <code>echo $SET_VALUE</code> 를 생각하면됩니다.</p>
<p><strong>RUN</strong>: 실행할 Shell 명령어를 명시하면 <strong>이미지 빌드 시점</strong>에서 해당 명령어를 수행합니다.<br><strong>CMD</strong>: 실행할 Shell 명령어를 명시하면 <strong>이미지 빌드 완료 뒤 컨테이너가 정상 실행되었을때</strong> 해당 명령어를 수행합니다.</p>
<p><strong>EXPOSE</strong>: 외부에 열고싶은 Port 를 설정합니다. <strong>Container 포트</strong>와 <strong>실제 Host 에서 노출할 포트</strong>를 연결합니다.<br><strong>WORKDIF</strong>, <strong>ENTRYPOINT</strong>: RUN/CMD 로 명시한 Shell 을 실행할 디렉토리 위치를 지정합니다.<br><strong>ADD</strong>, <strong>COPY</strong>: 호스트의 디렉토리나 파일을 <strong>이미지에 커밋</strong>합니다.<br><strong>VOLUME</strong>: 호스트의 디렉토리나 파일을 이미지에 커밋하지 않고 <strong>컨테이너 디렉토리에 연결</strong>합니다.</p>
<p>… 더 많은 명령어 및 상세 설명은 공식 Docker 문서를 참조하세요.</p>
</blockquote>
<ol start="2">
<li><strong>Build</strong> (docker build) - 이미지 생성</li>
</ol>
<p><code>docker build</code> 명령어를 실행하면 가장 먼저, 작성되어있는 Dockerfile 를 Docker Daemon 에게 전달합니다. 그 후 Dockerfile 스크립트 내 매 명령어마다 실행하기 위한 컨테이너를 구동하고, 명령어가 성공적으로 수행된다면 해당 스냡샷으로 이미지를 생성합니다. 아래에서 예시로 살펴볼 <code>docker build</code> 수행 로그를 보면 Docker 는 <strong>Dockerfile 내 각 명령어가 실행되는 컨테이너의 ID</strong>와 <strong>실행이 끝난다면 실행완료된 컨테이너의 스냅샷으로 생성한 이미지 ID</strong> 이 둘을 반환하는걸 알 수 있습니다.</p>
<p>만약에 명령어 수행중에 실패하게 된다면 <strong>해당 명령어가 실행되는 컨테이너 ID</strong>에 쉘을 통해 접근하여 로그를 확인할 수 있습니다. 이처럼 중간에 반환되는 컨테이너 ID 를 통해 <code>docker build</code> 디버깅이 가능합니다. 그렇다면 Dockerfile 스크립트의 마지막 라인이 실행 완료된 컨테이너의 스냅샷이 최종적으로 우리가 생성할 이미지가 되는것입니다.</p>
<ul>
<li><strong>2.1. 빌드의 시작은 Dockerfile 를 Docker Daemon 에 전달하면서 시작</strong>됩니다.</li>
</ul>
<p>Docker Daemon 은 Dockerfile 에서 FROM 명령어에 명시된 새로 생성할 이미지의 기반이 될 베이스 이미지를 가져옵니다.</p>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker build .</span><br><span class="line"></span><br><span class="line">Sending build context to Docker daemon 10240 bytes</span><br><span class="line"></span><br><span class="line">Step 1/3 : FROM base-image:1.7.2</span><br><span class="line">Pulling repository base-image:1.7.2</span><br><span class="line"> ---&gt; e9aa60c60128/1.000 MB (100%) endpoint: https://my-own.docker-registry.com/v1/</span><br></pre></td></tr></tbody></table></figure>
<p>개인 Docker Registry 인 <a target="_blank" rel="noopener" href="https://my-own.docker-registry.com/v1">https://my-own.docker-registry.com/v1</a> 에서 base-image:1.7.2 이미지를 가져왔습니다. 마지막 라인에 <code>e9aa60c60128</code>는 다운받은 베이스 이미지에 Docker 가 할당한 ID 입니다. 다음으로 수행될 명령어는 이 이미지 기반으로 중간 이미지를 만듭니다.</p>
<ul>
<li><strong>2.2. 그 다음 명령어는 이전에 생성된 중간 이미지를 다시 컨테이너로 구동하여, 명령어들을 수행한 뒤 스냅샷을 이미지로 반환</strong>합니다.</li>
</ul>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Step 2/3 : WORKDIR /instance</span><br><span class="line"> ---&gt; Running <span class="hljs-keyword">in</span> 9c9e81692ae9</span><br><span class="line">Removing intermediate container 9c9e81692ae9</span><br><span class="line"> ---&gt; b35f4035db3f</span><br></pre></td></tr></tbody></table></figure>
<p>바로 이전에 수행한 FROM 명령어의 결과로 <code>e9aa60c60128</code> 중간 이미지가 생성되었습니다. 본 이미지로 새 컨테이너 <code>9c9e81692ae9</code> 를 구동하였고, 그 내부에서 <code>WORKDIR /instance</code> 명령어를 수행한뒤, 수행 완료된 컨테이너를 내리고 그 스냅샷을 <code>b35f4035db3f</code> 이미지로 반환한것을 볼 수 있습니다.</p>
<ul>
<li><strong>2.3.</strong> 2.2.와 동일합니다. 단, Dockerfile 내 모든 Step 을 마쳤으므로 <strong>마지막으로 생성한 스냅샷 이미지가 우리가 최종적으로 얻는 이미지</strong>가 됩니다.</li>
</ul>
<figure class="highlight bash hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Step 3/3 : CMD <span class="hljs-built_in">echo</span> Hello world</span><br><span class="line"> ---&gt; Running <span class="hljs-keyword">in</span> 02071fceb21b</span><br><span class="line">Removing intermediate container 02071fceb21b</span><br><span class="line"> ---&gt; f52f38b7823e</span><br><span class="line"></span><br><span class="line">Successfully built f52f38b7823e</span><br></pre></td></tr></tbody></table></figure>
<p>우리가 얻는 최종 이미지명(ID)을 <code>f52f38b7823e</code>가 아닌 원하는 이름을 붙여주고 싶다면 tag 옵션을 통해 이름을 붙여줄 수 있습니다. 예를 들면 <strong>base-image:1.7.2</strong> 로 새 이미지를 만들었으니 <strong>custom-image:1.7.2</strong> 로 이름지어볼 수 있습니다.</p>
<ul>
<li><strong>2.4.</strong> <strong>Push</strong> (docker push) - 이렇게 만든 이미지를 Docker Registry 에 저장합니다.</li>
</ul>
<h2 id="Container-구동"><a href="#Container-구동" class="headerlink" title="Container 구동"></a>Container 구동</h2><p>생성된 최종 Image 로 Docker Daemon 위에서 Container 구동합니다.</p>
<ul>
<li><strong>1.</strong> <strong>Pull</strong> (docker pull) - 컨테이너를 구동하기 위해 저정된 이미지를 가져옵니다.</li>
<li><strong>2.</strong> <strong>Execute</strong> (docker run) - 가져온 이미지로 컨테이너를 구동합니다.</li>
</ul>
<h1 id="Docker-이미지-설정-예시"><a href="#Docker-이미지-설정-예시" class="headerlink" title="Docker 이미지 설정 예시"></a>Docker 이미지 설정 예시</h1><p>상품 정보를 저장/조회하는 서비스를 제공하기 위해 <strong>프론트엔드 서버</strong>는 <strong>nginx</strong>(react.js) 로 <strong>백엔드 서버</strong>는 <strong>tomcat</strong>(java) 으로 서비스를 제공하려고합니다. 두 Application 들을 각각 Container 로 총 두 개의 Container 를 하나의 AWS EC2 서버 인스턴스에서 구동하려합니다.</p>
<h2 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h2><p>먼저 nginx image 설정을 보겠습니다. nginx 구동은 쉘 스크립트를 실행하게되는데 직접 만든 replace-hosts-and-run.sh 쉘을 이미지에 주입해서 알맞은 환경변수와 함께 수행하여 최종적으로 nginx 서버를 띄우는것을 목표로 하겠습니다.</p>
<figure class="highlight dockerfile hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 1. 기본 베이스 이미지를 가져옵니다. 프론트엔드 서버용 nginx 기본 이미지를 받습니다.</span></span><br><span class="line"><span class="hljs-keyword">FROM</span> http://docker-hub.aaronryu.com/nginx:<span class="hljs-number">1.8</span>.<span class="hljs-number">0</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 2. nginx 웹 서버에서 다국어 지원을 위한 gettext 를 설치합니다.</span></span><br><span class="line"><span class="hljs-keyword">RUN</span><span class="hljs-bash"> apk --no-cache add gettext</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 3. 현재 프로젝트 디렉토리 중 files/, build/, 쉘 스크립트를 이미지 내 지정한 디렉토리에 추가/붙여넣습니다.</span></span><br><span class="line"><span class="hljs-keyword">ADD</span><span class="hljs-bash"> files/ /instance/program/nginx/conf</span></span><br><span class="line"><span class="hljs-keyword">ADD</span><span class="hljs-bash"> build/ /instance/service/webroot/ui</span></span><br><span class="line"><span class="hljs-keyword">ADD</span><span class="hljs-bash"> replace-hosts-and-run.sh /instance/program/nginx/replace-hosts-and-run.sh</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 4. 위 쉘 스크립트(replace-hosts-and-run.sh)에서 사용할 호스트 명 환경변수를 설정합니다.</span></span><br><span class="line"><span class="hljs-keyword">ENV</span> NGINX_HOST aaronryu.frontend.com</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 5. 로깅 등을 위해 nginx 컨테이너 내 아래 디렉토리를 호스트의 디렉토리에 연결합니다.</span></span><br><span class="line"><span class="hljs-comment"># (Container 가 아래 디렉토리에 하는 작업은 실제 호스트의 디렉토리에 반영됩니다.)</span></span><br><span class="line"><span class="hljs-keyword">VOLUME</span><span class="hljs-bash"> [<span class="hljs-string">"/instance/logs/nginx"</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 6. '이미지 완료 뒤'에 아까 복사해둔 아래 쉘 스크립트를 위 환경변수와 함께 실행(CMD)합니다.</span></span><br><span class="line"><span class="hljs-keyword">CMD</span><span class="hljs-bash"> /instance/program/nginx/replace-hosts-and-run.sh</span></span><br></pre></td></tr></tbody></table></figure>
<h2 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h2><p>nginx 서버의 SPA 정적 페이지에서 조회 및 저장을 위해서는 그에 맞는 API 가 필요합니다. 이 API 들을 제공하기위한 tomcat 서버를 구동하겠습니다. Java 서버이기에 JVM 에 대한 설정을 추가하고, 외부에서 본 서버의 상태를 조회하기 위해 12345 포트를 열어두겠습니다.</p>
<figure class="highlight dockerfile hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-comment"># 1. 기본 베이스 이미지를 가져옵니다. 백엔드 서버용 tomcat 기본 이미지를 받습니다.</span></span><br><span class="line"><span class="hljs-keyword">FROM</span> http://docker-hub.aaronryu.com/tomcat:<span class="hljs-number">8.0</span>.<span class="hljs-number">0</span>-jdk8</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 2. tomcat 의 구현은 spring boot 로 되어있습니다. 구동 시 production 프로파일 옵션을 주겠습니다.</span></span><br><span class="line"><span class="hljs-keyword">ENV</span> SPRING_PROFILE production</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 3. tomcat 은 Java 기반 서버이기에 JVM 메모리 옵션을 추가합니다.</span></span><br><span class="line"><span class="hljs-keyword">ENV</span> JVM_MEMORY -Xms2g -Xmx2g -XX:PermSize=<span class="hljs-number">512</span>m -XX:MAxPermSize=<span class="hljs-number">512</span>m</span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 4. 현재 프로젝트 디렉토리내 저장되어있는 setenv.sh 을 이미지 내 tomcat 실행 쉘 파일에 추가/붙여넣습니다.</span></span><br><span class="line"><span class="hljs-keyword">ADD</span><span class="hljs-bash"> setenv.sh <span class="hljs-variable">${CATALINA_HOME}</span>/bin/setenv.sh</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 5. 현재 프로젝트 빌드가 완료된 뒤 생성된 war 파일을 모두 tomcat 실행 webapps 에 추가/붙여넣습니다.</span></span><br><span class="line"><span class="hljs-keyword">COPY</span><span class="hljs-bash"> build/libs/*.war <span class="hljs-string">"<span class="hljs-variable">${CATALINA_HOME}</span>"</span> /webapps/ROOT.war</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 6. 설정한 tomcat 서버 포트 8080 을 호스트의 12345 포트에 연결하여 외부에 노출합니다.</span></span><br><span class="line"><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span> <span class="hljs-number">12345</span></span><br><span class="line"></span><br><span class="line"><span class="hljs-comment"># 7. 로깅 등을 위해 tomcat 컨테이너 내 아래 디렉토리들을 호스트의 디렉토리에 연결합니다.</span></span><br><span class="line"><span class="hljs-comment"># (Container 가 아래 디렉토리에 하는 작업은 실제 호스트의 디렉토리에 반영됩니다.)</span></span><br><span class="line"><span class="hljs-keyword">VOLUME</span><span class="hljs-bash"> [<span class="hljs-string">"/instance/logs/tomcat"</span>, <span class="hljs-string">"/instance/logs/tomcat/catalina_log"</span>, <span class="hljs-string">"/instance/logs/tomcat/gc"</span>]</span></span><br></pre></td></tr></tbody></table></figure>
<p>위 예시로 살펴본 각각의 Dockerfile 은 각각 nginx 와 tomcat 프로젝트 내에 위치하게 됩니다. 이 두 컨테이너를 하나의 인스턴스에 동시에 띄우기 위해서는 Docker Compose 설정으로(예, .yml) 설정으로 각 컨테이너의 이미지를 묶어서 명시하면 됩니다.</p>
<hr>
<ol>
<li><a target="_blank" rel="noopener" href="https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd">https://medium.com/@darkrasid/docker%EC%99%80-vm-d95d60e56fdd</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/#images-and-layers">https://docs.docker.com/storage/storagedriver/#images-and-layers</a></li>
<li><a target="_blank" rel="noopener" href="https://rampart81.github.io/post/docker_image/">https://rampart81.github.io/post/docker_image/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.quora.com/What-is-the-difference-between-the-Docker-Engine-and-Docker-Daemon">https://www.quora.com/What-is-the-difference-between-the-Docker-Engine-and-Docker-Daemon</a></li>
<li><a target="_blank" rel="noopener" href="https://www.joyfulbikeshedding.com/blog/2019-08-27-debugging-docker-builds.html">https://www.joyfulbikeshedding.com/blog/2019-08-27-debugging-docker-builds.html</a></li>
</ol>
</body></html></div></article></div></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Deployment/"><span class="level-start"><span class="level-item">Deployment</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Deployment/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Design-Pattern/"><span class="level-start"><span class="level-item">Design Pattern</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Design-Pattern/Adapter-Decorator/"><span class="level-start"><span class="level-item">Adapter, Decorator</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Factory/"><span class="level-start"><span class="level-item">Factory</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Observer/"><span class="level-start"><span class="level-item">Observer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Singleton/"><span class="level-start"><span class="level-item">Singleton</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Language/"><span class="level-start"><span class="level-item">Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Language/Functional-Programming/"><span class="level-start"><span class="level-item">Functional Programming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Java-8/"><span class="level-start"><span class="level-item">Java 8</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Swift-4-iOS/"><span class="level-start"><span class="level-item">Swift 4+ / iOS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Programming/Develop/"><span class="level-start"><span class="level-item">Develop</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Licenses/"><span class="level-start"><span class="level-item">Licenses</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Workplace/"><span class="level-start"><span class="level-item">Workplace</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Aaron Ryu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Aaron Ryu</p><p class="is-size-6 is-block">Software Engineer</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">17</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">17</p></a></div></div></nav><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/aaronryu"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitlab" href="https://gitlab.com/aaronryu"><i class="fab fa-gitlab"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Crucian Carp</a><p class="is-size-7"><span>&copy; 2021 Aaron Ryu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>