<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Crucian Carp</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Crucian Carp"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Crucian Carp"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Cool heads but warm hearts"><meta property="og:type" content="blog"><meta property="og:title" content="Crucian Carp"><meta property="og:url" content="https://aaronryu.github.io/"><meta property="og:site_name" content="Crucian Carp"><meta property="og:description" content="Cool heads but warm hearts"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://aaronryu.github.io/img/og_image.png"><meta property="article:author" content="Aaron Ryu"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://aaronryu.github.io"},"headline":"Crucian Carp","image":["https://aaronryu.github.io/img/og_image.png"],"author":{"@type":"Person","name":"Aaron Ryu"},"description":"Cool heads but warm hearts"}</script><link rel="alternate" href="/atom.xml" title="Crucian Carp" type="application/atom+xml"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/androidstudio.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><script src="https://www.googletagmanager.com/gtag/js?id=UA-134840627-1" async></script><script>window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());
    
        gtag('config', 'UA-134840627-1');</script><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/">Crucian Carp</a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-9-tablet is-9-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2019-02-27</div></span><span class="level-item"><a class="link-muted" href="/categories/Design-Pattern/">Design Pattern</a><span> / </span><a class="link-muted" href="/categories/Design-Pattern/Observer/">Observer</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/02/27/observer-pattern/">5. 옵저버 패턴</a></h1><div class="content"><html><head></head><body><p>디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다.</p>
<ul>
<li><a href="https://aaronryu.github.io/2018/12/30/a-introduction-to-design-patterns/">1. 디자인 패턴에 앞서</a></li>
<li><a href="https://aaronryu.github.io/2019/02/21/two-principles-of-design-patterns/">2. 디자인 패턴의 제 1, 2 원칙</a></li>
</ul>
<p>설명에 사용할 코드는 Java-like Pseudo Code 입니다.</p>
<hr>
<h1 id="변수"><a href="#변수" class="headerlink" title="변수"></a>변수</h1><p>프로그래밍을 처음 배울때 우리는 먼저 변수에 대해 배웁니다.<br>변하지 않는 값은 Constant 상수라고 부르며, Variable 변수의 값은 수시로 변합니다.<br>변수는 수시로 변할 수 있기 때문에 말 그대로 프로그램 내내 산전수전을 다 겪습니다.</p>
<h1 id="상태"><a href="#상태" class="headerlink" title="상태"></a>상태</h1><p>변수는 위에서 언급한대로 정말 다양한 상태를 갖습니다. 이러한 변수의 상태를 알기 위해서는 두 가지 방법이 있습니다.</p>
<h2 id="Push-방식"><a href="#Push-방식" class="headerlink" title="Push 방식"></a>Push 방식</h2><blockquote>
<p><strong>자동</strong>: <strong>변수가</strong> 자신이 상태가 바뀌었음을 우리에게 <strong>알려줍니다</strong>.</p>
</blockquote>
<h2 id="Pull-방식"><a href="#Pull-방식" class="headerlink" title="Pull 방식"></a>Pull 방식</h2><blockquote>
<p><strong>수동</strong>: <strong>우리가</strong> 변수가 상태가 바뀌었는지를 직접 <strong>알아봅니다</strong>.</p>
</blockquote>
<p><strong>자동</strong>으로 우리에게 알려주는게 가장 편해보일 수도 있겠지만 굳이 알 필요가 없는데 계속해서 자신의 상태에 대해 말해준다면 매우 귀찮겠지요. 그 상태를 계속 추적하기 위한 자원도 불필요하게 낭비될것입니다. 그럴때는 우리가 필요할때만 상태를 볼 수 있는 <strong>수동</strong>의 방법도 필요합니다. 이를 조금 고지식하게 <strong>Push</strong> 와 <strong>Pull</strong> 방식으로 이야기합니다. <strong>변수의 상태를 하나의 ‘주제’라고 본다면</strong> 주제를 중심으로 <strong>우리에게 알려주는지(Push)</strong> 아니면 **우리가 알아보는지(Pull)**에 따라 상태를 알 수 있는 방법이 나뉘는것입니다.</p>
<h1 id="옵저버-패턴"><a href="#옵저버-패턴" class="headerlink" title="옵저버 패턴"></a>옵저버 패턴</h1><blockquote>
<p>옵저버 패턴은 변수의 상태를 Push 와 Pull 중 원하는 방식을 통해 알 수 있는 패턴입니다.</p>
</blockquote>
<center><img src="/2019/02/27/observer-pattern/observer.svg" class=""></center>

<p>일반적으로 이 패턴을 설명할때 상태를 ‘주제’라 보고 Publish-Subscribe(발행-구독) 모델로 설명하곤합니다. 여기선 패턴 이름이 옵저버 패턴인 만큼 헷갈리지 않게 구독모델이 아닌 <strong>Observer</strong>와 <strong>Observable</strong> 두 가지 용어로만 설명을 드리겠습니다. 옵저버 패턴에는 앞서 말씀드린 딱 두 종류의 인터페이스만 존재합니다. 하나는 <strong>상태를 갖고있는 옵저버블</strong>, 나머지 하나는 <strong>상태를 보려하는 옵저버</strong>입니다.</p>
<h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>위 옵저버 패턴 그림을 보시면 옵저버블 인터페이스는 두 가지 정보를 ‘구성’(has)합니다.</p>
<ol>
<li><strong>상태</strong> (State)</li>
<li><strong>옵저버 리스트</strong> (Observers)</li>
</ol>
<p>오해를 해서는 안되는 점이 옵저버블 인터페이스는 <strong>상태 자체</strong>가 아니라 <strong>상태를 ‘갖고 있다’**는 것입니다. 상태를 갖고있다는 의미로 옵저버블, 즉 **옵저버는 이 인터페이스를 통해 상태를 ‘볼 수 있다’**는 의미인것입니다. 그리고 옵저버블은 상태를 알려주거나/알아보려는 옵저버들을 리스트(물론 다른 자료구조형도 가능합니다)로 관리하여 **Push 방식의 경우에는 상태를 누구에게 보내줄지?</strong> 그리고 <strong>Pull 방식의 경우에는 상태를 누구만 볼 수 있는지?</strong> 결정할 수 있습니다.</p>
<ul>
<li><strong>옵저버블 인터페이스</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observable</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">protected</span> List&lt;Observer&gt; observers;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer o)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer o)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">(Object obj)</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>옵저버블 구현</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateObservable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observable</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> State state;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeState</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">/* 상태가 변경됩니다. */</span> }</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerObserver</span><span class="hljs-params">(Observer o)</span> </span>{ <span class="hljs-comment">/* 옵저버 제외 */</span> }</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeObserver</span><span class="hljs-params">(Observer o)</span> </span>{ <span class="hljs-comment">/* 옵저버 추가 */</span> }</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>notifyObserver 구현 - 1) Push 방식</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">(State state)</span> </span>{ <span class="hljs-comment">/* 2. 옵저버 리스트의 각 옵저버들에게 1. 상태를 전송 */</span> }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>notifyObserver 구현 - 2) Pull 방식</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">/* 아무것도 하지 않습니다. */</span> <span class="hljs-keyword">null</span> }</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> State <span class="hljs-title">getState</span><span class="hljs-params">()</span> </span>{ <span class="hljs-comment">/* 상태를 보고싶으면 옵저버가 이 함수를 호출하면 됩니다. */</span> <span class="hljs-keyword">return</span> state; }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2></li>
</ul>
<p>옵저버는 길게 설명할 것 없이 <strong>상태를 보고자 하는 인터페이스</strong>입니다. 인터페이스인 만큼 해당 정보를 보고, 활용하고싶다면 의도에 맞게 원하는 방식대로 구현하여 사용하시면 됩니다.</p>
<ul>
<li><strong>옵저버 인터페이스</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">protected</span> Observable observable;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getStateFromObservable</span><span class="hljs-params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>옵저버 구현</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StateObserver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> State state;</span><br><span class="line"></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StateObserver</span><span class="hljs-params">(Observable observable)</span> </span>{ </span><br><span class="line">        <span class="hljs-keyword">this</span>.observable = observable;</span><br><span class="line">        <span class="hljs-keyword">this</span>.observable.registerObserver(<span class="hljs-keyword">this</span>);</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(state)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">this</span>.state = state;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
왜 StateObserver 를 <code>Observable.getObservers().add(new StateObserver())</code> 방식으로 추가하지 않고 StateObserver 객체를 생성할때 Observable 를 넣어줌으로써 생성자 안에서 추가를 해주었을까요?<blockquote>
<p><code>Observable.getObservers()</code>를 호출하지 않음으로써 <strong>옵저버 리스트를 옵저버블 외부에 절대 노출하지 않습니다.</strong></p>
</blockquote>
</li>
</ul>
<hr>
<p>옵저버 패턴을 왜 굳이 패턴으로 정의했을까요? 저렇게 복잡하게 할 필요까진 없을텐데요. 옵저버블과 옵저버 두 인터페이스가 서로의 구현에 대해서 전혀 알 필요없이 데이터만을 주고 받는데 의의가 있습니다. 좀 더 풀어쓰자면 아래와 같습니다.</p>
<blockquote>
<p><strong>옵저버블이 갖는 1. 상태와 2. 옵저버 테이블 모두 외부에 노출하지 않은채 오로지 옵저버들만 알게끔하는 것이죠.</strong><br>**”서로 상호작용을 하는 객체 사이에는 가능하면 느슨하게 결합하는 디자인을 사용해야 한다.”**는 원칙입니다.</p>
</blockquote>
<p>잘 이해가 되셨는지요. 오늘의 디자인 패턴은 여기서 마치도록 하겠습니다.</p>
</body></html></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2019-02-27</div></span><span class="level-item"><a class="link-muted" href="/categories/Design-Pattern/">Design Pattern</a><span> / </span><a class="link-muted" href="/categories/Design-Pattern/Adapter-Decorator/">Adapter, Decorator</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/02/27/adapter-decorator-facade-pattern/">4. 데코레이터, 어댑터, 퍼사드 패턴</a></h1><div class="content"><html><head></head><body><p>디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다.</p>
<ul>
<li><a href="https://aaronryu.github.io/2018/12/30/a-introduction-to-design-patterns/">1. 디자인 패턴에 앞서</a></li>
<li><a href="https://aaronryu.github.io/2019/02/21/two-principles-of-design-patterns/">2. 디자인 패턴의 제 1, 2 원칙</a></li>
</ul>
<p>설명에 사용할 코드는 Java-like Pseudo Code 입니다.</p>
<hr>
<h1 id="분장술"><a href="#분장술" class="headerlink" title="분장술"></a>분장술</h1><p>아기돼지 삼형제를 보면 양가죽을 쓰고 하얀색 분으로 손을 칠해 양으로 변장한 늑대가 나옵니다. 물론 너무 어설픈 나머지 막내돼지한테 비웃음을 당하지만 돼지들의 집을 들어가기 위해서는 ‘변장’이 필요했던 것이죠. 이번에 얘기할 내용은 분장과 변장에 대한 이야기입니다. 여기서 잠깐 그 차이를 알아볼까요.</p>
<h2 id="분장"><a href="#분장" class="headerlink" title="분장"></a>분장</h2><p>분장은 현재 <strong>나의 모습</strong>에서 조금 더 <strong>과장한 나의 모습</strong>으로 꾸민것입니다.<br><strong>나 자신은 그대로</strong>, 어렵게 말하면 본질은 해치지 않는 선에서 그 위에 <strong>무엇인가를 추가로 꾸민것</strong>이죠.</p>
<h2 id="변장"><a href="#변장" class="headerlink" title="변장"></a>변장</h2><p>변장은 현재 <strong>나의 모습</strong>에서 <strong>완전 다른것의 모습</strong>으로 꾸민것입니다.<br><strong>나 자신이 아닌 완전 다른 어떤것으로 꾸민것</strong>이죠.</p>
<p>이번 챕터에서 배울것은 <strong>분장에 해당하는 데코레이터 패턴</strong>과 <strong>변장에 해당하는 어댑터 패턴</strong>입니다. 마지막으론 앞서 두 패턴처럼 한 클래스를 다른 클래스로 바꾸는것이 아닌 <strong>다수의 클래스를 하나의 클래스로 단순히 묶어주는 퍼사드 패턴</strong>을 다루고 마칠 예정입니다.</p>
<h1 id="어댑터-패턴-변장"><a href="#어댑터-패턴-변장" class="headerlink" title="어댑터 패턴 - 변장"></a>어댑터 패턴 - 변장</h1><p>앞서 늑대가 돼지삼형제 집으로 들어가기 위해 순한 양으로 변장했습니다. 무시무시한 발톱을 하얀 분칠을 통해 예뻐보이는 손으로 바꾸었고, 그르렁거리는 목소리를 순한 양처럼 메에 흉내내기도 해봅니다. 이를 클래스로 표현하면 이해가 매우 Sheep습니다.</p>
<ul>
<li><p><strong>늑대</strong></p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wolf</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Claw</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"Sharp Claw"</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Growl</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-string">"Grrrrrrr"</span>;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>늑대가 돼지삼형제 집에 들어가기 위해 양으로 ‘변장’했군요.</strong></p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WolfWantsToBeSheep</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Sheep</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">public</span> Wolf wolf;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Hand</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        wolf.Claw().replace(<span class="hljs-string">"Sharp Claw"</span>, <span class="hljs-string">"White Hand"</span>);   </span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">Sound</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        wolf.Growl().replace(<span class="hljs-string">"Grrrrrrr"</span>, <span class="hljs-string">"Baaaaaaa"</span>);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>이제 늑대는 양이 들어갈 수 있는곳이면 어디든 갈 수 있습니다. 양만 들어갈 수 있는 돼지삼형제 집에 한번 들어가보겠습니다.</p>
</li>
<li><p><strong>돼지삼형제 집</strong></p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">WelcomeToPigHouse</span><span class="hljs-params">(Sheep sheep)</span></span>;</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>실제 양은 돼지삼형제 집에 잘 들어갑니다.</strong></p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WelcomeToPigHouse(<span class="hljs-keyword">new</span> Sheep());</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>이런, 양으로 변한 늑대도 돼지삼형제 집에 들어갔군요.</strong></p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WelcomeToPigHouse(<span class="hljs-keyword">new</span> WolfWantsToBeSheep(<span class="hljs-keyword">new</span> Wolf()));</span><br></pre></td></tr></tbody></table></figure>
<p>어떤 클래스나 함수를 <strong>클라이언트</strong>로 본다면 <strong>클라이언트들은 특정 타켓 인터페이스에만 맞게 구현</strong>되어있습니다. 이런 제약때문에 다른 클래스를 해당 클라이언트에서 사용하고 싶을지라도, <strong>해당 클래스가 타겟 인터페이스의 구현체가 아니라면 사용할 수 없습니다.</strong> 위의 예처럼 태어났을때부터 늑대였지만 돼지삼형제 집에 가기위해서는 순한 양이 되어야하는 상황말이죠. 일반 비지니스에서도 이와 같이 어떤 클래스를 클라이언트 목적에 맞는 클래스로 사용해야하는 갑작스런 요구사항이 발생하곤 합니다.</p>
</li>
</ul>
<h2 id="객체-어댑터"><a href="#객체-어댑터" class="headerlink" title="객체 어댑터"></a>객체 어댑터</h2><p>위 늑대와 양의 예시처럼 어댑터 패턴은 <strong>어댑터</strong>라는 <strong>타겟 인터페이스의 구현 클래스</strong>를 생성하고 그 안에 <strong>타켓 인터페이스로 변장하고자 하는 클래스를 객체</strong>로 갖습니다. 이를 <strong>어댑티</strong>라고 명명하는데요. 어댑티의 원래 함수와 프로퍼티들을 활용하여 <strong>타겟 인터페이스의 각 함수들을 구현</strong>하면 됩니다. </p>
<p>이걸 <strong>객체 어댑터</strong>로 부르는 이유는 <strong>어댑티를 어댑터가 객체로 갖고 있기 때문</strong>입니다. 이를 우리는 ‘구성’이라고 배웠었지요. 아래의 코드를 보면 Adapter 가 Adaptee 를 객체로 가지고 있습니다. 클래스 다이어그램이 이해를 조금 더 도와줄겁니다.</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">Client</span><span class="hljs-params">(TargetInterface interface)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> Adaptee adaptee; </span><br><span class="line">    <span class="hljs-comment">// ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">this</span>.Client(<span class="hljs-keyword">new</span> Adapter(<span class="hljs-keyword">new</span> Adaptee()));</span><br></pre></td></tr></tbody></table></figure>
<p>어답티는 어답터의 도움으로 TargetInterface 만을 사용하는 클라이언트에 주입가능해졌습니다.</p>
<center><img src="/2019/02/27/adapter-decorator-facade-pattern/adapter.svg" class=""></center>

<p>그럼 <strong>클래스 어댑터</strong>은 무엇일까요? Adapter 가 Adaptee 를 **객체의 형태로 ‘구성’**하지 않고 **클래스의 형태로 ‘상속’**하면 됩니다.</p>
<h2 id="클래스-어댑터"><a href="#클래스-어댑터" class="headerlink" title="클래스 어댑터"></a>클래스 어댑터</h2><p>클래스 어댑터는 되려 단순합니다. 아래 코드와 클래스 다이어그램을 보시면 객체 어댑터와 두 가지 차이점이 있습니다.</p>
<ol>
<li>Adapter 가 Adaptee 를 구성(has)하지 않고 상속(extends)하고 있습니다.</li>
<li>Target 이 Interface 가 아니라 Class 로 존재하며, 그에 따라 구현(implements)이 아닌 상속(extends)을 하고 있습니다.</li>
</ol>
<ul>
<li><strong>객체 어댑터</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> Adaptee adaptee; </span><br><span class="line">    <span class="hljs-comment">// ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<center><img src="/2019/02/27/adapter-decorator-facade-pattern/object-adapter.svg" class=""></center>


</li>
</ul>
<ul>
<li><strong>클래스 어댑터</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Target</span>, <span class="hljs-title">Adaptee</span> </span>{</span><br><span class="line">    <span class="hljs-comment">// ... adaptee 함수를 활용해 Target 의 함수를 확장합니다.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<center><img src="/2019/02/27/adapter-decorator-facade-pattern/class-adapter.svg" class=""></center>

</li>
</ul>
<p>위 코드를 보고 흠칫하셨을것입니다. Java 에서는 다중 상속을 지원하지 않기때문에 extends A, B 와 같은 문법은 사용할 수 없습니다. 또한 이렇게 사용할 경우 Target 이 Interface 가 아닌 Class 이기 때문에 다른 클래스로 대체할 수 없을뿐더러 Adapter 와 Target 이 단단히 엮어버렸습니다. 이는 배운대로 유연성을 해치는 구조이기에 사용을 권하지 않습니다.</p>
<h2 id="다중-어댑터"><a href="#다중-어댑터" class="headerlink" title="다중 어댑터"></a>다중 어댑터</h2><p>다중 어댑터는 기존에 <strong>하나의 타겟 인터페이스만 지원</strong>하는것이 아닌 <strong>다수의 타겟 인터페이스를 모두 지원</strong>하는걸 의미합니다. 하나의 어댑티 클래스를 <strong>여기 인터페이스뿐만 아니라 저 인터페이스에서도 사용하고 싶을때</strong> TargetOneInterface, TargetTwoInterface 를 하나의 어댑터 클래스로 연결하고 두 인터페이스의 모든 것을 구현하면 됩니다. 객체 어댑터가 아니라 클래스 어댑터라면 두 개의 클래스 TargetOne, TargetTwo 를 상속(extends) 하면 됩니다.</p>
<ul>
<li><strong>다중 (객체) 어댑터</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClientOne</span><span class="hljs-params">(TargetOneInterface interface1)</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ClientAnother</span><span class="hljs-params">(TargetTwoInterface interface2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetOneInterface</span>, <span class="hljs-title">TargetTwoInterface</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> Adaptee adaptee; </span><br><span class="line">    <span class="hljs-comment">// ... adaptee 함수를 활용해 TargetOne/TwoInterface 의 함수들을 모두 구현합니다.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h1 id="데코레이터-패턴-분장"><a href="#데코레이터-패턴-분장" class="headerlink" title="데코레이터 패턴 - 분장"></a>데코레이터 패턴 - 분장</h1></li>
</ul>
<p>데코레이터 패턴은 클래스에 추가적인 기능을 무수히 많이 추가하더라도 그 클래스는 본래 클래스의 기능을 유지하는 ‘분장’에 해당합니다. 데코레이터 패턴을 어댑터 패턴 다음에 같이 다루는 이유는 사실 원리는 어댑터-어댑티 개념과 같기 때문입니다. 어댑터가 <strong>Adaptee</strong>를 <strong>TargetInterface</strong>로 변장시켰다면, 데코레이터는 <strong>Decoratee</strong>를 <strong>Decoratee</strong> 자기 자신으로 분장시키는 꼴이 됩니다.</p>
<ul>
<li><strong>어댑터 패턴 - 변장</strong>: Adaptee != TargetInterface<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> Adaptee adaptee;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>데코레이터 패턴 - 분장</strong>: Decoratee == Decoratee<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decoratee</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> Decoratee decoratee; </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
데코레이터 패턴은 한번만 분장하기 위해 사용되지 않습니다. 자기 자신을 재귀적으로 계속 분장할 수 있는데요. 아무리 다양한 DecoratorA, DecoratorB 를 만들어 꾸미더라도 결국에 Decoratee 클래스기 때문에 기존 클라이언트에서는 크게 신경쓰지 않고 쓰던 그대로 사용하면 됩니다.</li>
</ul>
<blockquote>
<p>데코레이터 패턴은 Decorater 클래스가 Decoratee 를 Decoratee 로 분장하는것입니다.<br>Decorator 는 Decoratee 를 상속받기 때문에 그 자신도 Decoratee 가 될 수 있습니다.<br>따라서 Decorator 는 재귀적으로 Decoratee 에 위치할 수 있어 무한정 분장될 수 있습니다.</p>
</blockquote>
<ul>
<li><p><strong>데코레이티</strong>: 꾸미고 싶은 객체</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decoratee</span> </span>{</span><br><span class="line">    <span class="hljs-comment">// ... </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>데코레이터</strong>: 꾸며주는 객체</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decoratee</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> Decoratee decoratee; </span><br><span class="line">    <span class="hljs-comment">// ... decoratee 함수를 활용해 더 개선된 decoratee 함수로 확장합니다.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>단순한 코드는 위와 같지만 아마 책으로 접하신 데코레이터 패턴 코드는 아래와 같은 구조를 갖고 있었을것입니다.</p>
</li>
<li><p><strong>추상 데코레이터</strong>: 꾸며주는 추상 객체</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decoratee</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">protected</span> Decoratee decoratee; </span><br><span class="line">    Decorator(Decoratee decoratee) { </span><br><span class="line">        <span class="hljs-keyword">this</span>.decoratee = decoratee </span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><p><strong>구현 데코레이터</strong>: 꾸며주는 구현 객체</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoratorA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decorator</span> </span>{</span><br><span class="line">    DecoratorA(Decoratee decoratee) {</span><br><span class="line">        <span class="hljs-keyword">super</span>(decoratee)</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-comment">// ... </span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>정말 단순한 데코레이팅만 원하신다면 처음에 설명해드린 형태로도 충분합니다. 그렇다 하더라도 위와 같이 <strong>추상 데코레이터</strong>와 <strong>구현 데코레이터</strong>를 나누는 걸 추천드리는 이유는 다음과 같은 이점을 갖기 때문입니다.</p>
</li>
<li><p>구현 데코레이터에서 공통으로 필요로하는 로직이나 프로퍼티(특히 데코레이티)를 두고 구현 시 활용 가능합니다.</p>
</li>
<li><p>수많은 구현 데코레이터들을 추상 데코레이터 하나로 관리할 수 있습니다.</p>
</li>
</ul>
<p><strong>구현보다 인터페이스를 사용하라.**던 **디자인 패턴 제 1원칙</strong> 기억하시나요? 구현이 아닌 인터페이스(혹은 추상클래스)의 이점은 원하는 구현클래스를 붙였다 떼었다 할 수 있는 유용성과 재사용성이었습니다. 예를 들어 구현 데코레이터들을 하나의 리스트나 셋으로 담아 관리하고싶을때 추상 데코레이터 타입의 리스트, 셋을 생성하여 사용할 수 있겠죠.</p>
<h1 id="퍼사드-패턴-묶음"><a href="#퍼사드-패턴-묶음" class="headerlink" title="퍼사드 패턴 - 묶음"></a>퍼사드 패턴 - 묶음</h1><p>마지막으로 배울 패턴은 퍼사드 패턴입니다. 어댑터와 데코레이터 패턴은 <strong>각 하나의 어댑티나 데코레이티를 갖는다</strong>는 <strong>공통점</strong>이 있고, <strong>차이점</strong>은 **어댑터는 다른 클래스로 ‘변장’**하고 **데코레이터는 같은 데코레이터(사실상 데코레이티)로 ‘분장’**한다는 것 이었습니다. 퍼사드 패턴을 이 챕터에서 다룬다는것은 이들과 공통점이 있다는 것일텐데요. 어떤것이 같을까요?</p>
<p>퍼사드 패턴은 어댑터, 데코레이터 패턴의 공통점을 그대로 갖습니다. 어댑티, 데코레이티와 같이 활용하기 위한 클래스를 내부에 갖고있습니다. 다만 어댑터, 데코레이터가 어댑티, 데코레이티를 하나씩만 가졌다면 <strong>퍼사드는 엄청 많은 수의 클래스를 갖습니다.</strong> 그리고 어댑터와 데코레이터의 차이점이 ‘변장’이나 ‘분장’이냐의 차이였다면 퍼사드는 그저 그 자체로 새로운 클래스가 됩니다. <strong>어댑터 패턴</strong>도 클래스 자신이 아닌 <strong>다른 클래스</strong>로 ‘변장’한다고 했는데 그럼 퍼사드 패턴도 마찬가지가 아닐까요? <strong>아닙니다.</strong> 퍼사드 패턴은 특정 클래스가 다른 특정 클래스로 변장하는것이 아닌 <strong>다수의 클래스가 다른 하나의 클래스로 단순히 묶이는 것</strong>입니다.</p>
<ul>
<li><strong>(객체) 어댑터</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> Adaptee adaptee; </span><br><span class="line">    <span class="hljs-comment">// ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>퍼사드</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> ClassA classA;</span><br><span class="line">    <span class="hljs-keyword">private</span> ClassB classB; </span><br><span class="line">    <span class="hljs-keyword">private</span> ClassC classC; </span><br><span class="line">    <span class="hljs-comment">// ... ClassA, B, C 를 활용한 새 함수들을 만듭니다.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
퍼사드는 뒤에 어떠한 extends, implements 도 존재하지 않습니다. 단순히 여러 클래스를 묶어주는 하나의 클래스인 셈입니다. </li>
</ul>
<p>항상 마지막에 가면 집중력이 흐트러지곤 합니다. 중간쯤 읽다보면 세줄요약을 시급하게 찾는 자신을 발견하셨을겁니다. 그래도 꼭 한번은 다 잃고 아래 세줄요약을 읽어주시기 바랍니다. 그래야 머리속에 한번에 들어갈 수 있으니까요.</p>
<hr>
<p><strong>어댑터 패턴</strong></p>
<blockquote>
<p><strong>하나의 클래스</strong>(어댑티)를 <strong>다른 하나의 클래스</strong>(타겟 인터페이스)로 **’변장’**합니다.</p>
</blockquote>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TargetInterface</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> Adaptee adaptee; </span><br><span class="line">    <span class="hljs-comment">// ... adaptee 함수를 활용해 TargetInterface 의 함수를 구현합니다.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><strong>데코레이터 패턴</strong></p>
<blockquote>
<p><strong>하나의 클래스</strong>(데코레이티)를 <strong>그 하나의 클래스</strong>(데코레이티)로 **’분장’**합니다.</p>
</blockquote>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Decorator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Decoratee</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> Decoratee decoratee; </span><br><span class="line">    <span class="hljs-comment">// ... decoratee 함수를 활용해 더 개선된 decoratee 함수로 확장합니다.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>위 예제 코드는 이해를 위해 간단한 데코레이터 클래스를 작성했습니다. 본문에서 설명드린바와 같이 추상/구현 데코레이터로 사용하는걸 추천드립니다.</p>
<p><strong>퍼사드 패턴</strong></p>
<blockquote>
<p><strong>다수의 클래스</strong>를 <strong>다른 하나의 클래스</strong>로 <strong>묶습</strong>니다.</p>
</blockquote>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">private</span> ClassA classA;</span><br><span class="line">    <span class="hljs-keyword">private</span> ClassB classB; </span><br><span class="line">    <span class="hljs-keyword">private</span> ClassC classC; </span><br><span class="line">    <span class="hljs-comment">// ... ClassA, B, C 를 활용한 새 함수들을 만듭니다.</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></body></html></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2019-02-22</div></span><span class="level-item"><a class="link-muted" href="/categories/Design-Pattern/">Design Pattern</a><span> / </span><a class="link-muted" href="/categories/Design-Pattern/Factory/">Factory</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/02/22/factory-method-and-abstract-factory-pattern/">3. 팩토리 메소드, 추상 팩토리 패턴</a></h1><div class="content"><html><head></head><body><p>디자인 패턴은 무조건 아래 두 글을 선행해야합니다. 짧으니 간단히 읽고 오시면 이해가 쉽습니다.</p>
<ul>
<li><a href="https://aaronryu.github.io/2018/12/30/a-introduction-to-design-patterns/">1. 디자인 패턴에 앞서</a></li>
<li><a href="https://aaronryu.github.io/2019/02/21/two-principles-of-design-patterns/">2. 디자인 패턴의 제 1, 2 원칙</a></li>
</ul>
<p>설명에 사용할 코드는 Java-like Pseudo Code 입니다.</p>
<hr>
<h1 id="여러-상태에-따른-코드"><a href="#여러-상태에-따른-코드" class="headerlink" title="여러 상태에 따른 코드"></a>여러 상태에 따른 코드</h1><p>개발을 하다보면 어떤 <strong>상태에 따라 다른 플로</strong>를 작성해야할 상황이 발생합니다. 단순히 예/아니오 같은 <strong>단일 상태</strong>라면 if 문을 사용하도록 배웠고, <strong>다중 상태</strong>라면 if-else 혹은 switch 를 사용하도록 배웠습니다. 코드는 간단하게는 로직의 나열이라고 볼 수 있는데요. 우리의 실생활에서도 이처럼 다중 상태에 따라 다양한 작업을 수행하곤 합니다. 결국 모든 실생활도 if-else/switch 로 설명이 가능하다는 의미겠지요.</p>
<h2 id="if-else-에-“의존한”-처리"><a href="#if-else-에-“의존한”-처리" class="headerlink" title="if-else 에 “의존한” 처리"></a>if-else 에 “의존한” 처리</h2><ul>
<li><strong>라면 종류별 끓이기</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RamemMaker</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>{</span><br><span class="line">        Water water = <span class="hljs-keyword">new</span> Water(<span class="hljs-number">100</span>);</span><br><span class="line">        Ramen ramen;</span><br><span class="line">        heat(water);</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) {</span><br><span class="line">            ramen = 볶음라면;</span><br><span class="line">        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"국물"</span>) {</span><br><span class="line">            ramen = 국물라면;</span><br><span class="line">        }</span><br><span class="line">        water.add(ramen);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
라면 종류를 상태로 본다면 명시해준 라면 종류 String type 따라서 다른 라면을 끓입니다. 함수 makeRamen(String type) 은 아래와 같이 두 파트로 나눠볼 수 있습니다.</li>
</ul>
<ol>
<li><strong>상태</strong>:<br> 1.1. <strong>라면 종류</strong>를 고르고 </li>
<li><strong>처리</strong>: 라면을 <strong>끓입니다.</strong> </li>
</ol>
<p>상태와 처리라는 두 책임이 하나의 코드에 모여있군요. 1.상태와 2.처리를 한번 떼어내볼까요.</p>
<h2 id="if-else-를-“분리한”-처리"><a href="#if-else-를-“분리한”-처리" class="headerlink" title="if-else 를 “분리한” 처리"></a>if-else 를 “분리한” 처리</h2><ul>
<li><strong>라면 끓이기</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RamemMaker</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>{</span><br><span class="line">        Water water = <span class="hljs-keyword">new</span> Water(<span class="hljs-number">100</span>);</span><br><span class="line">        Ramen ramen = ramenGetter.getRamen(type);</span><br><span class="line">        heat(water);</span><br><span class="line">        water.add(ramen);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>라면 종류별 생성</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Ramen <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) {</span><br><span class="line">            <span class="hljs-keyword">return</span> 볶음라면;</span><br><span class="line">        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"국물"</span>) {</span><br><span class="line">            <span class="hljs-keyword">return</span> 국물라면;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
라면 종류별 생성을 책임지는 <strong>상태 함수</strong>는 <strong>재사용성</strong>을 갖게되었고, <strong>상태</strong> 책임이 더 명확해 졌습니다. 여기서 함수 getRamen(String type)와 같이 <strong>상태에 따라 알맞은 클래스를 만들어서 주입해주는 개념</strong>을 <strong>팩토리</strong>라고 합니다.</li>
</ul>
<blockquote>
<p><strong>팩토리</strong>는 if-else/switch 와 같이 <strong>상태</strong>에 따라 <strong>다른 클래스를 생성 및 주입해주는 개념</strong>를 의미합니다.<br>즉 **어떤 상태(What)**인지에 따라 **어떻게 처리(How)**할지가 다릅니다.</p>
</blockquote>
<h3 id="팩토리-메서드-패턴"><a href="#팩토리-메서드-패턴" class="headerlink" title="팩토리 메서드 패턴"></a>팩토리 메서드 패턴</h3><p>상태에 따라서 처리를 하기위해 <strong>RamemMaker.getRamen</strong> 함수 내부에서 if-else 문을 이용하여 분기를 탑니다. 이를 RamemMaker 의 <strong>추상 메서드</strong>로 만든다면 볶음라면(FriedRamemMaker), 국물라면(StewRamenMaker)에 따라 각각에서 <strong>getRamen</strong> 를 알맞게 구현하면 됩니다. 기존 if-else 기반 getRamen 을 간단히 <strong>팩토리</strong>라고 한다면 구현에 따라 달라지는 getRamen 추상 함수를 <strong>팩토리 메서드</strong>라고 합니다.</p>
<ul>
<li><strong>라면 생성 + 라면 끓이기</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RamemMaker</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> Ramem <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>{</span><br><span class="line">        Water water = <span class="hljs-keyword">new</span> Water(<span class="hljs-number">100</span>);</span><br><span class="line">        Ramen ramen = getRamen(type);</span><br><span class="line">        heat(water);</span><br><span class="line">        water.add(ramen);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>라면 종류별(볶음) 생성 + 라면 끓이기</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FriedRamenMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RamenMaker</span> </span>{</span><br><span class="line">    <span class="hljs-meta">@Override</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Ramen <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FriedRamen();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<blockquote>
<p><strong>팩토리 메서드 패턴</strong>은 팩토리 개념을 <strong>추상함수</strong>를 통해 원하는 <strong>구현 클래스</strong>를 반환하도록 하는것입니다.</p>
</blockquote>
</li>
</ul>
<h2 id="if-else-if-else"><a href="#if-else-if-else" class="headerlink" title="if-else + if-else"></a>if-else + if-else</h2><p>팩토리는 단순히 한 상태에 따른 구현(결과물) 클래스를 생성합니다. 라면은 <strong>라면 종류</strong>라는 한 상태뿐만 아니라 <strong>재료</strong>라는 추가 상태로도 세분화될 수 있습니다. 두 개의 상태가 생겼군요. 이를 <strong>이차원 상태</strong>로 보면 아래와 같이 if-else 문 안에 또 하나의 if-else 문을 갖는 구조로 볼 수 있습니다.</p>
<ul>
<li><strong>이차원 상태: 라면 업체 + 라면 종류</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (ingredient == <span class="hljs-string">"해물"</span>) {</span><br><span class="line">        <span class="hljs-keyword">return</span> 해물_볶음라면;</span><br><span class="line">    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ingredient == <span class="hljs-string">"고기"</span>) {</span><br><span class="line">        <span class="hljs-keyword">return</span> 고기_볶음라면;</span><br><span class="line">    }</span><br><span class="line">} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"국물"</span>) {</span><br><span class="line">    <span class="hljs-keyword">if</span> (ingredient == <span class="hljs-string">"해물"</span>) {</span><br><span class="line">        <span class="hljs-keyword">return</span> 해물_국물라면;</span><br><span class="line">    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ingredient == <span class="hljs-string">"고기"</span>) {</span><br><span class="line">        <span class="hljs-keyword">return</span> 고기_국물라면;</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
같은 볶음라면이지만 어떤 재료를 사용했는지에 따라서도 나눌 수 있는것이죠. 일차원 상태분기는 비교적 쉬웠습니다. 이차원 상태를 고려하도록 확장하려면 아래와 같이 될텐데요.</li>
</ul>
<ol>
<li><p><strong>상태</strong>:<br> 1.1. <strong>라면 종류</strong>를 고르고<br> 1.2. <strong>재료</strong>를 고르고 </p>
</li>
<li><p><strong>처리</strong>: 라면을 <strong>끓입니다.</strong> </p>
</li>
</ol>
<p>이번에는 1.상태와 2.처리라는 두 책임뿐 아니라 **두 상태인 1.1.과 1.2.**도 나누어야겠군요.</p>
<ul>
<li><strong>라면 끓이기</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RamemMaker</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRamen</span><span class="hljs-params">(String type)</span> </span>{</span><br><span class="line">        Water water = <span class="hljs-keyword">new</span> Water(<span class="hljs-number">100</span>);</span><br><span class="line">        Ramen ramen = ramenGetter.getRamen(type);</span><br><span class="line">        heat(water);</span><br><span class="line">        water.add(ramen);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>라면 종류별 생성</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    IngredientFactory ingredientFactory = <span class="hljs-keyword">new</span> MeatIngredientFactory();</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Ramen <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) {</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FriedRamen(ingredientFactory));</span><br><span class="line">        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"국물"</span>) {</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StewRamen(ingredientFactory));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>라면에 들어갈 재료</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IngredientFactory</span> </span>{</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Broth <span class="hljs-title">getBroth</span><span class="hljs-params">()</span></span>;</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Flakes <span class="hljs-title">getFlakes</span><span class="hljs-params">()</span></span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>라면에 들어갈 고기 재료</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MeatIngredientFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IngredientFactory</span> </span>{</span><br><span class="line">    <span class="hljs-comment">// 고기 육수</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Broth <span class="hljs-title">getBroth</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MeatBroth();</span><br><span class="line">    }</span><br><span class="line">    <span class="hljs-comment">// 고기 건더기</span></span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Flakes <span class="hljs-title">getFlakes</span><span class="hljs-params">()</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MeatFlakes();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
라면 종류가 함수 내 if-else 로 분기를 탔다면, 라면에 들어갈 재료는 추상 팩토리를 통해 어떤 재료든지 넣을 수 있도록 하였습니다. 전자를 <strong>팩토리</strong> 후자를 <strong>추상 팩토리</strong>라고 합니다. <strong>1) 어떤 종류</strong>의 라면인지는 <strong>팩토리(RamenGetter.getRamen)**에서 선택하고, **추상 팩토리(IngredientFactory)**의 구상 팩토리를 통해 **2) 특정 재료</strong>를 넣어주면 최종 라면 결과물이 나옵니다.</li>
</ul>
<h3 id="추상-팩토리-패턴"><a href="#추상-팩토리-패턴" class="headerlink" title="추상 팩토리 패턴"></a>추상 팩토리 패턴</h3><p>처음 팩토리를 배울때 “팩토리 메서드 패턴”과 “추상 팩토리 패턴” 두 패턴의 차이를 이해하는데 꽤나 힘들었습니다. 하지만 **팩토리(Factory)-결과물(Product)**의 개념을 잘 이해한다면 어렵지 않습니다.</p>
<p><strong>1) 팩토리 메서드 패턴</strong>은 추상 <strong>팩토리 메서드</strong>를 각 종류에 따라 구현해서 결과물(Product)을 바로 <strong>반환(Return)**했다면,<br>**2) 추상 팩토리 패턴</strong>은 <strong>추상 팩토리</strong>(Interface 혹은 Abstract)에 따라 결과물(Product)을 다르게 **생성(Make &amp; Return)**한다.</p>
<ul>
<li><strong>1) 팩토리 메서드 패턴</strong>: 볶음/국물 결정해서 바로 반환<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FriedRamenMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RamenMaker</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Ramen <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FriedRamen();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>2) 추상 팩토리 패턴</strong>: 볶음/국물 생성을 위한 재료 추상 클래스를 정의<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MeatRamenMaker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RamenMaker</span> </span>{</span><br><span class="line">    ...</span><br><span class="line">    IngredientFactory ingredientFactory = <span class="hljs-keyword">new</span> MeatIngredientFactory();</span><br><span class="line">    <span class="hljs-function"><span class="hljs-keyword">public</span> Ramen <span class="hljs-title">getRamen</span><span class="hljs-params">(String type)</span> </span>{</span><br><span class="line">        <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"볶음"</span>) {</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FriedRamen(ingredientFactory));</span><br><span class="line">        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (type == <span class="hljs-string">"국물"</span>) {</span><br><span class="line">            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StewRamen(ingredientFactory));</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
</li>
</ul>
<hr>
<p><strong>팩토리</strong></p>
<blockquote>
<p><strong>상태</strong>에 따라 그에 맞는 **결과물(Product)**를 반환합니다.</p>
</blockquote>
<p><strong>팩토리 메서드 패턴</strong></p>
<blockquote>
<p>추상 <strong>팩토리 메서드</strong>를 각 <strong>상태</strong>에 따라 구현하여 **결과물(Product)**을 바로 반환합니다.</p>
</blockquote>
<p><strong>추상 팩토리 패턴</strong></p>
<blockquote>
<p><strong>추상 팩토리</strong>(Interface 혹은 Abstract)에 따라 결과물(Product)을 다르게 **생성(Make &amp; Return)**한다.</p>
</blockquote>
</body></html></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2019-02-21</div></span><span class="level-item"><a class="link-muted" href="/categories/Design-Pattern/">Design Pattern</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/02/21/two-principles-of-design-patterns/">2. 디자인 패턴의 제 1, 2 원칙</a></h1><div class="content"><html><head></head><body><p>설명에 사용할 코드는 Java-like Pseudo Code 입니다.</p>
<hr>
<p>내게 대학교 시절에 객체지향 프로그램은 다형성과 상속뿐이었지만 책이 아닌 실제 프로그래밍으로 접한 객체지향 프로그램은 학문이 아니라 실전이었습니다. 왜 이걸 배웠고 이게 사실 어떤 의미를 갖는건지 그제서야 깨달을 수 있었습니다. 여기서는 짧게 우리가 생각했던 상속을 살펴보고 디자인 패턴으로 도약하기 위해 상속을 버리는 두 개의 원칙을 익히려고 합니다.</p>
<h1 id="상속-객체지향-프로그램"><a href="#상속-객체지향-프로그램" class="headerlink" title="상속 = 객체지향 프로그램?"></a>상속 = 객체지향 프로그램?</h1><p>처음 엔터프라이즈 객체지향 프로그램을 작성한다고 가정해봅시다. 학교에서 공부한대로라면 <strong>객체지향 프로그램은 상속</strong>이라고 배웠습니다. 그래서 우리는 과감히 상위 클래스를 만들고 이를 상속하여 하위 개념에 해당하는 클래스를 활용할 것입니다. 그리고 객체지향 프로그래밍 프로젝트 #1 이라고 이름 짓겠죠. 코드는 아래 헤드퍼스트 책의 예제와 같을 것입니다.</p>
<h2 id="처음-배웠던-상속"><a href="#처음-배웠던-상속" class="headerlink" title="처음 배웠던 상속"></a>처음 배웠던 상속</h2><ul>
<li><strong>상위 클래스 + 상위 행위</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span></span></span><br><span class="line"><span class="hljs-class"></span>{ swim(), display(), fly(), quack() }</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>하위 클래스 + 상위 행위 확장</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedHeadDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duck</span> </span></span><br><span class="line"><span class="hljs-class"></span>{ swim(), display(), fly(), quack() }</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RubberDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duck</span> </span></span><br><span class="line"><span class="hljs-class"></span>{ swim(), display(), fly(){ <span class="hljs-keyword">null</span> }, quack() }</span><br></pre></td></tr></tbody></table></figure>
상속을 사용하였더니 상위 Duck 클래스에 있는 모든 상위 행위들을 하위 Duck 클래스들이 모두 갖게됩니다. 어떤 <strong>하위 Duck 클래스는 의지와 상관없이 갖고싶지 않지만 무조건 모든 상위 행위를 갖고 확장해야합니다.</strong> 개발에 있어 불필요한 제약을 갖게되는 것입니다. 그럼 아래와 같이 <strong>선택적으로 행위를 가져갈 수 있도록 행위를 인터페이스로 분리해 가져보겠습니다.</strong></li>
</ul>
<h2 id="상속-대신-인터페이스"><a href="#상속-대신-인터페이스" class="headerlink" title="상속 대신 인터페이스"></a>상속 대신 인터페이스</h2><ul>
<li><strong>상위 클래스</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span> </span></span><br><span class="line"><span class="hljs-class"></span>{ swim(), display() }</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>행위 인터페이스</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>{ fly() }</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Quackable</span> </span>{ quack() }</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>하위 클래스 + 행위 인터페이스 구현</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedHeadDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duck</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Flyable</span>, <span class="hljs-title">Quackable</span></span></span><br><span class="line"><span class="hljs-class"></span>{ swim(), display(), fly(), quack() }</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RubberDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duck</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Quackable</span> </span></span><br><span class="line"><span class="hljs-class"></span>{ swim(), display(), quack() }</span><br></pre></td></tr></tbody></table></figure>
드디어 <strong>상위 클래스에 속하던 행위를 인터페이스로 분리하여 하위 클래스에 원하는 행위들만 붙일 수 있게 되었습니다.</strong> 하지만 두 개의 오리가 같은 소리를 갖는다면 Quackable 오리 각각에 quack() 을 똑같이 구현해주어야 합니다. 두 개의 오리면 괜찮겠지만 100 중 70 종의 오리가 같은 소리를 낸다면 70 개의 같은 quack() 구현 코드를 작성해야합니다. 그 중 몇 개의 quack() 소리를 다른 타입으로 바꾸려해도 같은 반복작업이 생기게 됩니다. 그럼 <strong>행위 인터페이스 구현을 따로 만들어서 원하는 구현을 선택적으로 가져보면</strong> 더 좋지 않을까요?</li>
</ul>
<h2 id="인터페이스-‘구현’이-아닌-‘구성’"><a href="#인터페이스-‘구현’이-아닌-‘구성’" class="headerlink" title="인터페이스 ‘구현’이 아닌 ‘구성’"></a>인터페이스 ‘구현’이 아닌 ‘구성’</h2><ul>
<li><strong>상위 클래스</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span> </span></span><br><span class="line"><span class="hljs-class"></span>{ <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span></span>;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Quackable</span></span>;</span><br><span class="line">  swim(), display(), doFly(){ Flyable.fly() }, doQuack(){ Quackable.quack() } }</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>행위 인터페이스</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>{ fly() }</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Quackable</span> </span>{ quack() }</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>행위 인터페이스 구현</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotFlyable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Flyable</span> </span>{ fly(){...} }</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperFlyable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Flyable</span> </span>{ fly(){...} }</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoutQuackable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Quackable</span> </span>{ quack(){...} }</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuiteQuackable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Quackable</span> </span>{ quack(){...} }</span><br></pre></td></tr></tbody></table></figure></li>
<li><strong>하위 클래스 + 행위 인터페이스 구현</strong><figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedHeadDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duck</span></span></span><br><span class="line"><span class="hljs-class"></span>{ <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>= <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperFlyable</span>()</span>;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Quackable</span> </span>= <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ShoutQuackable</span>()</span>;</span><br><span class="line">  swim(), display(), doFly(){ Flyable.fly() }, doQuack(){ Quackable.quack() } }</span><br><span class="line"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RubberDuck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Duck</span></span></span><br><span class="line"><span class="hljs-class"></span>{ <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Flyable</span> </span>= <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotFlyable</span>()</span>;</span><br><span class="line">  <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Quackable</span> </span>= <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QuiteQuackable</span>()</span>;</span><br><span class="line">  swim(), display(), doFly(){ Flyable.fly() }, doQuack(){ Quackable.quack() } }</span><br></pre></td></tr></tbody></table></figure>
인터페이스를 구현하는것이 아닌 구성을 통해 클래스 내부 변수로 갖게되면서 원하는 행위 인터페이스 구현을 마음껏 갖고 바꿀 수 있게 되었습니다. 이로써 인터페이스를 대학교때 배웠듯이 클래스의 템플릿이다.라는 이해에서 조금 더 나아가 <strong>클래스가 갖는 행위나 특성을 담을 수 있는 하나의 ‘변수’**로 생각할 수 있으면 좋을것 같습니다. 이것이 우리가 **다형성</strong>을 배운 이유이기도 합니다.</li>
</ul>
<hr>
<h1 id="디자인-패턴의-제-1-2-원칙"><a href="#디자인-패턴의-제-1-2-원칙" class="headerlink" title="디자인 패턴의 제 1, 2 원칙"></a>디자인 패턴의 제 1, 2 원칙</h1><p>위에서 배운 내용은 사실 아래 두 원칙에 해당합니다.<br>복습 겸 한번 더 복기하고 다음 챕터로 넘어가도록 하겠습니다.</p>
<h2 id="구현보다-인터페이스에-맞춰서-코딩한다"><a href="#구현보다-인터페이스에-맞춰서-코딩한다" class="headerlink" title="구현보다 인터페이스에 맞춰서 코딩한다."></a>구현보다 인터페이스에 맞춰서 코딩한다.</h2><blockquote>
<p><strong>구현은 언제나 바뀔 수 있다. 인터페이스를 통해 유연하게 구현하자</strong></p>
</blockquote>
<p>fly(), quack() 같은 행위를 클래스 내부에서 구현하지 않고 인터페이스로 대체함으로써 필요한 것과 필요하지 않은 것들을 분리할 수 있습니다.</p>
<h2 id="인터페이스는-‘상속’보다는-‘구성’으로-사용하자"><a href="#인터페이스는-‘상속’보다는-‘구성’으로-사용하자" class="headerlink" title="인터페이스는 ‘상속’보다는 ‘구성’으로 사용하자"></a>인터페이스는 ‘상속’보다는 ‘구성’으로 사용하자</h2><blockquote>
<p><strong>인터페이스를 ‘상속’이 아닌 ‘구성’ 시 원하는 구현을 붙였다 떼었다 할 수 있다.</strong></p>
</blockquote>
<p>인터페이스를 ‘상속’하면 인터페이스의 모든 함수들을 그를 상속하는 클래스 안에서 구현해야합니다. 구현이 클래스 안에 갖혀버림과 동시에 구현과 클래스 내부간의 강결합이 생깁니다. </p>
<p>반면 ‘구성’을 사용하면 인터페이스를 구현한 구현 클래스 단 하나로 어느곳에서든지 사용 가능합니다. 레고처럼 붙였다 떼었다 할 수 있어 쉽게 바꿀 수 있고, <em>구현 클래스</em> 로직과 <em>그걸 사용하는 클래스</em> 간 결합이 풀리게 됩니다.</p>
</body></html></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2019-02-17</div></span><span class="level-item"><a class="link-muted" href="/categories/Workplace/">Workplace</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/02/17/how-do-i-make-email-address/">프로페셔널해 보이는 메일 주소 만드는 방법</a></h1><div class="content"><html><head></head><body><h2 id="좋은-메일-주소"><a href="#좋은-메일-주소" class="headerlink" title="좋은 메일 주소"></a>좋은 메일 주소</h2><p>메일은 내용 및 형식뿐만 아니라 주소에도 예절이 있습니다. 가끔 전화번호에도 외우기 쉬운 전화번호들이 있습니다. 어떤 일에 연락하기 적합한 사람을 찾을때 머릿속에서 가장 쉽고, 먼저 떠오른다면 업무에 있어서나 헤드헌터에 의해 회사와 연결될때 더 많은 성과를 가져갈 수 있겠죠.</p>
<p>우리의 이메일 주소는 대개 아이디에 그 뒤에 네이버나 다음같은 도메인이 붙습니다.<br>문제는 우리가 매우 어린나이에 네이버주니어 같은 서비스를 이용하기 위해 해당 도메인에 가입을 했다는것입니다. 그러다보면 우스꽝스럽거나 어떤 캐릭터 이름 혹은 귀여운 아이디가 대다수입니다. 마치 과거 버디버디 아이디를 들췄을때 부끄러운 그것 말이죠. 부끄러운건 당사자 뿐만이 아닙니다. 그 아이디로 연락을 하는 상대분들은 어떨까요.</p>
<p>외국 대학, 기업뿐아니라 외국인과 같이 커뮤니케이션을 하고싶다면 위와 같은 과거의 주소는 지양하는것이 좋습니다. 계속 써왔던 메일이라 새 메일주소를 생성하는것이 불편하시다면 __메일 포워딩__을 사용하시길 권장합니다.</p>
<h2 id="추천-이메일"><a href="#추천-이메일" class="headerlink" title="추천 이메일"></a>추천 이메일</h2><p>일반적으로 다음과 같은 규칙을 갖기를 추천합니다. 핵심은 기억하기 쉬운 이메일 입니다.<br>각 규칙에 들어가는 단어들은 첫글자나 약어로 하셔도 좋습니다만 되도록이면 온전한 단어로 쓰시는것이 기억하기 좋습니다.</p>
<ul>
<li>First Name 이름</li>
<li>First Name 이름 + Last Name 성</li>
<li>Generic : 메일 수신 목적에 맞는 이름</li>
</ul>
<p>예는 다음과 같습니다.</p>
<ul>
<li><a href="mailto:aaron@domain.com">aaron@domain.com</a></li>
<li><a href="mailto:aaronryu@domain.com">aaronryu@domain.com</a></li>
<li><a href="mailto:contact@domain.com">contact@domain.com</a></li>
</ul>
<p>만약 Gmail 을 사용하신다면 다음과 같은 좋은 기능<a target="_blank" rel="noopener" href="http://765749953.tistory.com/10">^1</a>을 제공해주니 활용하시는것이 좋습니다.</p>
<ol>
<li><strong>.</strong> : 마음껏 점을 찍어서 가독성을 높힐 수 있습니다. 점을 찍지않은 본래의 메일로 자동 포워딩됩니다.<ul>
<li><a href="mailto:aaron.ryu@domain.com">aaron.ryu@domain.com</a></li>
</ul>
</li>
</ol>
<ol start="2">
<li><strong>+</strong> : 받을때 특정 필터를 적용한 채로 메일을 수신할 수 있습니다. 이 또한 본래의 메일로 자동 포워딩됩니다. 이력서에 명시한 메일은 aaron.ryu+recruit 이라면 recruit 필터 규칙에 걸러집니다. <ul>
<li><a href="mailto:aaron.ryu+recruit@domain.com">aaron.ryu+recruit@domain.com</a></li>
</ul>
</li>
</ol>
<h2 id="중복-이메일"><a href="#중복-이메일" class="headerlink" title="중복 이메일"></a>중복 이메일</h2><p>개인적으로 지메일에서 메일을 생성하려하니 중복된 주소가 이미 생성되어있었습니다.<br>그럴때에는 각 아이디나 메일 입력 폼에 숫자를 붙이거나 성과 이름의 방향을 바꿔 추천해줍니다만 사용하지 않는것이 좋습니다. 외국인들은 이름 내 순서를 이름 + 성 으로 사용하기때문에 그 규칙을 그대로 따르는것이 좋습니다. 그렇지 않다면 외국인이 “성” 으로 저를 부를지도 모릅니다.<br>생년을 적는다면 특히 나이에 대해 동양만큼 민감하지 않은 외국인들에게 그 사람을 떠올렸을때 몇년에 태어났는지까지 기억해야하는 불필요한 정보를 제공하게 됩니다.</p>
<p>이럴땐 어떻게 하는것이 좋을까요.<br>쉽게는 직무를 명시할 수 있겠고, 번거롭게는 하나의 도메인을 생성하는것도 좋습니다.</p>
<ul>
<li><a href="mailto:aaron.ryu.dev@domain.com">aaron.ryu.dev@domain.com</a> = <a href="mailto:aaronryudev@domain.com">aaronryudev@domain.com</a></li>
<li><a href="mailto:aaronryu@aaronryu.com">aaronryu@aaronryu.com</a></li>
</ul>
<p>아이디뿐만 아니라 도메인에도 자신의 이름이 중복으로 들어가서 언프로페셔널하게 느껴질것이 걱정되신다면 걱정하지 않으셔도 될 것 같습니다. 오히려 자신만의 도메인이 있다는것과 메일 시 직접 그 사람과 이야기한다는 느낌을 줄 수 있을 것입니다.<a target="_blank" rel="noopener" href="https://workplace.stackexchange.com/questions/127195/does-repeating-name-in-email-address-look-unprofessional">^2</a></p>
<hr>
<p>1: <a target="_blank" rel="noopener" href="http://consultantjournal.com/blog/professional-email-address-ideas-for-common-names">http://consultantjournal.com/blog/professional-email-address-ideas-for-common-names</a><br>2: <a target="_blank" rel="noopener" href="https://yeonlab.com/check-your-email-address/">https://yeonlab.com/check-your-email-address/</a><br>3: <a target="_blank" rel="noopener" href="https://workplace.stackexchange.com/questions/11731/what-should-a-professional-email-address-look-like">https://workplace.stackexchange.com/questions/11731/what-should-a-professional-email-address-look-like</a></p>
</body></html></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><div>2018-12-30</div></span><span class="level-item"><a class="link-muted" href="/categories/Design-Pattern/">Design Pattern</a></span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2018/12/30/a-introduction-to-design-patterns/">1. 디자인 패턴에 앞서</a></h1><div class="content"><html><head></head><body><p>디자인 패턴은 대학교에서 간단하게만 배웠던 기억이 닙니다. 대학원에서도 입사 준비 때도 주변에서는 디자인 패턴이 중요하다지만 실제로 잘 사용하는 사람은 없었고, 이게 왜 중요한지에 대해서도 체감하기 힘들었었습니다. 어렸을때는 내 코드에 대한 리뷰어나 배울만한 시니어 개발자들이 없었으니 당연하다 생각합니다. 제가 코딩과 공부를 능동적으로 안해온것이 크겠지만 패턴이 왜 쓰이는지 경험적으로 습득한것은 입사하고 나서부터 였으니까요.</p>
<h1 id="디자인-패턴"><a href="#디자인-패턴" class="headerlink" title="디자인 패턴"></a>디자인 패턴</h1><p>디자인 패턴은 짧게 <strong>“객체지향 패러다임에서 더 좋은 코드란 무엇인가에 대한 고민의 결과”</strong> 입니다.</p>
<ul>
<li><strong>중복의 최소화</strong>: 한 곳의 수정이 중복된 다른 코드에서의 수정을 동반해선 안됩니다</li>
<li><strong>코드 변경의 용이성</strong>: 코드는 항상 완벽하지 않고, 요구사항은 상시 바뀔 수 있습니다.</li>
<li><strong>재사용성</strong>: 정돈된 코드는 전혀 다른 요구사항 및 비슷한 경우에도 그대로 사용이 가능합니다.</li>
</ul>
<h1 id="너무나도-먼-디자인-패턴"><a href="#너무나도-먼-디자인-패턴" class="headerlink" title="너무나도 먼 디자인 패턴"></a>너무나도 먼 디자인 패턴</h1><p>우리는 어떻게보면 디자인 패턴을 모르는것이 당연합니다. </p>
<blockquote>
<p>코드 한 줄의 변경이 다른 줄의 변경을 일으킬만한 큰 프로젝트를 만들어본적이 없습니다. </p>
</blockquote>
<p>교내 팀 프로젝트에서 Web Application 으로 API 서버를 만들어서 고객 폰의 앱으로 주변 AP 정보를 파싱하고, LCD 패널이 붙은 라즈베리 파이로 해당 고객 위치에 따른 재실표시기를 만들었을때도 정말 코드가 단순명료했습니다. 학생분들이라면 아시죠 환경 계획 및 구축이 60% 고 개발이 20% 입니다. 남은 20% 은 술마셔야죠. </p>
<blockquote>
<p>팀 프로젝트로 만든 코드는 다신 볼일이 없습니다.<br>요구사항 변경을 요청할 교수도 다른 프로젝트에 활용할 일도 없습니다.</p>
</blockquote>
<p>팀 프로젝트 발표를 마치고 학점을 받으면 친척동생이 놀러와 롤을 깔때즘 용량문제로 소스코드를 지우는 상황에 이릅니다. 가끔 입사 준비 중 볼일이 있습니다만 예로 학부생 코드는 고쳐쓰는게 아니라했습니다.</p>
<blockquote>
<p><strong>결국엔 직접 해보아야 합니다.</strong><br>본 카테고리에선 직접 해보며 조금이나마 짧고 명료하게 정리해놓으려합니다.<br>복습없인 항상 까먹기 일수거든요.</p>
</blockquote>
<p>앞으로 본 카테고리에선 여러 디자인 패턴들에 대해서 살펴보려합니다. 각 패턴의 설명은 기본적으로 글을 사용하겠지만 <strong>클래스 다이어그램</strong>을 통해 이해를 도우려고 합니다.</p>
<h1 id="클래스-다이어그램-화살표"><a href="#클래스-다이어그램-화살표" class="headerlink" title="클래스 다이어그램 화살표"></a>클래스 다이어그램 화살표</h1><p>클래스 다이어그램은 이름 자체가 내포하고있듯 Class 간의 관계를 표로 간단하게 설명한 것으로 Class 개념이 존재하는 객체지향 프로그래밍(OOP)에서 프로젝트 구현을 위한 설계도라고 보시면 될 것 같습니다. 클래스 다이어그램 자체로 한 챕터 분량이지만, 디자인 패턴에는 Class, Interface 이 둘만 필요하므로 딱 핵심적인 화살표 세 개만 살펴보겠습니다. 앞으로 Java 기반으로 설명하겠습니다.</p>
<h2 id="implements-구현"><a href="#implements-구현" class="headerlink" title="implements (구현)"></a>implements (구현)</h2><center><img src="/2018/12/30/a-introduction-to-design-patterns/implements.svg" class=""></center>

<p>일반적으로 코드는 인터페이스를 단위로 구성됩니다. 사용하려는 구현 클래스를 코드 내에 지정하지 않고 인터페이스만을 명시하고 그 인터페이스의 위치에 원하는 구현 클래스를 연결(주입)하여 실제 작업을 수행합니다. 앞으로 설명할 모든 디자인 패턴의 주축이 되는 제 1 원칙이니 조금 더 설명드리겠습니다. </p>
<p>학생분들은 모든 클래스를 사용할때 아래 코드를 사용하실겁니다.</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ConcreteClass <span class="hljs-class"><span class="hljs-keyword">class</span> </span>= <span class="hljs-keyword">new</span> ConcreteClass();</span><br></pre></td></tr></tbody></table></figure>
<p>우리가 배운 다형성을 활용하면 <strong>인터페이스와 구현 클래스를 나눠서 인터페이스에 우리가 원하는 구현 클래스들을 다음과 같이 동적으로 주입</strong>할 수 있습니다.</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Interface <span class="hljs-class"><span class="hljs-keyword">class</span> </span>= <span class="hljs-keyword">new</span> ConcreteClass();</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Interface <span class="hljs-class"><span class="hljs-keyword">class</span> </span>= <span class="hljs-keyword">new</span> SuperConcreteClass();</span><br></pre></td></tr></tbody></table></figure>
<p>주입을 직접 Interface 에 하지않고 아래처럼 더 간편하게 함수를 통해 해줄 수 있습니다.</p>
<figure class="highlight java hljs"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="hljs-keyword">private</span> Interface <span class="hljs-class"><span class="hljs-keyword">class</span></span>;</span><br><span class="line"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setClass</span><span class="hljs-params">(Interface class)</span> </span>{</span><br><span class="line">    <span class="hljs-keyword">this</span>.class = <span class="hljs-class"><span class="hljs-keyword">class</span></span>;</span><br><span class="line">}</span><br><span class="line">setClass(<span class="hljs-keyword">new</span> ConcreteClass();</span><br></pre></td></tr></tbody></table></figure>
<p>사용하려는 구현 클래스가 무엇인지 바로 명시하지 않고 원하는 구현 클래스를 동적으로 Interface 에 외부에서 주입하기 때문에 결정권을 갖지 않는다는 이유로 <strong>Dependency Injection</strong>, 내지는 <strong>Inversion of Control</strong> 이라 부릅니다.</p>
<h2 id="extends-상속"><a href="#extends-상속" class="headerlink" title="extends (상속)"></a>extends (상속)</h2><center><img src="/2018/12/30/a-introduction-to-design-patterns/extends.svg" class=""></center>

<p>상속은 클래스의 몇몇 함수에 대해 추가적인 기능이나 다른 로직의 함수로 대체하고 싶을때 사용합니다. 일반적으로 대학교때 객체지향 프로그램의 가장 큰 특성을 상속으로 배우고 Animal 과 같은 상위  클래스와 그를 상속하는 Cat, Dog 같은 하위 개념 클래스를 예제로 배우니 상위, 하위 클래스를 사용할때 상속을 많이 사용합니다. 하지만 상위, 하위 개념은 앞서 설명드린 implements(구현)에 해당합니다. 상위 개념을 Interface 로 두고 상위 개념에 해당하는 함수들을 하위 개념 Class 에서 명시하는것입니다. </p>
<p>반면 extends(상속)은 extends 가 의미하는대로 단순 확장에 해당합니다. Cat 중에서 줄무늬가 있는 Cat이 있을때 StripeCat 은 Cat 의 줄무늬를 제외한 모든 함수와 변수는 동일합니다.</p>
<h2 id="composite-구성-합성"><a href="#composite-구성-합성" class="headerlink" title="composite (구성, 합성)"></a>composite (구성, 합성)</h2><center><img src="/2018/12/30/a-introduction-to-design-patterns/has.svg" class=""></center>

<p>특정 클래스가 특정 클래스를 내부 변수로 갖고있는것을 뜻합니다. 구성은 단순히 갖고있다는 의미인데 왜 패턴에서 중요하게 쓰일까요. extend 가 interface 와 composite 의 조합으로 표현될 수 있기 때문입니다.</p>
<center><img src="/2018/12/30/a-introduction-to-design-patterns/extends2.svg" class=""></center>

<p>CatClass 가 줄무늬를 갖는것을 상속을 통해 Sprite 함수 및 변수를 넣어주지 않고, “종” 이라는 하나의 상위 클래스를 두고 “줄무늬종” 임을 하위 클래스로 명시해준다면 상위 개념인 “종”에 그 하위에 무슨 “종”이든 다 넣을 수 있는 확장성을 갖게됩니다. 바로 위 extends(상속)과 비교해보십시오. <strong>좌측에 SpriteCatClass 가 갖고있던 Sprite 정보가 우측 클래스로 이동했습니다.</strong> <strong>Inversion of Control</strong> 의 의미가 조금 짐작되시는지요.</p>
<center><img src="/2018/12/30/a-introduction-to-design-patterns/extends3.svg" class=""></center>

<p>CatClass 가 줄무늬뿐만 아니라 두 눈이 오드아이라고 설정해봅시다. 이 또한 상위-하위 개념인 interface 와 has 를 통해 EyesClass 에 OddEyesClass 를 명시하는것이 좋겠지요. 아까 제 1 원칙 <strong>“구현이 아닌 인터페이스에 맞춰 프로그래밍 한다.”</strong> 다음에 제 2 원칙 <strong>“상속대신 구성과 인터페이스를 사용한다”</strong> 가 되겠습니다.</p>
<p>이제 이 세 개의 화살표(구현, 상속, 구성)와 두 개의 원칙으로 디자인 패턴들을 살펴보겠습니다.</p>
<hr>
<p>1: <a target="_blank" rel="noopener" href="https://martinfowler.com/articles/injection.html">https://martinfowler.com/articles/injection.html</a><br>2: <a target="_blank" rel="noopener" href="http://www.nextree.co.kr/p11247/">http://www.nextree.co.kr/p11247/</a><br>3: <a target="_blank" rel="noopener" href="http://www.nextree.co.kr/p6753/">http://www.nextree.co.kr/p6753/</a></p>
</body></html></div></article></div><nav class="pagination" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/">Previous</a></div><div class="pagination-next is-invisible is-hidden-mobile"><a href="/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><a class="pagination-link is-current" href="/page/2/">2</a></li></ul></nav></div><div class="column column-left is-3-tablet is-3-desktop is-3-widescreen  order-1 is-sticky"><!--!--><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Deployment/"><span class="level-start"><span class="level-item">Deployment</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul><li><a class="level is-mobile" href="/categories/Deployment/Docker/"><span class="level-start"><span class="level-item">Docker</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Design-Pattern/"><span class="level-start"><span class="level-item">Design Pattern</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul><li><a class="level is-mobile" href="/categories/Design-Pattern/Adapter-Decorator/"><span class="level-start"><span class="level-item">Adapter, Decorator</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Factory/"><span class="level-start"><span class="level-item">Factory</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Observer/"><span class="level-start"><span class="level-item">Observer</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Design-Pattern/Singleton/"><span class="level-start"><span class="level-item">Singleton</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Language/"><span class="level-start"><span class="level-item">Language</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul><li><a class="level is-mobile" href="/categories/Language/Functional-Programming/"><span class="level-start"><span class="level-item">Functional Programming</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Java-8/"><span class="level-start"><span class="level-item">Java 8</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Javascript/"><span class="level-start"><span class="level-item">Javascript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Kotlin/"><span class="level-start"><span class="level-item">Kotlin</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/Language/Swift-4-iOS/"><span class="level-start"><span class="level-item">Swift 4+ / iOS</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Programming/"><span class="level-start"><span class="level-item">Programming</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul><li><a class="level is-mobile" href="/categories/Programming/Develop/"><span class="level-start"><span class="level-item">Develop</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Programming/Licenses/"><span class="level-start"><span class="level-item">Licenses</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile" href="/categories/Workplace/"><span class="level-start"><span class="level-item">Workplace</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></div></div></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Aaron Ryu"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Aaron Ryu</p><p class="is-size-6 is-block">Software Engineer</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">16</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">17</p></a></div></div></nav><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/aaronryu"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitlab" href="https://gitlab.com/aaronryu"><i class="fab fa-gitlab"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div></div></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/">Crucian Carp</a><p class="is-size-7"><span>&copy; 2021 Aaron Ryu</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: false,
                    fold: ''
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>